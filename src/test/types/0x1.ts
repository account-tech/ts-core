/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */

/* Generated types for 0x1, original address 0x1 */

import { TypeDescriptor, ANY_TYPE } from "@typemove/move";
import { MoveCoder, TypedEventInstance } from "@typemove/sui";

import { defaultMoveCoder } from "@typemove/sui";

import {
  ZERO_ADDRESS,
  TypedDevInspectResults,
  getMoveCoder,
} from "@typemove/sui";
import {
  TransactionBlock,
  TransactionArgument,
  TransactionObjectArgument,
} from "@mysten/sui.js/transactions";
import { SuiClient } from "@mysten/sui.js/client";
import {
  transactionArgumentOrObject,
  transactionArgumentOrPure,
  transactionArgumentOrVec,
} from "@typemove/sui";

export namespace address {
  export namespace builder {
    export function length(
      tx: TransactionBlock,
      args: [],
    ): TransactionArgument & [] {
      const _args: any[] = [];

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::address::length",
        arguments: _args,
      });
    }
  }
  export namespace view {
    export async function length(
      client: SuiClient,
      args: [],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new TransactionBlock();
      builder.length(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
  }
}

export namespace ascii {
  export type Char = string;
  export namespace Char {
    export const TYPE_QNAME = "0x1::ascii::Char";

    const TYPE = new TypeDescriptor<Char>(Char.TYPE_QNAME);

    export function type(): TypeDescriptor<Char> {
      return TYPE.apply();
    }
  }

  export type String = string;
  export namespace String {
    export const TYPE_QNAME = "0x1::ascii::String";

    const TYPE = new TypeDescriptor<String>(String.TYPE_QNAME);

    export function type(): TypeDescriptor<String> {
      return TYPE.apply();
    }
  }

  export namespace builder {
    export function allCharactersPrintable(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::ascii::all_characters_printable",
        arguments: _args,
      });
    }
    export function asBytes(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::ascii::as_bytes",
        arguments: _args,
      });
    }
    export function byte(
      tx: TransactionBlock,
      args: [ascii.Char | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::ascii::byte",
        arguments: _args,
      });
    }
    export function char(
      tx: TransactionBlock,
      args: [number | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::ascii::char",
        arguments: _args,
      });
    }
    export function intoBytes(
      tx: TransactionBlock,
      args: [ascii.String | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::ascii::into_bytes",
        arguments: _args,
      });
    }
    export function isPrintableChar(
      tx: TransactionBlock,
      args: [number | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::ascii::is_printable_char",
        arguments: _args,
      });
    }
    export function isValidChar(
      tx: TransactionBlock,
      args: [number | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::ascii::is_valid_char",
        arguments: _args,
      });
    }
    export function length(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::ascii::length",
        arguments: _args,
      });
    }
    export function popChar(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::ascii::pop_char",
        arguments: _args,
      });
    }
    export function pushChar(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        ascii.Char | TransactionArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::ascii::push_char",
        arguments: _args,
      });
    }
    export function string_(
      tx: TransactionBlock,
      args: [(string | TransactionObjectArgument)[] | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrVec(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::ascii::string",
        arguments: _args,
      });
    }
    export function tryString(
      tx: TransactionBlock,
      args: [(string | TransactionObjectArgument)[] | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrVec(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::ascii::try_string",
        arguments: _args,
      });
    }
  }
  export namespace view {
    export async function allCharactersPrintable(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): Promise<TypedDevInspectResults<[Boolean]>> {
      const tx = new TransactionBlock();
      builder.allCharactersPrintable(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[Boolean]>(
        inspectRes,
      );
    }
    export async function asBytes(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new TransactionBlock();
      builder.asBytes(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function byte(
      client: SuiClient,
      args: [ascii.Char | TransactionArgument],
    ): Promise<TypedDevInspectResults<[number]>> {
      const tx = new TransactionBlock();
      builder.byte(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[number]>(
        inspectRes,
      );
    }
    export async function char(
      client: SuiClient,
      args: [number | TransactionArgument],
    ): Promise<TypedDevInspectResults<[ascii.Char]>> {
      const tx = new TransactionBlock();
      builder.char(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[ascii.Char]>(
        inspectRes,
      );
    }
    export async function intoBytes(
      client: SuiClient,
      args: [ascii.String | TransactionArgument],
    ): Promise<TypedDevInspectResults<[number[]]>> {
      const tx = new TransactionBlock();
      builder.intoBytes(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[number[]]>(
        inspectRes,
      );
    }
    export async function isPrintableChar(
      client: SuiClient,
      args: [number | TransactionArgument],
    ): Promise<TypedDevInspectResults<[Boolean]>> {
      const tx = new TransactionBlock();
      builder.isPrintableChar(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[Boolean]>(
        inspectRes,
      );
    }
    export async function isValidChar(
      client: SuiClient,
      args: [number | TransactionArgument],
    ): Promise<TypedDevInspectResults<[Boolean]>> {
      const tx = new TransactionBlock();
      builder.isValidChar(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[Boolean]>(
        inspectRes,
      );
    }
    export async function length(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new TransactionBlock();
      builder.length(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function popChar(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): Promise<TypedDevInspectResults<[ascii.Char]>> {
      const tx = new TransactionBlock();
      builder.popChar(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[ascii.Char]>(
        inspectRes,
      );
    }
    export async function pushChar(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        ascii.Char | TransactionArgument,
      ],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.pushChar(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function string_(
      client: SuiClient,
      args: [(string | TransactionObjectArgument)[] | TransactionArgument],
    ): Promise<TypedDevInspectResults<[ascii.String]>> {
      const tx = new TransactionBlock();
      builder.string_(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [ascii.String]
      >(inspectRes);
    }
    export async function tryString(
      client: SuiClient,
      args: [(string | TransactionObjectArgument)[] | TransactionArgument],
    ): Promise<TypedDevInspectResults<[option.Option<ascii.String>]>> {
      const tx = new TransactionBlock();
      builder.tryString(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [option.Option<ascii.String>]
      >(inspectRes);
    }
  }
}

export namespace bcs {
  export namespace builder {
    export function toBytes<T0 = any>(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::bcs::to_bytes",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
  }
  export namespace view {
    export async function toBytes<T0 = any>(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[number[]]>> {
      const tx = new TransactionBlock();
      builder.toBytes(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[number[]]>(
        inspectRes,
      );
    }
  }
}

export namespace bit_vector {
  export interface BitVector {
    length: bigint;
    bit_field: Boolean[];
  }

  export namespace BitVector {
    export const TYPE_QNAME = "0x1::bit_vector::BitVector";

    const TYPE = new TypeDescriptor<BitVector>(BitVector.TYPE_QNAME);

    export function type(): TypeDescriptor<BitVector> {
      return TYPE.apply();
    }
  }

  export interface BitVectorInstance extends TypedEventInstance<BitVector> {
    data_decoded: BitVector;
    type_arguments: [];
  }

  export namespace builder {
    export function isIndexSet(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::bit_vector::is_index_set",
        arguments: _args,
      });
    }
    export function length(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::bit_vector::length",
        arguments: _args,
      });
    }
    export function longestSetSequenceStartingAt(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::bit_vector::longest_set_sequence_starting_at",
        arguments: _args,
      });
    }
    export function new_(
      tx: TransactionBlock,
      args: [bigint | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::bit_vector::new",
        arguments: _args,
      });
    }
    export function set(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::bit_vector::set",
        arguments: _args,
      });
    }
    export function shiftLeft(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::bit_vector::shift_left",
        arguments: _args,
      });
    }
    export function unset(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::bit_vector::unset",
        arguments: _args,
      });
    }
  }
  export namespace view {
    export async function isIndexSet(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
      ],
    ): Promise<TypedDevInspectResults<[Boolean]>> {
      const tx = new TransactionBlock();
      builder.isIndexSet(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[Boolean]>(
        inspectRes,
      );
    }
    export async function length(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new TransactionBlock();
      builder.length(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function longestSetSequenceStartingAt(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
      ],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new TransactionBlock();
      builder.longestSetSequenceStartingAt(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function new_(
      client: SuiClient,
      args: [bigint | TransactionArgument],
    ): Promise<TypedDevInspectResults<[bit_vector.BitVector]>> {
      const tx = new TransactionBlock();
      builder.new_(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [bit_vector.BitVector]
      >(inspectRes);
    }
    export async function set(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
      ],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.set(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function shiftLeft(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
      ],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.shiftLeft(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function unset(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
      ],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.unset(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
  }
}

export namespace debug {
  export namespace builder {
    export function print<T0 = any>(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::debug::print",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function printStackTrace(
      tx: TransactionBlock,
      args: [],
    ): TransactionArgument & [] {
      const _args: any[] = [];

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::debug::print_stack_trace",
        arguments: _args,
      });
    }
  }
  export namespace view {
    export async function print<T0 = any>(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.print(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function printStackTrace(
      client: SuiClient,
      args: [],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.printStackTrace(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
  }
}

export namespace fixed_point32 {
  export interface FixedPoint32 {
    value: bigint;
  }

  export namespace FixedPoint32 {
    export const TYPE_QNAME = "0x1::fixed_point32::FixedPoint32";

    const TYPE = new TypeDescriptor<FixedPoint32>(FixedPoint32.TYPE_QNAME);

    export function type(): TypeDescriptor<FixedPoint32> {
      return TYPE.apply();
    }
  }

  export interface FixedPoint32Instance
    extends TypedEventInstance<FixedPoint32> {
    data_decoded: FixedPoint32;
    type_arguments: [];
  }

  export namespace builder {
    export function createFromRational(
      tx: TransactionBlock,
      args: [bigint | TransactionArgument, bigint | TransactionArgument],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::fixed_point32::create_from_rational",
        arguments: _args,
      });
    }
    export function createFromRawValue(
      tx: TransactionBlock,
      args: [bigint | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::fixed_point32::create_from_raw_value",
        arguments: _args,
      });
    }
    export function divideU64(
      tx: TransactionBlock,
      args: [
        bigint | TransactionArgument,
        fixed_point32.FixedPoint32 | TransactionArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::fixed_point32::divide_u64",
        arguments: _args,
      });
    }
    export function getRawValue(
      tx: TransactionBlock,
      args: [fixed_point32.FixedPoint32 | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::fixed_point32::get_raw_value",
        arguments: _args,
      });
    }
    export function isZero(
      tx: TransactionBlock,
      args: [fixed_point32.FixedPoint32 | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::fixed_point32::is_zero",
        arguments: _args,
      });
    }
    export function multiplyU64(
      tx: TransactionBlock,
      args: [
        bigint | TransactionArgument,
        fixed_point32.FixedPoint32 | TransactionArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::fixed_point32::multiply_u64",
        arguments: _args,
      });
    }
  }
  export namespace view {
    export async function createFromRational(
      client: SuiClient,
      args: [bigint | TransactionArgument, bigint | TransactionArgument],
    ): Promise<TypedDevInspectResults<[fixed_point32.FixedPoint32]>> {
      const tx = new TransactionBlock();
      builder.createFromRational(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [fixed_point32.FixedPoint32]
      >(inspectRes);
    }
    export async function createFromRawValue(
      client: SuiClient,
      args: [bigint | TransactionArgument],
    ): Promise<TypedDevInspectResults<[fixed_point32.FixedPoint32]>> {
      const tx = new TransactionBlock();
      builder.createFromRawValue(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [fixed_point32.FixedPoint32]
      >(inspectRes);
    }
    export async function divideU64(
      client: SuiClient,
      args: [
        bigint | TransactionArgument,
        fixed_point32.FixedPoint32 | TransactionArgument,
      ],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new TransactionBlock();
      builder.divideU64(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function getRawValue(
      client: SuiClient,
      args: [fixed_point32.FixedPoint32 | TransactionArgument],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new TransactionBlock();
      builder.getRawValue(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function isZero(
      client: SuiClient,
      args: [fixed_point32.FixedPoint32 | TransactionArgument],
    ): Promise<TypedDevInspectResults<[Boolean]>> {
      const tx = new TransactionBlock();
      builder.isZero(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[Boolean]>(
        inspectRes,
      );
    }
    export async function multiplyU64(
      client: SuiClient,
      args: [
        bigint | TransactionArgument,
        fixed_point32.FixedPoint32 | TransactionArgument,
      ],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new TransactionBlock();
      builder.multiplyU64(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
  }
}

export namespace hash {
  export namespace builder {
    export function sha2256(
      tx: TransactionBlock,
      args: [(string | TransactionObjectArgument)[] | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrVec(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::hash::sha2_256",
        arguments: _args,
      });
    }
    export function sha3256(
      tx: TransactionBlock,
      args: [(string | TransactionObjectArgument)[] | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrVec(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::hash::sha3_256",
        arguments: _args,
      });
    }
  }
  export namespace view {
    export async function sha2256(
      client: SuiClient,
      args: [(string | TransactionObjectArgument)[] | TransactionArgument],
    ): Promise<TypedDevInspectResults<[number[]]>> {
      const tx = new TransactionBlock();
      builder.sha2256(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[number[]]>(
        inspectRes,
      );
    }
    export async function sha3256(
      client: SuiClient,
      args: [(string | TransactionObjectArgument)[] | TransactionArgument],
    ): Promise<TypedDevInspectResults<[number[]]>> {
      const tx = new TransactionBlock();
      builder.sha3256(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[number[]]>(
        inspectRes,
      );
    }
  }
}

export namespace option {
  export type Option<T> = T | undefined;
  export namespace Option {
    export const TYPE_QNAME = "0x1::option::Option";

    const TYPE = new TypeDescriptor<Option<any>>(Option.TYPE_QNAME);

    export function type<T0>(
      arg0: TypeDescriptor<T0> = ANY_TYPE,
    ): TypeDescriptor<Option<T0>> {
      return TYPE.apply(arg0);
    }
  }

  export namespace builder {
    export function borrow<T0 = any>(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::option::borrow",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function borrowMut<T0 = any>(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::option::borrow_mut",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function borrowWithDefault<T0 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::option::borrow_with_default",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function contains<T0 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::option::contains",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function destroyNone<T0 = any>(
      tx: TransactionBlock,
      args: [option.Option<T0> | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::option::destroy_none",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function destroySome<T0 = any>(
      tx: TransactionBlock,
      args: [option.Option<T0> | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::option::destroy_some",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function destroyWithDefault<T0 = any>(
      tx: TransactionBlock,
      args: [option.Option<T0> | TransactionArgument, T0 | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::option::destroy_with_default",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function extract<T0 = any>(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::option::extract",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function fill<T0 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        T0 | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::option::fill",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function getWithDefault<T0 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        T0 | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::option::get_with_default",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function isNone<T0 = any>(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::option::is_none",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function isSome<T0 = any>(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::option::is_some",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function none<T0 = any>(
      tx: TransactionBlock,
      args: [],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [] {
      const _args: any[] = [];

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::option::none",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function some<T0 = any>(
      tx: TransactionBlock,
      args: [T0 | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::option::some",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function swap<T0 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        T0 | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::option::swap",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function swapOrFill<T0 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        T0 | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::option::swap_or_fill",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function toVec<T0 = any>(
      tx: TransactionBlock,
      args: [option.Option<T0> | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::option::to_vec",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
  }
  export namespace view {
    export async function borrow<T0 = any>(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new TransactionBlock();
      builder.borrow(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function borrowMut<T0 = any>(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new TransactionBlock();
      builder.borrowMut(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function borrowWithDefault<T0 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new TransactionBlock();
      builder.borrowWithDefault(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function contains<T0 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[Boolean]>> {
      const tx = new TransactionBlock();
      builder.contains(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[Boolean]>(
        inspectRes,
      );
    }
    export async function destroyNone<T0 = any>(
      client: SuiClient,
      args: [option.Option<T0> | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.destroyNone(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function destroySome<T0 = any>(
      client: SuiClient,
      args: [option.Option<T0> | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[T0]>> {
      const tx = new TransactionBlock();
      builder.destroySome(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[T0]>(
        inspectRes,
      );
    }
    export async function destroyWithDefault<T0 = any>(
      client: SuiClient,
      args: [option.Option<T0> | TransactionArgument, T0 | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[T0]>> {
      const tx = new TransactionBlock();
      builder.destroyWithDefault(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[T0]>(
        inspectRes,
      );
    }
    export async function extract<T0 = any>(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[T0]>> {
      const tx = new TransactionBlock();
      builder.extract(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[T0]>(
        inspectRes,
      );
    }
    export async function fill<T0 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        T0 | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.fill(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function getWithDefault<T0 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        T0 | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[T0]>> {
      const tx = new TransactionBlock();
      builder.getWithDefault(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[T0]>(
        inspectRes,
      );
    }
    export async function isNone<T0 = any>(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[Boolean]>> {
      const tx = new TransactionBlock();
      builder.isNone(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[Boolean]>(
        inspectRes,
      );
    }
    export async function isSome<T0 = any>(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[Boolean]>> {
      const tx = new TransactionBlock();
      builder.isSome(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[Boolean]>(
        inspectRes,
      );
    }
    export async function none<T0 = any>(
      client: SuiClient,
      args: [],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[option.Option<T0>]>> {
      const tx = new TransactionBlock();
      builder.none(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [option.Option<T0>]
      >(inspectRes);
    }
    export async function some<T0 = any>(
      client: SuiClient,
      args: [T0 | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[option.Option<T0>]>> {
      const tx = new TransactionBlock();
      builder.some(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [option.Option<T0>]
      >(inspectRes);
    }
    export async function swap<T0 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        T0 | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[T0]>> {
      const tx = new TransactionBlock();
      builder.swap(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[T0]>(
        inspectRes,
      );
    }
    export async function swapOrFill<T0 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        T0 | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[option.Option<T0>]>> {
      const tx = new TransactionBlock();
      builder.swapOrFill(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [option.Option<T0>]
      >(inspectRes);
    }
    export async function toVec<T0 = any>(
      client: SuiClient,
      args: [option.Option<T0> | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[T0[] | string]>> {
      const tx = new TransactionBlock();
      builder.toVec(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [T0[] | string]
      >(inspectRes);
    }
  }
}

export namespace string_ {
  export interface String {
    bytes: number[];
  }

  export namespace String {
    export const TYPE_QNAME = "0x1::string::String";

    const TYPE = new TypeDescriptor<String>(String.TYPE_QNAME);

    export function type(): TypeDescriptor<String> {
      return TYPE.apply();
    }
  }

  export interface StringInstance extends TypedEventInstance<String> {
    data_decoded: String;
    type_arguments: [];
  }

  export namespace builder {
    export function append(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::string::append",
        arguments: _args,
      });
    }
    export function appendUtf8(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrVec(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::string::append_utf8",
        arguments: _args,
      });
    }
    export function bytes(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::string::bytes",
        arguments: _args,
      });
    }
    export function fromAscii(
      tx: TransactionBlock,
      args: [ascii.String | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::string::from_ascii",
        arguments: _args,
      });
    }
    export function indexOf(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::string::index_of",
        arguments: _args,
      });
    }
    export function insert(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
        string | TransactionArgument,
      ],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));
      _args.push(transactionArgumentOrPure(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::string::insert",
        arguments: _args,
      });
    }
    export function isEmpty(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::string::is_empty",
        arguments: _args,
      });
    }
    export function length(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::string::length",
        arguments: _args,
      });
    }
    export function subString(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
        bigint | TransactionArgument,
      ],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));
      _args.push(transactionArgumentOrPure(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::string::sub_string",
        arguments: _args,
      });
    }
    export function toAscii(
      tx: TransactionBlock,
      args: [string | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::string::to_ascii",
        arguments: _args,
      });
    }
    export function tryUtf8(
      tx: TransactionBlock,
      args: [(string | TransactionObjectArgument)[] | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrVec(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::string::try_utf8",
        arguments: _args,
      });
    }
    export function utf8(
      tx: TransactionBlock,
      args: [(string | TransactionObjectArgument)[] | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrVec(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::string::utf8",
        arguments: _args,
      });
    }
  }
  export namespace view {
    export async function append(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionArgument,
      ],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.append(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function appendUtf8(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
      ],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.appendUtf8(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function bytes(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new TransactionBlock();
      builder.bytes(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function fromAscii(
      client: SuiClient,
      args: [ascii.String | TransactionArgument],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new TransactionBlock();
      builder.fromAscii(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function indexOf(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new TransactionBlock();
      builder.indexOf(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function insert(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
        string | TransactionArgument,
      ],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.insert(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function isEmpty(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): Promise<TypedDevInspectResults<[Boolean]>> {
      const tx = new TransactionBlock();
      builder.isEmpty(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[Boolean]>(
        inspectRes,
      );
    }
    export async function length(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new TransactionBlock();
      builder.length(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function subString(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
        bigint | TransactionArgument,
      ],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new TransactionBlock();
      builder.subString(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function toAscii(
      client: SuiClient,
      args: [string | TransactionArgument],
    ): Promise<TypedDevInspectResults<[ascii.String]>> {
      const tx = new TransactionBlock();
      builder.toAscii(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [ascii.String]
      >(inspectRes);
    }
    export async function tryUtf8(
      client: SuiClient,
      args: [(string | TransactionObjectArgument)[] | TransactionArgument],
    ): Promise<TypedDevInspectResults<[option.Option<string>]>> {
      const tx = new TransactionBlock();
      builder.tryUtf8(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [option.Option<string>]
      >(inspectRes);
    }
    export async function utf8(
      client: SuiClient,
      args: [(string | TransactionObjectArgument)[] | TransactionArgument],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new TransactionBlock();
      builder.utf8(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
  }
}

export namespace type_name {
  export interface TypeName {
    name: ascii.String;
  }

  export namespace TypeName {
    export const TYPE_QNAME = "0x1::type_name::TypeName";

    const TYPE = new TypeDescriptor<TypeName>(TypeName.TYPE_QNAME);

    export function type(): TypeDescriptor<TypeName> {
      return TYPE.apply();
    }
  }

  export interface TypeNameInstance extends TypedEventInstance<TypeName> {
    data_decoded: TypeName;
    type_arguments: [];
  }

  export namespace builder {
    export function borrowString(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::type_name::borrow_string",
        arguments: _args,
      });
    }
    export function get<T0 = any>(
      tx: TransactionBlock,
      args: [],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [] {
      const _args: any[] = [];

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::type_name::get",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function getAddress(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::type_name::get_address",
        arguments: _args,
      });
    }
    export function getModule(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::type_name::get_module",
        arguments: _args,
      });
    }
    export function getWithOriginalIds<T0 = any>(
      tx: TransactionBlock,
      args: [],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [] {
      const _args: any[] = [];

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::type_name::get_with_original_ids",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function intoString(
      tx: TransactionBlock,
      args: [type_name.TypeName | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::type_name::into_string",
        arguments: _args,
      });
    }
    export function isPrimitive(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::type_name::is_primitive",
        arguments: _args,
      });
    }
  }
  export namespace view {
    export async function borrowString(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new TransactionBlock();
      builder.borrowString(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function get<T0 = any>(
      client: SuiClient,
      args: [],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[type_name.TypeName]>> {
      const tx = new TransactionBlock();
      builder.get(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [type_name.TypeName]
      >(inspectRes);
    }
    export async function getAddress(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): Promise<TypedDevInspectResults<[ascii.String]>> {
      const tx = new TransactionBlock();
      builder.getAddress(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [ascii.String]
      >(inspectRes);
    }
    export async function getModule(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): Promise<TypedDevInspectResults<[ascii.String]>> {
      const tx = new TransactionBlock();
      builder.getModule(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [ascii.String]
      >(inspectRes);
    }
    export async function getWithOriginalIds<T0 = any>(
      client: SuiClient,
      args: [],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[type_name.TypeName]>> {
      const tx = new TransactionBlock();
      builder.getWithOriginalIds(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [type_name.TypeName]
      >(inspectRes);
    }
    export async function intoString(
      client: SuiClient,
      args: [type_name.TypeName | TransactionArgument],
    ): Promise<TypedDevInspectResults<[ascii.String]>> {
      const tx = new TransactionBlock();
      builder.intoString(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [ascii.String]
      >(inspectRes);
    }
    export async function isPrimitive(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): Promise<TypedDevInspectResults<[Boolean]>> {
      const tx = new TransactionBlock();
      builder.isPrimitive(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[Boolean]>(
        inspectRes,
      );
    }
  }
}

export namespace vector {
  export namespace builder {
    export function append<T0 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrVec(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::vector::append",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function borrow<T0 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::vector::borrow",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function borrowMut<T0 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::vector::borrow_mut",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function contains<T0 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::vector::contains",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function destroyEmpty<T0 = any>(
      tx: TransactionBlock,
      args: [(string | TransactionObjectArgument)[] | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrVec(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::vector::destroy_empty",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function empty<T0 = any>(
      tx: TransactionBlock,
      args: [],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [] {
      const _args: any[] = [];

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::vector::empty",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function indexOf<T0 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::vector::index_of",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function insert<T0 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        T0 | TransactionArgument,
        bigint | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));
      _args.push(transactionArgumentOrPure(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::vector::insert",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function isEmpty<T0 = any>(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::vector::is_empty",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function length<T0 = any>(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::vector::length",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function popBack<T0 = any>(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::vector::pop_back",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function pushBack<T0 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        T0 | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::vector::push_back",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function remove<T0 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::vector::remove",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function reverse<T0 = any>(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::vector::reverse",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function singleton<T0 = any>(
      tx: TransactionBlock,
      args: [T0 | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::vector::singleton",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function swap<T0 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
        bigint | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));
      _args.push(transactionArgumentOrPure(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::vector::swap",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function swapRemove<T0 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x1::vector::swap_remove",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
  }
  export namespace view {
    export async function append<T0 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.append(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function borrow<T0 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new TransactionBlock();
      builder.borrow(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function borrowMut<T0 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new TransactionBlock();
      builder.borrowMut(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function contains<T0 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[Boolean]>> {
      const tx = new TransactionBlock();
      builder.contains(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[Boolean]>(
        inspectRes,
      );
    }
    export async function destroyEmpty<T0 = any>(
      client: SuiClient,
      args: [(string | TransactionObjectArgument)[] | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.destroyEmpty(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function empty<T0 = any>(
      client: SuiClient,
      args: [],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[T0[] | string]>> {
      const tx = new TransactionBlock();
      builder.empty(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [T0[] | string]
      >(inspectRes);
    }
    export async function indexOf<T0 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[Boolean, bigint]>> {
      const tx = new TransactionBlock();
      builder.indexOf(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [Boolean, bigint]
      >(inspectRes);
    }
    export async function insert<T0 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        T0 | TransactionArgument,
        bigint | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.insert(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function isEmpty<T0 = any>(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[Boolean]>> {
      const tx = new TransactionBlock();
      builder.isEmpty(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[Boolean]>(
        inspectRes,
      );
    }
    export async function length<T0 = any>(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new TransactionBlock();
      builder.length(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function popBack<T0 = any>(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[T0]>> {
      const tx = new TransactionBlock();
      builder.popBack(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[T0]>(
        inspectRes,
      );
    }
    export async function pushBack<T0 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        T0 | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.pushBack(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function remove<T0 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[T0]>> {
      const tx = new TransactionBlock();
      builder.remove(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[T0]>(
        inspectRes,
      );
    }
    export async function reverse<T0 = any>(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.reverse(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function singleton<T0 = any>(
      client: SuiClient,
      args: [T0 | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[T0[] | string]>> {
      const tx = new TransactionBlock();
      builder.singleton(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [T0[] | string]
      >(inspectRes);
    }
    export async function swap<T0 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
        bigint | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.swap(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function swapRemove<T0 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[T0]>> {
      const tx = new TransactionBlock();
      builder.swapRemove(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[T0]>(
        inspectRes,
      );
    }
  }
}

const MODULES = JSON.parse(
  '{"address":{"fileFormatVersion":6,"address":"0x1","name":"address","friends":[],"structs":{},"exposedFunctions":{"length":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[],"return":["U64"]}}},"ascii":{"fileFormatVersion":6,"address":"0x1","name":"ascii","friends":[],"structs":{"Char":{"abilities":{"abilities":["Copy","Drop","Store"]},"typeParameters":[],"fields":[{"name":"byte","type":"U8"}]},"String":{"abilities":{"abilities":["Copy","Drop","Store"]},"typeParameters":[],"fields":[{"name":"bytes","type":{"Vector":"U8"}}]}},"exposedFunctions":{"all_characters_printable":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x1","module":"ascii","name":"String","typeArguments":[]}}}],"return":["Bool"]},"as_bytes":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x1","module":"ascii","name":"String","typeArguments":[]}}}],"return":[{"Reference":{"Vector":"U8"}}]},"byte":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Struct":{"address":"0x1","module":"ascii","name":"Char","typeArguments":[]}}],"return":["U8"]},"char":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U8"],"return":[{"Struct":{"address":"0x1","module":"ascii","name":"Char","typeArguments":[]}}]},"into_bytes":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Struct":{"address":"0x1","module":"ascii","name":"String","typeArguments":[]}}],"return":[{"Vector":"U8"}]},"is_printable_char":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U8"],"return":["Bool"]},"is_valid_char":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U8"],"return":["Bool"]},"length":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x1","module":"ascii","name":"String","typeArguments":[]}}}],"return":["U64"]},"pop_char":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x1","module":"ascii","name":"String","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x1","module":"ascii","name":"Char","typeArguments":[]}}]},"push_char":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x1","module":"ascii","name":"String","typeArguments":[]}}},{"Struct":{"address":"0x1","module":"ascii","name":"Char","typeArguments":[]}}],"return":[]},"string":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Vector":"U8"}],"return":[{"Struct":{"address":"0x1","module":"ascii","name":"String","typeArguments":[]}}]},"try_string":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Vector":"U8"}],"return":[{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":[{"Struct":{"address":"0x1","module":"ascii","name":"String","typeArguments":[]}}]}}]}}},"bcs":{"fileFormatVersion":6,"address":"0x1","name":"bcs","friends":[],"structs":{},"exposedFunctions":{"to_bytes":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"TypeParameter":0}}],"return":[{"Vector":"U8"}]}}},"bit_vector":{"fileFormatVersion":6,"address":"0x1","name":"bit_vector","friends":[],"structs":{"BitVector":{"abilities":{"abilities":["Copy","Drop","Store"]},"typeParameters":[],"fields":[{"name":"length","type":"U64"},{"name":"bit_field","type":{"Vector":"Bool"}}]}},"exposedFunctions":{"is_index_set":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x1","module":"bit_vector","name":"BitVector","typeArguments":[]}}},"U64"],"return":["Bool"]},"length":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x1","module":"bit_vector","name":"BitVector","typeArguments":[]}}}],"return":["U64"]},"longest_set_sequence_starting_at":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x1","module":"bit_vector","name":"BitVector","typeArguments":[]}}},"U64"],"return":["U64"]},"new":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U64"],"return":[{"Struct":{"address":"0x1","module":"bit_vector","name":"BitVector","typeArguments":[]}}]},"set":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x1","module":"bit_vector","name":"BitVector","typeArguments":[]}}},"U64"],"return":[]},"shift_left":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x1","module":"bit_vector","name":"BitVector","typeArguments":[]}}},"U64"],"return":[]},"unset":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x1","module":"bit_vector","name":"BitVector","typeArguments":[]}}},"U64"],"return":[]}}},"debug":{"fileFormatVersion":6,"address":"0x1","name":"debug","friends":[],"structs":{},"exposedFunctions":{"print":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"TypeParameter":0}}],"return":[]},"print_stack_trace":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[],"return":[]}}},"fixed_point32":{"fileFormatVersion":6,"address":"0x1","name":"fixed_point32","friends":[],"structs":{"FixedPoint32":{"abilities":{"abilities":["Copy","Drop","Store"]},"typeParameters":[],"fields":[{"name":"value","type":"U64"}]}},"exposedFunctions":{"create_from_rational":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U64","U64"],"return":[{"Struct":{"address":"0x1","module":"fixed_point32","name":"FixedPoint32","typeArguments":[]}}]},"create_from_raw_value":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U64"],"return":[{"Struct":{"address":"0x1","module":"fixed_point32","name":"FixedPoint32","typeArguments":[]}}]},"divide_u64":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U64",{"Struct":{"address":"0x1","module":"fixed_point32","name":"FixedPoint32","typeArguments":[]}}],"return":["U64"]},"get_raw_value":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Struct":{"address":"0x1","module":"fixed_point32","name":"FixedPoint32","typeArguments":[]}}],"return":["U64"]},"is_zero":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Struct":{"address":"0x1","module":"fixed_point32","name":"FixedPoint32","typeArguments":[]}}],"return":["Bool"]},"multiply_u64":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U64",{"Struct":{"address":"0x1","module":"fixed_point32","name":"FixedPoint32","typeArguments":[]}}],"return":["U64"]}}},"hash":{"fileFormatVersion":6,"address":"0x1","name":"hash","friends":[],"structs":{},"exposedFunctions":{"sha2_256":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Vector":"U8"}],"return":[{"Vector":"U8"}]},"sha3_256":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Vector":"U8"}],"return":[{"Vector":"U8"}]}}},"option":{"fileFormatVersion":6,"address":"0x1","name":"option","friends":[],"structs":{"Option":{"abilities":{"abilities":["Copy","Drop","Store"]},"typeParameters":[{"constraints":{"abilities":[]},"isPhantom":false}],"fields":[{"name":"vec","type":{"Vector":{"TypeParameter":0}}}]}},"exposedFunctions":{"borrow":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":[{"TypeParameter":0}]}}}],"return":[{"Reference":{"TypeParameter":0}}]},"borrow_mut":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":[{"TypeParameter":0}]}}}],"return":[{"MutableReference":{"TypeParameter":0}}]},"borrow_with_default":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":[{"TypeParameter":0}]}}},{"Reference":{"TypeParameter":0}}],"return":[{"Reference":{"TypeParameter":0}}]},"contains":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":[{"TypeParameter":0}]}}},{"Reference":{"TypeParameter":0}}],"return":["Bool"]},"destroy_none":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":[{"TypeParameter":0}]}}],"return":[]},"destroy_some":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":[{"TypeParameter":0}]}}],"return":[{"TypeParameter":0}]},"destroy_with_default":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Drop"]}],"parameters":[{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":[{"TypeParameter":0}]}},{"TypeParameter":0}],"return":[{"TypeParameter":0}]},"extract":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":[{"TypeParameter":0}]}}}],"return":[{"TypeParameter":0}]},"fill":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":[{"TypeParameter":0}]}}},{"TypeParameter":0}],"return":[]},"get_with_default":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop"]}],"parameters":[{"Reference":{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":[{"TypeParameter":0}]}}},{"TypeParameter":0}],"return":[{"TypeParameter":0}]},"is_none":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":[{"TypeParameter":0}]}}}],"return":["Bool"]},"is_some":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":[{"TypeParameter":0}]}}}],"return":["Bool"]},"none":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[],"return":[{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":[{"TypeParameter":0}]}}]},"some":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"TypeParameter":0}],"return":[{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":[{"TypeParameter":0}]}}]},"swap":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":[{"TypeParameter":0}]}}},{"TypeParameter":0}],"return":[{"TypeParameter":0}]},"swap_or_fill":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":[{"TypeParameter":0}]}}},{"TypeParameter":0}],"return":[{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":[{"TypeParameter":0}]}}]},"to_vec":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":[{"TypeParameter":0}]}}],"return":[{"Vector":{"TypeParameter":0}}]}}},"string":{"fileFormatVersion":6,"address":"0x1","name":"string","friends":[],"structs":{"String":{"abilities":{"abilities":["Copy","Drop","Store"]},"typeParameters":[],"fields":[{"name":"bytes","type":{"Vector":"U8"}}]}},"exposedFunctions":{"append":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}},{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}],"return":[]},"append_utf8":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}},{"Vector":"U8"}],"return":[]},"bytes":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}}],"return":[{"Reference":{"Vector":"U8"}}]},"from_ascii":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Struct":{"address":"0x1","module":"ascii","name":"String","typeArguments":[]}}],"return":[{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}]},"index_of":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}},{"Reference":{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}}],"return":["U64"]},"insert":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}},"U64",{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}],"return":[]},"is_empty":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}}],"return":["Bool"]},"length":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}}],"return":["U64"]},"sub_string":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}},"U64","U64"],"return":[{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}]},"to_ascii":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}],"return":[{"Struct":{"address":"0x1","module":"ascii","name":"String","typeArguments":[]}}]},"try_utf8":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Vector":"U8"}],"return":[{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":[{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}]}}]},"utf8":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Vector":"U8"}],"return":[{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}]}}},"type_name":{"fileFormatVersion":6,"address":"0x1","name":"type_name","friends":[],"structs":{"TypeName":{"abilities":{"abilities":["Copy","Drop","Store"]},"typeParameters":[],"fields":[{"name":"name","type":{"Struct":{"address":"0x1","module":"ascii","name":"String","typeArguments":[]}}}]}},"exposedFunctions":{"borrow_string":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x1","module":"type_name","name":"TypeName","typeArguments":[]}}}],"return":[{"Reference":{"Struct":{"address":"0x1","module":"ascii","name":"String","typeArguments":[]}}}]},"get":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[],"return":[{"Struct":{"address":"0x1","module":"type_name","name":"TypeName","typeArguments":[]}}]},"get_address":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x1","module":"type_name","name":"TypeName","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x1","module":"ascii","name":"String","typeArguments":[]}}]},"get_module":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x1","module":"type_name","name":"TypeName","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x1","module":"ascii","name":"String","typeArguments":[]}}]},"get_with_original_ids":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[],"return":[{"Struct":{"address":"0x1","module":"type_name","name":"TypeName","typeArguments":[]}}]},"into_string":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Struct":{"address":"0x1","module":"type_name","name":"TypeName","typeArguments":[]}}],"return":[{"Struct":{"address":"0x1","module":"ascii","name":"String","typeArguments":[]}}]},"is_primitive":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x1","module":"type_name","name":"TypeName","typeArguments":[]}}}],"return":["Bool"]}}},"vector":{"fileFormatVersion":6,"address":"0x1","name":"vector","friends":[],"structs":{},"exposedFunctions":{"append":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"MutableReference":{"Vector":{"TypeParameter":0}}},{"Vector":{"TypeParameter":0}}],"return":[]},"borrow":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"Vector":{"TypeParameter":0}}},"U64"],"return":[{"Reference":{"TypeParameter":0}}]},"borrow_mut":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"MutableReference":{"Vector":{"TypeParameter":0}}},"U64"],"return":[{"MutableReference":{"TypeParameter":0}}]},"contains":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"Vector":{"TypeParameter":0}}},{"Reference":{"TypeParameter":0}}],"return":["Bool"]},"destroy_empty":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Vector":{"TypeParameter":0}}],"return":[]},"empty":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[],"return":[{"Vector":{"TypeParameter":0}}]},"index_of":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"Vector":{"TypeParameter":0}}},{"Reference":{"TypeParameter":0}}],"return":["Bool","U64"]},"insert":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"MutableReference":{"Vector":{"TypeParameter":0}}},{"TypeParameter":0},"U64"],"return":[]},"is_empty":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"Vector":{"TypeParameter":0}}}],"return":["Bool"]},"length":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"Vector":{"TypeParameter":0}}}],"return":["U64"]},"pop_back":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"MutableReference":{"Vector":{"TypeParameter":0}}}],"return":[{"TypeParameter":0}]},"push_back":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"MutableReference":{"Vector":{"TypeParameter":0}}},{"TypeParameter":0}],"return":[]},"remove":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"MutableReference":{"Vector":{"TypeParameter":0}}},"U64"],"return":[{"TypeParameter":0}]},"reverse":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"MutableReference":{"Vector":{"TypeParameter":0}}}],"return":[]},"singleton":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"TypeParameter":0}],"return":[{"Vector":{"TypeParameter":0}}]},"swap":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"MutableReference":{"Vector":{"TypeParameter":0}}},"U64","U64"],"return":[]},"swap_remove":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"MutableReference":{"Vector":{"TypeParameter":0}}},"U64"],"return":[{"TypeParameter":0}]}}}}',
);

export function loadAllTypes(coder: MoveCoder) {
  for (const m of Object.values(MODULES)) {
    coder.load(m as any, "0x1");
  }
}

loadAllTypes(defaultMoveCoder());
