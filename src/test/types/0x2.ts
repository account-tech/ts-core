/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */

/* Generated types for 0x2, original address 0x2 */

import { TypeDescriptor, ANY_TYPE } from "@typemove/move";
import { MoveCoder, TypedEventInstance } from "@typemove/sui";

import { defaultMoveCoder } from "@typemove/sui";

import {
  ZERO_ADDRESS,
  TypedDevInspectResults,
  getMoveCoder,
} from "@typemove/sui";
import {
  TransactionBlock,
  TransactionArgument,
  TransactionObjectArgument,
} from "@mysten/sui.js/transactions";
import { SuiClient } from "@mysten/sui.js/client";
import {
  transactionArgumentOrObject,
  transactionArgumentOrPure,
  transactionArgumentOrVec,
} from "@typemove/sui";

import * as _0x1 from "./0x1.js";

export namespace address {
  export namespace builder {
    export function fromAsciiBytes(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::address::from_ascii_bytes",
        arguments: _args,
      });
    }
    export function fromBytes(
      tx: TransactionBlock,
      args: [(string | TransactionObjectArgument)[] | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrVec(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::address::from_bytes",
        arguments: _args,
      });
    }
    export function fromU256(
      tx: TransactionBlock,
      args: [bigint | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::address::from_u256",
        arguments: _args,
      });
    }
    export function length(
      tx: TransactionBlock,
      args: [],
    ): TransactionArgument & [] {
      const _args: any[] = [];

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::address::length",
        arguments: _args,
      });
    }
    export function max(
      tx: TransactionBlock,
      args: [],
    ): TransactionArgument & [] {
      const _args: any[] = [];

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::address::max",
        arguments: _args,
      });
    }
    export function toAsciiString(
      tx: TransactionBlock,
      args: [string | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::address::to_ascii_string",
        arguments: _args,
      });
    }
    export function toBytes(
      tx: TransactionBlock,
      args: [string | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::address::to_bytes",
        arguments: _args,
      });
    }
    export function toString(
      tx: TransactionBlock,
      args: [string | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::address::to_string",
        arguments: _args,
      });
    }
    export function toU256(
      tx: TransactionBlock,
      args: [string | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::address::to_u256",
        arguments: _args,
      });
    }
  }
  export namespace view {
    export async function fromAsciiBytes(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new TransactionBlock();
      builder.fromAsciiBytes(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function fromBytes(
      client: SuiClient,
      args: [(string | TransactionObjectArgument)[] | TransactionArgument],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new TransactionBlock();
      builder.fromBytes(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function fromU256(
      client: SuiClient,
      args: [bigint | TransactionArgument],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new TransactionBlock();
      builder.fromU256(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function length(
      client: SuiClient,
      args: [],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new TransactionBlock();
      builder.length(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function max(
      client: SuiClient,
      args: [],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new TransactionBlock();
      builder.max(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function toAsciiString(
      client: SuiClient,
      args: [string | TransactionArgument],
    ): Promise<TypedDevInspectResults<[_0x1.ascii.String]>> {
      const tx = new TransactionBlock();
      builder.toAsciiString(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [_0x1.ascii.String]
      >(inspectRes);
    }
    export async function toBytes(
      client: SuiClient,
      args: [string | TransactionArgument],
    ): Promise<TypedDevInspectResults<[number[]]>> {
      const tx = new TransactionBlock();
      builder.toBytes(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[number[]]>(
        inspectRes,
      );
    }
    export async function toString(
      client: SuiClient,
      args: [string | TransactionArgument],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new TransactionBlock();
      builder.toString(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function toU256(
      client: SuiClient,
      args: [string | TransactionArgument],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new TransactionBlock();
      builder.toU256(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
  }
}

export namespace authenticator_state {
  export interface ActiveJwk {
    jwk_id: authenticator_state.JwkId;
    jwk: authenticator_state.JWK;
    epoch: bigint;
  }

  export namespace ActiveJwk {
    export const TYPE_QNAME = "0x2::authenticator_state::ActiveJwk";

    const TYPE = new TypeDescriptor<ActiveJwk>(ActiveJwk.TYPE_QNAME);

    export function type(): TypeDescriptor<ActiveJwk> {
      return TYPE.apply();
    }
  }

  export interface ActiveJwkInstance extends TypedEventInstance<ActiveJwk> {
    data_decoded: ActiveJwk;
    type_arguments: [];
  }

  export interface AuthenticatorState {
    id: object_.UID;
    version: bigint;
  }

  export namespace AuthenticatorState {
    export const TYPE_QNAME = "0x2::authenticator_state::AuthenticatorState";

    const TYPE = new TypeDescriptor<AuthenticatorState>(
      AuthenticatorState.TYPE_QNAME,
    );

    export function type(): TypeDescriptor<AuthenticatorState> {
      return TYPE.apply();
    }
  }

  export interface AuthenticatorStateInner {
    version: bigint;
    active_jwks: authenticator_state.ActiveJwk[];
  }

  export namespace AuthenticatorStateInner {
    export const TYPE_QNAME =
      "0x2::authenticator_state::AuthenticatorStateInner";

    const TYPE = new TypeDescriptor<AuthenticatorStateInner>(
      AuthenticatorStateInner.TYPE_QNAME,
    );

    export function type(): TypeDescriptor<AuthenticatorStateInner> {
      return TYPE.apply();
    }
  }

  export interface JWK {
    kty: string;
    e: string;
    n: string;
    alg: string;
  }

  export namespace JWK {
    export const TYPE_QNAME = "0x2::authenticator_state::JWK";

    const TYPE = new TypeDescriptor<JWK>(JWK.TYPE_QNAME);

    export function type(): TypeDescriptor<JWK> {
      return TYPE.apply();
    }
  }

  export interface JWKInstance extends TypedEventInstance<JWK> {
    data_decoded: JWK;
    type_arguments: [];
  }

  export interface JwkId {
    iss: string;
    kid: string;
  }

  export namespace JwkId {
    export const TYPE_QNAME = "0x2::authenticator_state::JwkId";

    const TYPE = new TypeDescriptor<JwkId>(JwkId.TYPE_QNAME);

    export function type(): TypeDescriptor<JwkId> {
      return TYPE.apply();
    }
  }

  export interface JwkIdInstance extends TypedEventInstance<JwkId> {
    data_decoded: JwkId;
    type_arguments: [];
  }

  export namespace builder {}
  export namespace view {}
}

export namespace bag {
  export interface Bag {
    id: object_.UID;
    size: bigint;
  }

  export namespace Bag {
    export const TYPE_QNAME = "0x2::bag::Bag";

    const TYPE = new TypeDescriptor<Bag>(Bag.TYPE_QNAME);

    export function type(): TypeDescriptor<Bag> {
      return TYPE.apply();
    }
  }

  export namespace builder {
    export function add<T0 = any, T1 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        T0 | TransactionArgument,
        T1 | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));
      _args.push(transactionArgumentOrPure(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bag::add",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function borrow<T0 = any, T1 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        T0 | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bag::borrow",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function borrowMut<T0 = any, T1 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        T0 | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bag::borrow_mut",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function contains<T0 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        T0 | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bag::contains",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function containsWithType<T0 = any, T1 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        T0 | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bag::contains_with_type",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function destroyEmpty(
      tx: TransactionBlock,
      args: [bag.Bag | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bag::destroy_empty",
        arguments: _args,
      });
    }
    export function isEmpty(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bag::is_empty",
        arguments: _args,
      });
    }
    export function length(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bag::length",
        arguments: _args,
      });
    }
    export function new_(
      tx: TransactionBlock,
      args: [],
    ): TransactionArgument & [] {
      const _args: any[] = [];

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bag::new",
        arguments: _args,
      });
    }
    export function remove<T0 = any, T1 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        T0 | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bag::remove",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
  }
  export namespace view {
    export async function add<T0 = any, T1 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        T0 | TransactionArgument,
        T1 | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.add(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function borrow<T0 = any, T1 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        T0 | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new TransactionBlock();
      builder.borrow(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function borrowMut<T0 = any, T1 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        T0 | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new TransactionBlock();
      builder.borrowMut(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function contains<T0 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        T0 | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[Boolean]>> {
      const tx = new TransactionBlock();
      builder.contains(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[Boolean]>(
        inspectRes,
      );
    }
    export async function containsWithType<T0 = any, T1 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        T0 | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[Boolean]>> {
      const tx = new TransactionBlock();
      builder.containsWithType(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[Boolean]>(
        inspectRes,
      );
    }
    export async function destroyEmpty(
      client: SuiClient,
      args: [bag.Bag | TransactionArgument],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.destroyEmpty(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function isEmpty(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): Promise<TypedDevInspectResults<[Boolean]>> {
      const tx = new TransactionBlock();
      builder.isEmpty(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[Boolean]>(
        inspectRes,
      );
    }
    export async function length(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new TransactionBlock();
      builder.length(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function new_(
      client: SuiClient,
      args: [],
    ): Promise<TypedDevInspectResults<[bag.Bag]>> {
      const tx = new TransactionBlock();
      builder.new_(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bag.Bag]>(
        inspectRes,
      );
    }
    export async function remove<T0 = any, T1 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        T0 | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[T1]>> {
      const tx = new TransactionBlock();
      builder.remove(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[T1]>(
        inspectRes,
      );
    }
  }
}

export namespace balance {
  export type Balance<T> = bigint;
  export namespace Balance {
    export const TYPE_QNAME = "0x2::balance::Balance";

    const TYPE = new TypeDescriptor<Balance<any>>(Balance.TYPE_QNAME);

    export function type<T0>(
      arg0: TypeDescriptor<T0> = ANY_TYPE,
    ): TypeDescriptor<Balance<T0>> {
      return TYPE.apply(arg0);
    }
  }

  export interface Supply<T0> {
    value: bigint;
  }

  export namespace Supply {
    export const TYPE_QNAME = "0x2::balance::Supply";

    const TYPE = new TypeDescriptor<Supply<any>>(Supply.TYPE_QNAME);

    export function type<T0>(
      arg0: TypeDescriptor<T0> = ANY_TYPE,
    ): TypeDescriptor<Supply<T0>> {
      return TYPE.apply(arg0);
    }
  }

  export namespace builder {
    export function createSupply<T0 = any>(
      tx: TransactionBlock,
      args: [T0 | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::balance::create_supply",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function decreaseSupply<T0 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        balance.Balance<T0> | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::balance::decrease_supply",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function destroySupply<T0 = any>(
      tx: TransactionBlock,
      args: [balance.Supply<T0> | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::balance::destroy_supply",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function destroyZero<T0 = any>(
      tx: TransactionBlock,
      args: [balance.Balance<T0> | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::balance::destroy_zero",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function increaseSupply<T0 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::balance::increase_supply",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function join<T0 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        balance.Balance<T0> | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::balance::join",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function split<T0 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::balance::split",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function supplyValue<T0 = any>(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::balance::supply_value",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function value<T0 = any>(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::balance::value",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function withdrawAll<T0 = any>(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::balance::withdraw_all",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function zero<T0 = any>(
      tx: TransactionBlock,
      args: [],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [] {
      const _args: any[] = [];

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::balance::zero",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
  }
  export namespace view {
    export async function createSupply<T0 = any>(
      client: SuiClient,
      args: [T0 | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[balance.Supply<T0>]>> {
      const tx = new TransactionBlock();
      builder.createSupply(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [balance.Supply<T0>]
      >(inspectRes);
    }
    export async function decreaseSupply<T0 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        balance.Balance<T0> | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new TransactionBlock();
      builder.decreaseSupply(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function destroySupply<T0 = any>(
      client: SuiClient,
      args: [balance.Supply<T0> | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new TransactionBlock();
      builder.destroySupply(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function destroyZero<T0 = any>(
      client: SuiClient,
      args: [balance.Balance<T0> | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.destroyZero(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function increaseSupply<T0 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[balance.Balance<T0>]>> {
      const tx = new TransactionBlock();
      builder.increaseSupply(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [balance.Balance<T0>]
      >(inspectRes);
    }
    export async function join<T0 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        balance.Balance<T0> | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new TransactionBlock();
      builder.join(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function split<T0 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[balance.Balance<T0>]>> {
      const tx = new TransactionBlock();
      builder.split(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [balance.Balance<T0>]
      >(inspectRes);
    }
    export async function supplyValue<T0 = any>(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new TransactionBlock();
      builder.supplyValue(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function value<T0 = any>(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new TransactionBlock();
      builder.value(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function withdrawAll<T0 = any>(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[balance.Balance<T0>]>> {
      const tx = new TransactionBlock();
      builder.withdrawAll(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [balance.Balance<T0>]
      >(inspectRes);
    }
    export async function zero<T0 = any>(
      client: SuiClient,
      args: [],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[balance.Balance<T0>]>> {
      const tx = new TransactionBlock();
      builder.zero(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [balance.Balance<T0>]
      >(inspectRes);
    }
  }
}

export namespace bcs {
  export interface BCS {
    bytes: number[];
  }

  export namespace BCS {
    export const TYPE_QNAME = "0x2::bcs::BCS";

    const TYPE = new TypeDescriptor<BCS>(BCS.TYPE_QNAME);

    export function type(): TypeDescriptor<BCS> {
      return TYPE.apply();
    }
  }

  export interface BCSInstance extends TypedEventInstance<BCS> {
    data_decoded: BCS;
    type_arguments: [];
  }

  export namespace builder {
    export function intoRemainderBytes(
      tx: TransactionBlock,
      args: [bcs.BCS | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bcs::into_remainder_bytes",
        arguments: _args,
      });
    }
    export function new_(
      tx: TransactionBlock,
      args: [(string | TransactionObjectArgument)[] | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrVec(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bcs::new",
        arguments: _args,
      });
    }
    export function peelAddress(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bcs::peel_address",
        arguments: _args,
      });
    }
    export function peelBool(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bcs::peel_bool",
        arguments: _args,
      });
    }
    export function peelOptionAddress(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bcs::peel_option_address",
        arguments: _args,
      });
    }
    export function peelOptionBool(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bcs::peel_option_bool",
        arguments: _args,
      });
    }
    export function peelOptionU128(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bcs::peel_option_u128",
        arguments: _args,
      });
    }
    export function peelOptionU64(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bcs::peel_option_u64",
        arguments: _args,
      });
    }
    export function peelOptionU8(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bcs::peel_option_u8",
        arguments: _args,
      });
    }
    export function peelU128(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bcs::peel_u128",
        arguments: _args,
      });
    }
    export function peelU256(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bcs::peel_u256",
        arguments: _args,
      });
    }
    export function peelU64(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bcs::peel_u64",
        arguments: _args,
      });
    }
    export function peelU8(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bcs::peel_u8",
        arguments: _args,
      });
    }
    export function peelVecAddress(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bcs::peel_vec_address",
        arguments: _args,
      });
    }
    export function peelVecBool(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bcs::peel_vec_bool",
        arguments: _args,
      });
    }
    export function peelVecLength(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bcs::peel_vec_length",
        arguments: _args,
      });
    }
    export function peelVecU128(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bcs::peel_vec_u128",
        arguments: _args,
      });
    }
    export function peelVecU64(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bcs::peel_vec_u64",
        arguments: _args,
      });
    }
    export function peelVecU8(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bcs::peel_vec_u8",
        arguments: _args,
      });
    }
    export function peelVecVecU8(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bcs::peel_vec_vec_u8",
        arguments: _args,
      });
    }
    export function toBytes<T0 = any>(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bcs::to_bytes",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
  }
  export namespace view {
    export async function intoRemainderBytes(
      client: SuiClient,
      args: [bcs.BCS | TransactionArgument],
    ): Promise<TypedDevInspectResults<[number[]]>> {
      const tx = new TransactionBlock();
      builder.intoRemainderBytes(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[number[]]>(
        inspectRes,
      );
    }
    export async function new_(
      client: SuiClient,
      args: [(string | TransactionObjectArgument)[] | TransactionArgument],
    ): Promise<TypedDevInspectResults<[bcs.BCS]>> {
      const tx = new TransactionBlock();
      builder.new_(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bcs.BCS]>(
        inspectRes,
      );
    }
    export async function peelAddress(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new TransactionBlock();
      builder.peelAddress(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function peelBool(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): Promise<TypedDevInspectResults<[Boolean]>> {
      const tx = new TransactionBlock();
      builder.peelBool(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[Boolean]>(
        inspectRes,
      );
    }
    export async function peelOptionAddress(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): Promise<TypedDevInspectResults<[_0x1.option.Option<string>]>> {
      const tx = new TransactionBlock();
      builder.peelOptionAddress(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [_0x1.option.Option<string>]
      >(inspectRes);
    }
    export async function peelOptionBool(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): Promise<TypedDevInspectResults<[_0x1.option.Option<Boolean>]>> {
      const tx = new TransactionBlock();
      builder.peelOptionBool(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [_0x1.option.Option<Boolean>]
      >(inspectRes);
    }
    export async function peelOptionU128(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): Promise<TypedDevInspectResults<[_0x1.option.Option<bigint>]>> {
      const tx = new TransactionBlock();
      builder.peelOptionU128(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [_0x1.option.Option<bigint>]
      >(inspectRes);
    }
    export async function peelOptionU64(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): Promise<TypedDevInspectResults<[_0x1.option.Option<bigint>]>> {
      const tx = new TransactionBlock();
      builder.peelOptionU64(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [_0x1.option.Option<bigint>]
      >(inspectRes);
    }
    export async function peelOptionU8(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): Promise<TypedDevInspectResults<[_0x1.option.Option<number>]>> {
      const tx = new TransactionBlock();
      builder.peelOptionU8(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [_0x1.option.Option<number>]
      >(inspectRes);
    }
    export async function peelU128(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new TransactionBlock();
      builder.peelU128(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function peelU256(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new TransactionBlock();
      builder.peelU256(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function peelU64(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new TransactionBlock();
      builder.peelU64(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function peelU8(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): Promise<TypedDevInspectResults<[number]>> {
      const tx = new TransactionBlock();
      builder.peelU8(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[number]>(
        inspectRes,
      );
    }
    export async function peelVecAddress(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): Promise<TypedDevInspectResults<[string[]]>> {
      const tx = new TransactionBlock();
      builder.peelVecAddress(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string[]]>(
        inspectRes,
      );
    }
    export async function peelVecBool(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): Promise<TypedDevInspectResults<[Boolean[]]>> {
      const tx = new TransactionBlock();
      builder.peelVecBool(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[Boolean[]]>(
        inspectRes,
      );
    }
    export async function peelVecLength(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new TransactionBlock();
      builder.peelVecLength(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function peelVecU128(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): Promise<TypedDevInspectResults<[bigint[]]>> {
      const tx = new TransactionBlock();
      builder.peelVecU128(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint[]]>(
        inspectRes,
      );
    }
    export async function peelVecU64(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): Promise<TypedDevInspectResults<[bigint[]]>> {
      const tx = new TransactionBlock();
      builder.peelVecU64(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint[]]>(
        inspectRes,
      );
    }
    export async function peelVecU8(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): Promise<TypedDevInspectResults<[number[]]>> {
      const tx = new TransactionBlock();
      builder.peelVecU8(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[number[]]>(
        inspectRes,
      );
    }
    export async function peelVecVecU8(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): Promise<TypedDevInspectResults<[number[][]]>> {
      const tx = new TransactionBlock();
      builder.peelVecVecU8(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[number[][]]>(
        inspectRes,
      );
    }
    export async function toBytes<T0 = any>(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[number[]]>> {
      const tx = new TransactionBlock();
      builder.toBytes(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[number[]]>(
        inspectRes,
      );
    }
  }
}

export namespace bls12381 {
  export interface G1 {
    dummy_field: Boolean;
  }

  export namespace G1 {
    export const TYPE_QNAME = "0x2::bls12381::G1";

    const TYPE = new TypeDescriptor<G1>(G1.TYPE_QNAME);

    export function type(): TypeDescriptor<G1> {
      return TYPE.apply();
    }
  }

  export interface G2 {
    dummy_field: Boolean;
  }

  export namespace G2 {
    export const TYPE_QNAME = "0x2::bls12381::G2";

    const TYPE = new TypeDescriptor<G2>(G2.TYPE_QNAME);

    export function type(): TypeDescriptor<G2> {
      return TYPE.apply();
    }
  }

  export interface GT {
    dummy_field: Boolean;
  }

  export namespace GT {
    export const TYPE_QNAME = "0x2::bls12381::GT";

    const TYPE = new TypeDescriptor<GT>(GT.TYPE_QNAME);

    export function type(): TypeDescriptor<GT> {
      return TYPE.apply();
    }
  }

  export interface Scalar {
    dummy_field: Boolean;
  }

  export namespace Scalar {
    export const TYPE_QNAME = "0x2::bls12381::Scalar";

    const TYPE = new TypeDescriptor<Scalar>(Scalar.TYPE_QNAME);

    export function type(): TypeDescriptor<Scalar> {
      return TYPE.apply();
    }
  }

  export namespace builder {
    export function bls12381MinPkVerify(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));
      _args.push(transactionArgumentOrObject(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bls12381::bls12381_min_pk_verify",
        arguments: _args,
      });
    }
    export function bls12381MinSigVerify(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));
      _args.push(transactionArgumentOrObject(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bls12381::bls12381_min_sig_verify",
        arguments: _args,
      });
    }
    export function g1Add(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bls12381::g1_add",
        arguments: _args,
      });
    }
    export function g1Div(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bls12381::g1_div",
        arguments: _args,
      });
    }
    export function g1FromBytes(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bls12381::g1_from_bytes",
        arguments: _args,
      });
    }
    export function g1Generator(
      tx: TransactionBlock,
      args: [],
    ): TransactionArgument & [] {
      const _args: any[] = [];

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bls12381::g1_generator",
        arguments: _args,
      });
    }
    export function g1Identity(
      tx: TransactionBlock,
      args: [],
    ): TransactionArgument & [] {
      const _args: any[] = [];

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bls12381::g1_identity",
        arguments: _args,
      });
    }
    export function g1Mul(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bls12381::g1_mul",
        arguments: _args,
      });
    }
    export function g1MultiScalarMultiplication(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bls12381::g1_multi_scalar_multiplication",
        arguments: _args,
      });
    }
    export function g1Neg(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bls12381::g1_neg",
        arguments: _args,
      });
    }
    export function g1Sub(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bls12381::g1_sub",
        arguments: _args,
      });
    }
    export function g2Add(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bls12381::g2_add",
        arguments: _args,
      });
    }
    export function g2Div(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bls12381::g2_div",
        arguments: _args,
      });
    }
    export function g2FromBytes(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bls12381::g2_from_bytes",
        arguments: _args,
      });
    }
    export function g2Generator(
      tx: TransactionBlock,
      args: [],
    ): TransactionArgument & [] {
      const _args: any[] = [];

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bls12381::g2_generator",
        arguments: _args,
      });
    }
    export function g2Identity(
      tx: TransactionBlock,
      args: [],
    ): TransactionArgument & [] {
      const _args: any[] = [];

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bls12381::g2_identity",
        arguments: _args,
      });
    }
    export function g2Mul(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bls12381::g2_mul",
        arguments: _args,
      });
    }
    export function g2MultiScalarMultiplication(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bls12381::g2_multi_scalar_multiplication",
        arguments: _args,
      });
    }
    export function g2Neg(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bls12381::g2_neg",
        arguments: _args,
      });
    }
    export function g2Sub(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bls12381::g2_sub",
        arguments: _args,
      });
    }
    export function gtAdd(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bls12381::gt_add",
        arguments: _args,
      });
    }
    export function gtDiv(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bls12381::gt_div",
        arguments: _args,
      });
    }
    export function gtGenerator(
      tx: TransactionBlock,
      args: [],
    ): TransactionArgument & [] {
      const _args: any[] = [];

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bls12381::gt_generator",
        arguments: _args,
      });
    }
    export function gtIdentity(
      tx: TransactionBlock,
      args: [],
    ): TransactionArgument & [] {
      const _args: any[] = [];

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bls12381::gt_identity",
        arguments: _args,
      });
    }
    export function gtMul(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bls12381::gt_mul",
        arguments: _args,
      });
    }
    export function gtNeg(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bls12381::gt_neg",
        arguments: _args,
      });
    }
    export function gtSub(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bls12381::gt_sub",
        arguments: _args,
      });
    }
    export function hashToG1(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bls12381::hash_to_g1",
        arguments: _args,
      });
    }
    export function hashToG2(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bls12381::hash_to_g2",
        arguments: _args,
      });
    }
    export function pairing(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bls12381::pairing",
        arguments: _args,
      });
    }
    export function scalarAdd(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bls12381::scalar_add",
        arguments: _args,
      });
    }
    export function scalarDiv(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bls12381::scalar_div",
        arguments: _args,
      });
    }
    export function scalarFromBytes(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bls12381::scalar_from_bytes",
        arguments: _args,
      });
    }
    export function scalarFromU64(
      tx: TransactionBlock,
      args: [bigint | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bls12381::scalar_from_u64",
        arguments: _args,
      });
    }
    export function scalarInv(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bls12381::scalar_inv",
        arguments: _args,
      });
    }
    export function scalarMul(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bls12381::scalar_mul",
        arguments: _args,
      });
    }
    export function scalarNeg(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bls12381::scalar_neg",
        arguments: _args,
      });
    }
    export function scalarOne(
      tx: TransactionBlock,
      args: [],
    ): TransactionArgument & [] {
      const _args: any[] = [];

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bls12381::scalar_one",
        arguments: _args,
      });
    }
    export function scalarSub(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bls12381::scalar_sub",
        arguments: _args,
      });
    }
    export function scalarZero(
      tx: TransactionBlock,
      args: [],
    ): TransactionArgument & [] {
      const _args: any[] = [];

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::bls12381::scalar_zero",
        arguments: _args,
      });
    }
  }
  export namespace view {
    export async function bls12381MinPkVerify(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
    ): Promise<TypedDevInspectResults<[Boolean]>> {
      const tx = new TransactionBlock();
      builder.bls12381MinPkVerify(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[Boolean]>(
        inspectRes,
      );
    }
    export async function bls12381MinSigVerify(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
    ): Promise<TypedDevInspectResults<[Boolean]>> {
      const tx = new TransactionBlock();
      builder.bls12381MinSigVerify(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[Boolean]>(
        inspectRes,
      );
    }
    export async function g1Add(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
    ): Promise<TypedDevInspectResults<[group_ops.Element<bls12381.G1>]>> {
      const tx = new TransactionBlock();
      builder.g1Add(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [group_ops.Element<bls12381.G1>]
      >(inspectRes);
    }
    export async function g1Div(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
    ): Promise<TypedDevInspectResults<[group_ops.Element<bls12381.G1>]>> {
      const tx = new TransactionBlock();
      builder.g1Div(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [group_ops.Element<bls12381.G1>]
      >(inspectRes);
    }
    export async function g1FromBytes(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): Promise<TypedDevInspectResults<[group_ops.Element<bls12381.G1>]>> {
      const tx = new TransactionBlock();
      builder.g1FromBytes(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [group_ops.Element<bls12381.G1>]
      >(inspectRes);
    }
    export async function g1Generator(
      client: SuiClient,
      args: [],
    ): Promise<TypedDevInspectResults<[group_ops.Element<bls12381.G1>]>> {
      const tx = new TransactionBlock();
      builder.g1Generator(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [group_ops.Element<bls12381.G1>]
      >(inspectRes);
    }
    export async function g1Identity(
      client: SuiClient,
      args: [],
    ): Promise<TypedDevInspectResults<[group_ops.Element<bls12381.G1>]>> {
      const tx = new TransactionBlock();
      builder.g1Identity(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [group_ops.Element<bls12381.G1>]
      >(inspectRes);
    }
    export async function g1Mul(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
    ): Promise<TypedDevInspectResults<[group_ops.Element<bls12381.G1>]>> {
      const tx = new TransactionBlock();
      builder.g1Mul(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [group_ops.Element<bls12381.G1>]
      >(inspectRes);
    }
    export async function g1MultiScalarMultiplication(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
    ): Promise<TypedDevInspectResults<[group_ops.Element<bls12381.G1>]>> {
      const tx = new TransactionBlock();
      builder.g1MultiScalarMultiplication(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [group_ops.Element<bls12381.G1>]
      >(inspectRes);
    }
    export async function g1Neg(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): Promise<TypedDevInspectResults<[group_ops.Element<bls12381.G1>]>> {
      const tx = new TransactionBlock();
      builder.g1Neg(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [group_ops.Element<bls12381.G1>]
      >(inspectRes);
    }
    export async function g1Sub(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
    ): Promise<TypedDevInspectResults<[group_ops.Element<bls12381.G1>]>> {
      const tx = new TransactionBlock();
      builder.g1Sub(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [group_ops.Element<bls12381.G1>]
      >(inspectRes);
    }
    export async function g2Add(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
    ): Promise<TypedDevInspectResults<[group_ops.Element<bls12381.G2>]>> {
      const tx = new TransactionBlock();
      builder.g2Add(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [group_ops.Element<bls12381.G2>]
      >(inspectRes);
    }
    export async function g2Div(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
    ): Promise<TypedDevInspectResults<[group_ops.Element<bls12381.G2>]>> {
      const tx = new TransactionBlock();
      builder.g2Div(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [group_ops.Element<bls12381.G2>]
      >(inspectRes);
    }
    export async function g2FromBytes(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): Promise<TypedDevInspectResults<[group_ops.Element<bls12381.G2>]>> {
      const tx = new TransactionBlock();
      builder.g2FromBytes(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [group_ops.Element<bls12381.G2>]
      >(inspectRes);
    }
    export async function g2Generator(
      client: SuiClient,
      args: [],
    ): Promise<TypedDevInspectResults<[group_ops.Element<bls12381.G2>]>> {
      const tx = new TransactionBlock();
      builder.g2Generator(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [group_ops.Element<bls12381.G2>]
      >(inspectRes);
    }
    export async function g2Identity(
      client: SuiClient,
      args: [],
    ): Promise<TypedDevInspectResults<[group_ops.Element<bls12381.G2>]>> {
      const tx = new TransactionBlock();
      builder.g2Identity(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [group_ops.Element<bls12381.G2>]
      >(inspectRes);
    }
    export async function g2Mul(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
    ): Promise<TypedDevInspectResults<[group_ops.Element<bls12381.G2>]>> {
      const tx = new TransactionBlock();
      builder.g2Mul(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [group_ops.Element<bls12381.G2>]
      >(inspectRes);
    }
    export async function g2MultiScalarMultiplication(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
    ): Promise<TypedDevInspectResults<[group_ops.Element<bls12381.G2>]>> {
      const tx = new TransactionBlock();
      builder.g2MultiScalarMultiplication(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [group_ops.Element<bls12381.G2>]
      >(inspectRes);
    }
    export async function g2Neg(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): Promise<TypedDevInspectResults<[group_ops.Element<bls12381.G2>]>> {
      const tx = new TransactionBlock();
      builder.g2Neg(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [group_ops.Element<bls12381.G2>]
      >(inspectRes);
    }
    export async function g2Sub(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
    ): Promise<TypedDevInspectResults<[group_ops.Element<bls12381.G2>]>> {
      const tx = new TransactionBlock();
      builder.g2Sub(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [group_ops.Element<bls12381.G2>]
      >(inspectRes);
    }
    export async function gtAdd(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
    ): Promise<TypedDevInspectResults<[group_ops.Element<bls12381.GT>]>> {
      const tx = new TransactionBlock();
      builder.gtAdd(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [group_ops.Element<bls12381.GT>]
      >(inspectRes);
    }
    export async function gtDiv(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
    ): Promise<TypedDevInspectResults<[group_ops.Element<bls12381.GT>]>> {
      const tx = new TransactionBlock();
      builder.gtDiv(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [group_ops.Element<bls12381.GT>]
      >(inspectRes);
    }
    export async function gtGenerator(
      client: SuiClient,
      args: [],
    ): Promise<TypedDevInspectResults<[group_ops.Element<bls12381.GT>]>> {
      const tx = new TransactionBlock();
      builder.gtGenerator(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [group_ops.Element<bls12381.GT>]
      >(inspectRes);
    }
    export async function gtIdentity(
      client: SuiClient,
      args: [],
    ): Promise<TypedDevInspectResults<[group_ops.Element<bls12381.GT>]>> {
      const tx = new TransactionBlock();
      builder.gtIdentity(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [group_ops.Element<bls12381.GT>]
      >(inspectRes);
    }
    export async function gtMul(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
    ): Promise<TypedDevInspectResults<[group_ops.Element<bls12381.GT>]>> {
      const tx = new TransactionBlock();
      builder.gtMul(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [group_ops.Element<bls12381.GT>]
      >(inspectRes);
    }
    export async function gtNeg(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): Promise<TypedDevInspectResults<[group_ops.Element<bls12381.GT>]>> {
      const tx = new TransactionBlock();
      builder.gtNeg(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [group_ops.Element<bls12381.GT>]
      >(inspectRes);
    }
    export async function gtSub(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
    ): Promise<TypedDevInspectResults<[group_ops.Element<bls12381.GT>]>> {
      const tx = new TransactionBlock();
      builder.gtSub(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [group_ops.Element<bls12381.GT>]
      >(inspectRes);
    }
    export async function hashToG1(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): Promise<TypedDevInspectResults<[group_ops.Element<bls12381.G1>]>> {
      const tx = new TransactionBlock();
      builder.hashToG1(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [group_ops.Element<bls12381.G1>]
      >(inspectRes);
    }
    export async function hashToG2(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): Promise<TypedDevInspectResults<[group_ops.Element<bls12381.G2>]>> {
      const tx = new TransactionBlock();
      builder.hashToG2(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [group_ops.Element<bls12381.G2>]
      >(inspectRes);
    }
    export async function pairing(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
    ): Promise<TypedDevInspectResults<[group_ops.Element<bls12381.GT>]>> {
      const tx = new TransactionBlock();
      builder.pairing(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [group_ops.Element<bls12381.GT>]
      >(inspectRes);
    }
    export async function scalarAdd(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
    ): Promise<TypedDevInspectResults<[group_ops.Element<bls12381.Scalar>]>> {
      const tx = new TransactionBlock();
      builder.scalarAdd(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [group_ops.Element<bls12381.Scalar>]
      >(inspectRes);
    }
    export async function scalarDiv(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
    ): Promise<TypedDevInspectResults<[group_ops.Element<bls12381.Scalar>]>> {
      const tx = new TransactionBlock();
      builder.scalarDiv(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [group_ops.Element<bls12381.Scalar>]
      >(inspectRes);
    }
    export async function scalarFromBytes(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): Promise<TypedDevInspectResults<[group_ops.Element<bls12381.Scalar>]>> {
      const tx = new TransactionBlock();
      builder.scalarFromBytes(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [group_ops.Element<bls12381.Scalar>]
      >(inspectRes);
    }
    export async function scalarFromU64(
      client: SuiClient,
      args: [bigint | TransactionArgument],
    ): Promise<TypedDevInspectResults<[group_ops.Element<bls12381.Scalar>]>> {
      const tx = new TransactionBlock();
      builder.scalarFromU64(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [group_ops.Element<bls12381.Scalar>]
      >(inspectRes);
    }
    export async function scalarInv(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): Promise<TypedDevInspectResults<[group_ops.Element<bls12381.Scalar>]>> {
      const tx = new TransactionBlock();
      builder.scalarInv(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [group_ops.Element<bls12381.Scalar>]
      >(inspectRes);
    }
    export async function scalarMul(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
    ): Promise<TypedDevInspectResults<[group_ops.Element<bls12381.Scalar>]>> {
      const tx = new TransactionBlock();
      builder.scalarMul(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [group_ops.Element<bls12381.Scalar>]
      >(inspectRes);
    }
    export async function scalarNeg(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): Promise<TypedDevInspectResults<[group_ops.Element<bls12381.Scalar>]>> {
      const tx = new TransactionBlock();
      builder.scalarNeg(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [group_ops.Element<bls12381.Scalar>]
      >(inspectRes);
    }
    export async function scalarOne(
      client: SuiClient,
      args: [],
    ): Promise<TypedDevInspectResults<[group_ops.Element<bls12381.Scalar>]>> {
      const tx = new TransactionBlock();
      builder.scalarOne(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [group_ops.Element<bls12381.Scalar>]
      >(inspectRes);
    }
    export async function scalarSub(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
    ): Promise<TypedDevInspectResults<[group_ops.Element<bls12381.Scalar>]>> {
      const tx = new TransactionBlock();
      builder.scalarSub(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [group_ops.Element<bls12381.Scalar>]
      >(inspectRes);
    }
    export async function scalarZero(
      client: SuiClient,
      args: [],
    ): Promise<TypedDevInspectResults<[group_ops.Element<bls12381.Scalar>]>> {
      const tx = new TransactionBlock();
      builder.scalarZero(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [group_ops.Element<bls12381.Scalar>]
      >(inspectRes);
    }
  }
}

export namespace borrow {
  export interface Borrow {
    ref: string;
    obj: object_.ID;
  }

  export namespace Borrow {
    export const TYPE_QNAME = "0x2::borrow::Borrow";

    const TYPE = new TypeDescriptor<Borrow>(Borrow.TYPE_QNAME);

    export function type(): TypeDescriptor<Borrow> {
      return TYPE.apply();
    }
  }

  export interface Referent<T0> {
    id: string;
    value: _0x1.option.Option<T0>;
  }

  export namespace Referent {
    export const TYPE_QNAME = "0x2::borrow::Referent";

    const TYPE = new TypeDescriptor<Referent<any>>(Referent.TYPE_QNAME);

    export function type<T0>(
      arg0: TypeDescriptor<T0> = ANY_TYPE,
    ): TypeDescriptor<Referent<T0>> {
      return TYPE.apply(arg0);
    }
  }

  export namespace builder {
    export function borrow<T0 = any>(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::borrow::borrow",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function destroy<T0 = any>(
      tx: TransactionBlock,
      args: [borrow.Referent<T0> | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::borrow::destroy",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function new_<T0 = any>(
      tx: TransactionBlock,
      args: [T0 | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::borrow::new",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function putBack<T0 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        T0 | TransactionArgument,
        borrow.Borrow | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));
      _args.push(transactionArgumentOrPure(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::borrow::put_back",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
  }
  export namespace view {
    export async function borrow<T0 = any>(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[T0, borrow.Borrow]>> {
      const tx = new TransactionBlock();
      builder.borrow(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [T0, borrow.Borrow]
      >(inspectRes);
    }
    export async function destroy<T0 = any>(
      client: SuiClient,
      args: [borrow.Referent<T0> | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[T0]>> {
      const tx = new TransactionBlock();
      builder.destroy(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[T0]>(
        inspectRes,
      );
    }
    export async function new_<T0 = any>(
      client: SuiClient,
      args: [T0 | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[borrow.Referent<T0>]>> {
      const tx = new TransactionBlock();
      builder.new_(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [borrow.Referent<T0>]
      >(inspectRes);
    }
    export async function putBack<T0 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        T0 | TransactionArgument,
        borrow.Borrow | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.putBack(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
  }
}

export namespace clock {
  export interface Clock {
    id: object_.UID;
    timestamp_ms: bigint;
  }

  export namespace Clock {
    export const TYPE_QNAME = "0x2::clock::Clock";

    const TYPE = new TypeDescriptor<Clock>(Clock.TYPE_QNAME);

    export function type(): TypeDescriptor<Clock> {
      return TYPE.apply();
    }
  }

  export namespace builder {
    export function timestampMs(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::clock::timestamp_ms",
        arguments: _args,
      });
    }
  }
  export namespace view {
    export async function timestampMs(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new TransactionBlock();
      builder.timestampMs(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
  }
}

export namespace coin {
  export type Coin<T> = string;
  export namespace Coin {
    export const TYPE_QNAME = "0x2::coin::Coin";

    const TYPE = new TypeDescriptor<Coin<any>>(Coin.TYPE_QNAME);

    export function type<T0>(
      arg0: TypeDescriptor<T0> = ANY_TYPE,
    ): TypeDescriptor<Coin<T0>> {
      return TYPE.apply(arg0);
    }
  }

  export interface CoinMetadata<T0> {
    id: object_.UID;
    decimals: number;
    name: string;
    symbol: _0x1.ascii.String;
    description: string;
    icon_url: _0x1.option.Option<url.Url>;
  }

  export namespace CoinMetadata {
    export const TYPE_QNAME = "0x2::coin::CoinMetadata";

    const TYPE = new TypeDescriptor<CoinMetadata<any>>(CoinMetadata.TYPE_QNAME);

    export function type<T0>(
      arg0: TypeDescriptor<T0> = ANY_TYPE,
    ): TypeDescriptor<CoinMetadata<T0>> {
      return TYPE.apply(arg0);
    }
  }

  export interface CurrencyCreated<T0> {
    decimals: number;
  }

  export namespace CurrencyCreated {
    export const TYPE_QNAME = "0x2::coin::CurrencyCreated";

    const TYPE = new TypeDescriptor<CurrencyCreated<any>>(
      CurrencyCreated.TYPE_QNAME,
    );

    export function type<T0>(
      arg0: TypeDescriptor<T0> = ANY_TYPE,
    ): TypeDescriptor<CurrencyCreated<T0>> {
      return TYPE.apply(arg0);
    }
  }

  export interface CurrencyCreatedInstance
    extends TypedEventInstance<CurrencyCreated<any>> {
    data_decoded: CurrencyCreated<any>;
    type_arguments: [string];
  }

  export interface DenyCap<T0> {
    id: object_.UID;
  }

  export namespace DenyCap {
    export const TYPE_QNAME = "0x2::coin::DenyCap";

    const TYPE = new TypeDescriptor<DenyCap<any>>(DenyCap.TYPE_QNAME);

    export function type<T0>(
      arg0: TypeDescriptor<T0> = ANY_TYPE,
    ): TypeDescriptor<DenyCap<T0>> {
      return TYPE.apply(arg0);
    }
  }

  export interface RegulatedCoinMetadata<T0> {
    id: object_.UID;
    coin_metadata_object: object_.ID;
    deny_cap_object: object_.ID;
  }

  export namespace RegulatedCoinMetadata {
    export const TYPE_QNAME = "0x2::coin::RegulatedCoinMetadata";

    const TYPE = new TypeDescriptor<RegulatedCoinMetadata<any>>(
      RegulatedCoinMetadata.TYPE_QNAME,
    );

    export function type<T0>(
      arg0: TypeDescriptor<T0> = ANY_TYPE,
    ): TypeDescriptor<RegulatedCoinMetadata<T0>> {
      return TYPE.apply(arg0);
    }
  }

  export interface TreasuryCap<T0> {
    id: object_.UID;
    total_supply: balance.Supply<T0>;
  }

  export namespace TreasuryCap {
    export const TYPE_QNAME = "0x2::coin::TreasuryCap";

    const TYPE = new TypeDescriptor<TreasuryCap<any>>(TreasuryCap.TYPE_QNAME);

    export function type<T0>(
      arg0: TypeDescriptor<T0> = ANY_TYPE,
    ): TypeDescriptor<TreasuryCap<T0>> {
      return TYPE.apply(arg0);
    }
  }

  export namespace builder {
    export function balance<T0 = any>(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::coin::balance",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function balanceMut<T0 = any>(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::coin::balance_mut",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function burn<T0 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        coin.Coin<T0> | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::coin::burn",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function createCurrency<T0 = any>(
      tx: TransactionBlock,
      args: [
        T0 | TransactionArgument,
        number | TransactionArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
        _0x1.option.Option<url.Url> | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument &
      [
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
      ] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));
      _args.push(transactionArgumentOrVec(args[2], tx));
      _args.push(transactionArgumentOrVec(args[3], tx));
      _args.push(transactionArgumentOrVec(args[4], tx));
      _args.push(transactionArgumentOrPure(args[5], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::coin::create_currency",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function createRegulatedCurrency<T0 = any>(
      tx: TransactionBlock,
      args: [
        T0 | TransactionArgument,
        number | TransactionArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
        _0x1.option.Option<url.Url> | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument &
      [
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
      ] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));
      _args.push(transactionArgumentOrVec(args[2], tx));
      _args.push(transactionArgumentOrVec(args[3], tx));
      _args.push(transactionArgumentOrVec(args[4], tx));
      _args.push(transactionArgumentOrPure(args[5], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::coin::create_regulated_currency",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function denyListAdd<T0 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));
      _args.push(transactionArgumentOrPure(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::coin::deny_list_add",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function denyListContains<T0 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::coin::deny_list_contains",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function denyListRemove<T0 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));
      _args.push(transactionArgumentOrPure(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::coin::deny_list_remove",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function destroyZero<T0 = any>(
      tx: TransactionBlock,
      args: [coin.Coin<T0> | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::coin::destroy_zero",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function divideIntoN<T0 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::coin::divide_into_n",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function fromBalance<T0 = any>(
      tx: TransactionBlock,
      args: [balance.Balance<T0> | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::coin::from_balance",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function getDecimals<T0 = any>(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::coin::get_decimals",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function getDescription<T0 = any>(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::coin::get_description",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function getIconUrl<T0 = any>(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::coin::get_icon_url",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function getName<T0 = any>(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::coin::get_name",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function getSymbol<T0 = any>(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::coin::get_symbol",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function intoBalance<T0 = any>(
      tx: TransactionBlock,
      args: [coin.Coin<T0> | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::coin::into_balance",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function join<T0 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        coin.Coin<T0> | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::coin::join",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function mint<T0 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::coin::mint",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function mintAndTransfer<T0 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
        string | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));
      _args.push(transactionArgumentOrPure(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::coin::mint_and_transfer",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function mintBalance<T0 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::coin::mint_balance",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function put<T0 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        coin.Coin<T0> | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::coin::put",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function split<T0 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::coin::split",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function supply<T0 = any>(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::coin::supply",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function supplyImmut<T0 = any>(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::coin::supply_immut",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function supplyMut<T0 = any>(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::coin::supply_mut",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function take<T0 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::coin::take",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function totalSupply<T0 = any>(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::coin::total_supply",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function treasuryIntoSupply<T0 = any>(
      tx: TransactionBlock,
      args: [coin.TreasuryCap<T0> | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::coin::treasury_into_supply",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function updateDescription<T0 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));
      _args.push(transactionArgumentOrPure(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::coin::update_description",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function updateIconUrl<T0 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        _0x1.ascii.String | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));
      _args.push(transactionArgumentOrPure(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::coin::update_icon_url",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function updateName<T0 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));
      _args.push(transactionArgumentOrPure(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::coin::update_name",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function updateSymbol<T0 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        _0x1.ascii.String | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));
      _args.push(transactionArgumentOrPure(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::coin::update_symbol",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function value<T0 = any>(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::coin::value",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function zero<T0 = any>(
      tx: TransactionBlock,
      args: [],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [] {
      const _args: any[] = [];

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::coin::zero",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
  }
  export namespace view {
    export async function balance<T0 = any>(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new TransactionBlock();
      builder.balance(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function balanceMut<T0 = any>(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new TransactionBlock();
      builder.balanceMut(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function burn<T0 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        coin.Coin<T0> | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new TransactionBlock();
      builder.burn(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function createCurrency<T0 = any>(
      client: SuiClient,
      args: [
        T0 | TransactionArgument,
        number | TransactionArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
        _0x1.option.Option<url.Url> | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<
      TypedDevInspectResults<[coin.TreasuryCap<T0>, coin.CoinMetadata<T0>]>
    > {
      const tx = new TransactionBlock();
      builder.createCurrency(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [coin.TreasuryCap<T0>, coin.CoinMetadata<T0>]
      >(inspectRes);
    }
    export async function createRegulatedCurrency<T0 = any>(
      client: SuiClient,
      args: [
        T0 | TransactionArgument,
        number | TransactionArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
        _0x1.option.Option<url.Url> | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<
      TypedDevInspectResults<
        [coin.TreasuryCap<T0>, coin.DenyCap<T0>, coin.CoinMetadata<T0>]
      >
    > {
      const tx = new TransactionBlock();
      builder.createRegulatedCurrency(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [coin.TreasuryCap<T0>, coin.DenyCap<T0>, coin.CoinMetadata<T0>]
      >(inspectRes);
    }
    export async function denyListAdd<T0 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.denyListAdd(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function denyListContains<T0 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[Boolean]>> {
      const tx = new TransactionBlock();
      builder.denyListContains(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[Boolean]>(
        inspectRes,
      );
    }
    export async function denyListRemove<T0 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.denyListRemove(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function destroyZero<T0 = any>(
      client: SuiClient,
      args: [coin.Coin<T0> | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.destroyZero(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function divideIntoN<T0 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[coin.Coin<T0>[]]>> {
      const tx = new TransactionBlock();
      builder.divideIntoN(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [coin.Coin<T0>[]]
      >(inspectRes);
    }
    export async function fromBalance<T0 = any>(
      client: SuiClient,
      args: [balance.Balance<T0> | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[coin.Coin<T0>]>> {
      const tx = new TransactionBlock();
      builder.fromBalance(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [coin.Coin<T0>]
      >(inspectRes);
    }
    export async function getDecimals<T0 = any>(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[number]>> {
      const tx = new TransactionBlock();
      builder.getDecimals(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[number]>(
        inspectRes,
      );
    }
    export async function getDescription<T0 = any>(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new TransactionBlock();
      builder.getDescription(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function getIconUrl<T0 = any>(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[_0x1.option.Option<url.Url>]>> {
      const tx = new TransactionBlock();
      builder.getIconUrl(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [_0x1.option.Option<url.Url>]
      >(inspectRes);
    }
    export async function getName<T0 = any>(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new TransactionBlock();
      builder.getName(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function getSymbol<T0 = any>(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[_0x1.ascii.String]>> {
      const tx = new TransactionBlock();
      builder.getSymbol(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [_0x1.ascii.String]
      >(inspectRes);
    }
    export async function intoBalance<T0 = any>(
      client: SuiClient,
      args: [coin.Coin<T0> | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[balance.Balance<T0>]>> {
      const tx = new TransactionBlock();
      builder.intoBalance(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [balance.Balance<T0>]
      >(inspectRes);
    }
    export async function join<T0 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        coin.Coin<T0> | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.join(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function mint<T0 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[coin.Coin<T0>]>> {
      const tx = new TransactionBlock();
      builder.mint(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [coin.Coin<T0>]
      >(inspectRes);
    }
    export async function mintAndTransfer<T0 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
        string | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.mintAndTransfer(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function mintBalance<T0 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[balance.Balance<T0>]>> {
      const tx = new TransactionBlock();
      builder.mintBalance(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [balance.Balance<T0>]
      >(inspectRes);
    }
    export async function put<T0 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        coin.Coin<T0> | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.put(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function split<T0 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[coin.Coin<T0>]>> {
      const tx = new TransactionBlock();
      builder.split(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [coin.Coin<T0>]
      >(inspectRes);
    }
    export async function supply<T0 = any>(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new TransactionBlock();
      builder.supply(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function supplyImmut<T0 = any>(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new TransactionBlock();
      builder.supplyImmut(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function supplyMut<T0 = any>(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new TransactionBlock();
      builder.supplyMut(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function take<T0 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[coin.Coin<T0>]>> {
      const tx = new TransactionBlock();
      builder.take(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [coin.Coin<T0>]
      >(inspectRes);
    }
    export async function totalSupply<T0 = any>(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new TransactionBlock();
      builder.totalSupply(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function treasuryIntoSupply<T0 = any>(
      client: SuiClient,
      args: [coin.TreasuryCap<T0> | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[balance.Supply<T0>]>> {
      const tx = new TransactionBlock();
      builder.treasuryIntoSupply(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [balance.Supply<T0>]
      >(inspectRes);
    }
    export async function updateDescription<T0 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.updateDescription(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function updateIconUrl<T0 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        _0x1.ascii.String | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.updateIconUrl(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function updateName<T0 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.updateName(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function updateSymbol<T0 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        _0x1.ascii.String | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.updateSymbol(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function value<T0 = any>(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new TransactionBlock();
      builder.value(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function zero<T0 = any>(
      client: SuiClient,
      args: [],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[coin.Coin<T0>]>> {
      const tx = new TransactionBlock();
      builder.zero(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [coin.Coin<T0>]
      >(inspectRes);
    }
  }
}

export namespace deny_list {
  export interface DenyList {
    id: object_.UID;
    lists: bag.Bag;
  }

  export namespace DenyList {
    export const TYPE_QNAME = "0x2::deny_list::DenyList";

    const TYPE = new TypeDescriptor<DenyList>(DenyList.TYPE_QNAME);

    export function type(): TypeDescriptor<DenyList> {
      return TYPE.apply();
    }
  }

  export interface PerTypeList {
    id: object_.UID;
    denied_count: table.Table<string, bigint>;
    denied_addresses: table.Table<number[], vec_set.VecSet<string>>;
  }

  export namespace PerTypeList {
    export const TYPE_QNAME = "0x2::deny_list::PerTypeList";

    const TYPE = new TypeDescriptor<PerTypeList>(PerTypeList.TYPE_QNAME);

    export function type(): TypeDescriptor<PerTypeList> {
      return TYPE.apply();
    }
  }

  export namespace builder {
    export function add(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
        string | TransactionArgument,
      ],
    ): TransactionArgument &
      [
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
      ] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));
      _args.push(transactionArgumentOrVec(args[2], tx));
      _args.push(transactionArgumentOrPure(args[3], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::deny_list::add",
        arguments: _args,
      });
    }
    export function contains(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
        string | TransactionArgument,
      ],
    ): TransactionArgument &
      [
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
      ] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));
      _args.push(transactionArgumentOrVec(args[2], tx));
      _args.push(transactionArgumentOrPure(args[3], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::deny_list::contains",
        arguments: _args,
      });
    }
    export function remove(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
        string | TransactionArgument,
      ],
    ): TransactionArgument &
      [
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
      ] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));
      _args.push(transactionArgumentOrVec(args[2], tx));
      _args.push(transactionArgumentOrPure(args[3], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::deny_list::remove",
        arguments: _args,
      });
    }
  }
  export namespace view {
    export async function add(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
        string | TransactionArgument,
      ],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.add(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function contains(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
        string | TransactionArgument,
      ],
    ): Promise<TypedDevInspectResults<[Boolean]>> {
      const tx = new TransactionBlock();
      builder.contains(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[Boolean]>(
        inspectRes,
      );
    }
    export async function remove(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
        string | TransactionArgument,
      ],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.remove(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
  }
}

export namespace display {
  export interface Display<T0> {
    id: object_.UID;
    fields: vec_map.VecMap<string, string>;
    version: number;
  }

  export namespace Display {
    export const TYPE_QNAME = "0x2::display::Display";

    const TYPE = new TypeDescriptor<Display<any>>(Display.TYPE_QNAME);

    export function type<T0>(
      arg0: TypeDescriptor<T0> = ANY_TYPE,
    ): TypeDescriptor<Display<T0>> {
      return TYPE.apply(arg0);
    }
  }

  export interface DisplayCreated<T0> {
    id: object_.ID;
  }

  export namespace DisplayCreated {
    export const TYPE_QNAME = "0x2::display::DisplayCreated";

    const TYPE = new TypeDescriptor<DisplayCreated<any>>(
      DisplayCreated.TYPE_QNAME,
    );

    export function type<T0>(
      arg0: TypeDescriptor<T0> = ANY_TYPE,
    ): TypeDescriptor<DisplayCreated<T0>> {
      return TYPE.apply(arg0);
    }
  }

  export interface DisplayCreatedInstance
    extends TypedEventInstance<DisplayCreated<any>> {
    data_decoded: DisplayCreated<any>;
    type_arguments: [string];
  }

  export interface VersionUpdated<T0> {
    id: object_.ID;
    version: number;
    fields: vec_map.VecMap<string, string>;
  }

  export namespace VersionUpdated {
    export const TYPE_QNAME = "0x2::display::VersionUpdated";

    const TYPE = new TypeDescriptor<VersionUpdated<any>>(
      VersionUpdated.TYPE_QNAME,
    );

    export function type<T0>(
      arg0: TypeDescriptor<T0> = ANY_TYPE,
    ): TypeDescriptor<VersionUpdated<T0>> {
      return TYPE.apply(arg0);
    }
  }

  export interface VersionUpdatedInstance
    extends TypedEventInstance<VersionUpdated<any>> {
    data_decoded: VersionUpdated<any>;
    type_arguments: [string];
  }

  export namespace builder {
    export function add<T0 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionArgument,
        string | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));
      _args.push(transactionArgumentOrPure(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::display::add",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function addMultiple<T0 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrVec(args[1], tx));
      _args.push(transactionArgumentOrVec(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::display::add_multiple",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function createAndKeep<T0 = any>(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::display::create_and_keep",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function edit<T0 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionArgument,
        string | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));
      _args.push(transactionArgumentOrPure(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::display::edit",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function fields<T0 = any>(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::display::fields",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function isAuthorized<T0 = any>(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::display::is_authorized",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function new_<T0 = any>(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::display::new",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function newWithFields<T0 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrVec(args[1], tx));
      _args.push(transactionArgumentOrVec(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::display::new_with_fields",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function remove<T0 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::display::remove",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function updateVersion<T0 = any>(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::display::update_version",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function version<T0 = any>(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::display::version",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
  }
  export namespace view {
    export async function add<T0 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionArgument,
        string | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.add(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function addMultiple<T0 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.addMultiple(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function createAndKeep<T0 = any>(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.createAndKeep(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function edit<T0 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionArgument,
        string | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.edit(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function fields<T0 = any>(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new TransactionBlock();
      builder.fields(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function isAuthorized<T0 = any>(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[Boolean]>> {
      const tx = new TransactionBlock();
      builder.isAuthorized(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[Boolean]>(
        inspectRes,
      );
    }
    export async function new_<T0 = any>(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[display.Display<T0>]>> {
      const tx = new TransactionBlock();
      builder.new_(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [display.Display<T0>]
      >(inspectRes);
    }
    export async function newWithFields<T0 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[display.Display<T0>]>> {
      const tx = new TransactionBlock();
      builder.newWithFields(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [display.Display<T0>]
      >(inspectRes);
    }
    export async function remove<T0 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.remove(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function updateVersion<T0 = any>(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.updateVersion(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function version<T0 = any>(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[number]>> {
      const tx = new TransactionBlock();
      builder.version(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[number]>(
        inspectRes,
      );
    }
  }
}

export namespace dynamic_field {
  export interface Field<T0, T1> {
    id: object_.UID;
    name: T0;
    value: T1;
  }

  export namespace Field {
    export const TYPE_QNAME = "0x2::dynamic_field::Field";

    const TYPE = new TypeDescriptor<Field<any, any>>(Field.TYPE_QNAME);

    export function type<T0, T1>(
      arg0: TypeDescriptor<T0> = ANY_TYPE,
      arg1: TypeDescriptor<T1> = ANY_TYPE,
    ): TypeDescriptor<Field<T0, T1>> {
      return TYPE.apply(arg0, arg1);
    }
  }

  export namespace builder {
    export function add<T0 = any, T1 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        T0 | TransactionArgument,
        T1 | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));
      _args.push(transactionArgumentOrPure(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::dynamic_field::add",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function addChildObject<T0 = any>(
      tx: TransactionBlock,
      args: [string | TransactionArgument, T0 | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::dynamic_field::add_child_object",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function borrow<T0 = any, T1 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        T0 | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::dynamic_field::borrow",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function borrowChildObject<T0 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::dynamic_field::borrow_child_object",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function borrowChildObjectMut<T0 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::dynamic_field::borrow_child_object_mut",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function borrowMut<T0 = any, T1 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        T0 | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::dynamic_field::borrow_mut",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function exists_<T0 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        T0 | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::dynamic_field::exists_",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function existsWithType<T0 = any, T1 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        T0 | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::dynamic_field::exists_with_type",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function fieldInfo<T0 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        T0 | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::dynamic_field::field_info",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function fieldInfoMut<T0 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        T0 | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::dynamic_field::field_info_mut",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function hasChildObject(
      tx: TransactionBlock,
      args: [string | TransactionArgument, string | TransactionArgument],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::dynamic_field::has_child_object",
        arguments: _args,
      });
    }
    export function hasChildObjectWithTy<T0 = any>(
      tx: TransactionBlock,
      args: [string | TransactionArgument, string | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::dynamic_field::has_child_object_with_ty",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function hashTypeAndKey<T0 = any>(
      tx: TransactionBlock,
      args: [string | TransactionArgument, T0 | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::dynamic_field::hash_type_and_key",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function remove<T0 = any, T1 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        T0 | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::dynamic_field::remove",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function removeChildObject<T0 = any>(
      tx: TransactionBlock,
      args: [string | TransactionArgument, string | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::dynamic_field::remove_child_object",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function removeIfExists<T0 = any, T1 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        T0 | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::dynamic_field::remove_if_exists",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
  }
  export namespace view {
    export async function add<T0 = any, T1 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        T0 | TransactionArgument,
        T1 | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.add(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function addChildObject<T0 = any>(
      client: SuiClient,
      args: [string | TransactionArgument, T0 | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.addChildObject(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function borrow<T0 = any, T1 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        T0 | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new TransactionBlock();
      builder.borrow(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function borrowChildObject<T0 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new TransactionBlock();
      builder.borrowChildObject(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function borrowChildObjectMut<T0 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new TransactionBlock();
      builder.borrowChildObjectMut(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function borrowMut<T0 = any, T1 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        T0 | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new TransactionBlock();
      builder.borrowMut(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function exists_<T0 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        T0 | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[Boolean]>> {
      const tx = new TransactionBlock();
      builder.exists_(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[Boolean]>(
        inspectRes,
      );
    }
    export async function existsWithType<T0 = any, T1 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        T0 | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[Boolean]>> {
      const tx = new TransactionBlock();
      builder.existsWithType(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[Boolean]>(
        inspectRes,
      );
    }
    export async function fieldInfo<T0 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        T0 | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[string, string]>> {
      const tx = new TransactionBlock();
      builder.fieldInfo(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [string, string]
      >(inspectRes);
    }
    export async function fieldInfoMut<T0 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        T0 | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[string, string]>> {
      const tx = new TransactionBlock();
      builder.fieldInfoMut(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [string, string]
      >(inspectRes);
    }
    export async function hasChildObject(
      client: SuiClient,
      args: [string | TransactionArgument, string | TransactionArgument],
    ): Promise<TypedDevInspectResults<[Boolean]>> {
      const tx = new TransactionBlock();
      builder.hasChildObject(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[Boolean]>(
        inspectRes,
      );
    }
    export async function hasChildObjectWithTy<T0 = any>(
      client: SuiClient,
      args: [string | TransactionArgument, string | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[Boolean]>> {
      const tx = new TransactionBlock();
      builder.hasChildObjectWithTy(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[Boolean]>(
        inspectRes,
      );
    }
    export async function hashTypeAndKey<T0 = any>(
      client: SuiClient,
      args: [string | TransactionArgument, T0 | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new TransactionBlock();
      builder.hashTypeAndKey(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function remove<T0 = any, T1 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        T0 | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[T1]>> {
      const tx = new TransactionBlock();
      builder.remove(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[T1]>(
        inspectRes,
      );
    }
    export async function removeChildObject<T0 = any>(
      client: SuiClient,
      args: [string | TransactionArgument, string | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[T0]>> {
      const tx = new TransactionBlock();
      builder.removeChildObject(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[T0]>(
        inspectRes,
      );
    }
    export async function removeIfExists<T0 = any, T1 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        T0 | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[_0x1.option.Option<T1>]>> {
      const tx = new TransactionBlock();
      builder.removeIfExists(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [_0x1.option.Option<T1>]
      >(inspectRes);
    }
  }
}

export namespace dynamic_object_field {
  export interface Wrapper<T0> {
    name: T0;
  }

  export namespace Wrapper {
    export const TYPE_QNAME = "0x2::dynamic_object_field::Wrapper";

    const TYPE = new TypeDescriptor<Wrapper<any>>(Wrapper.TYPE_QNAME);

    export function type<T0>(
      arg0: TypeDescriptor<T0> = ANY_TYPE,
    ): TypeDescriptor<Wrapper<T0>> {
      return TYPE.apply(arg0);
    }
  }

  export interface WrapperInstance extends TypedEventInstance<Wrapper<any>> {
    data_decoded: Wrapper<any>;
    type_arguments: [string];
  }

  export namespace builder {
    export function add<T0 = any, T1 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        T0 | TransactionArgument,
        T1 | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));
      _args.push(transactionArgumentOrPure(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::dynamic_object_field::add",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function borrow<T0 = any, T1 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        T0 | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::dynamic_object_field::borrow",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function borrowMut<T0 = any, T1 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        T0 | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::dynamic_object_field::borrow_mut",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function exists_<T0 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        T0 | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::dynamic_object_field::exists_",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function existsWithType<T0 = any, T1 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        T0 | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::dynamic_object_field::exists_with_type",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function id<T0 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        T0 | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::dynamic_object_field::id",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function remove<T0 = any, T1 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        T0 | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::dynamic_object_field::remove",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
  }
  export namespace view {
    export async function add<T0 = any, T1 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        T0 | TransactionArgument,
        T1 | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.add(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function borrow<T0 = any, T1 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        T0 | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new TransactionBlock();
      builder.borrow(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function borrowMut<T0 = any, T1 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        T0 | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new TransactionBlock();
      builder.borrowMut(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function exists_<T0 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        T0 | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[Boolean]>> {
      const tx = new TransactionBlock();
      builder.exists_(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[Boolean]>(
        inspectRes,
      );
    }
    export async function existsWithType<T0 = any, T1 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        T0 | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[Boolean]>> {
      const tx = new TransactionBlock();
      builder.existsWithType(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[Boolean]>(
        inspectRes,
      );
    }
    export async function id<T0 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        T0 | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[_0x1.option.Option<object_.ID>]>> {
      const tx = new TransactionBlock();
      builder.id(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [_0x1.option.Option<object_.ID>]
      >(inspectRes);
    }
    export async function remove<T0 = any, T1 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        T0 | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[T1]>> {
      const tx = new TransactionBlock();
      builder.remove(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[T1]>(
        inspectRes,
      );
    }
  }
}

export namespace ecdsa_k1 {
  export namespace builder {
    export function decompressPubkey(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::ecdsa_k1::decompress_pubkey",
        arguments: _args,
      });
    }
    export function secp256k1Ecrecover(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        number | TransactionArgument,
      ],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));
      _args.push(transactionArgumentOrPure(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::ecdsa_k1::secp256k1_ecrecover",
        arguments: _args,
      });
    }
    export function secp256k1Verify(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        number | TransactionArgument,
      ],
    ): TransactionArgument &
      [
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
      ] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));
      _args.push(transactionArgumentOrObject(args[2], tx));
      _args.push(transactionArgumentOrPure(args[3], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::ecdsa_k1::secp256k1_verify",
        arguments: _args,
      });
    }
  }
  export namespace view {
    export async function decompressPubkey(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): Promise<TypedDevInspectResults<[number[]]>> {
      const tx = new TransactionBlock();
      builder.decompressPubkey(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[number[]]>(
        inspectRes,
      );
    }
    export async function secp256k1Ecrecover(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        number | TransactionArgument,
      ],
    ): Promise<TypedDevInspectResults<[number[]]>> {
      const tx = new TransactionBlock();
      builder.secp256k1Ecrecover(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[number[]]>(
        inspectRes,
      );
    }
    export async function secp256k1Verify(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        number | TransactionArgument,
      ],
    ): Promise<TypedDevInspectResults<[Boolean]>> {
      const tx = new TransactionBlock();
      builder.secp256k1Verify(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[Boolean]>(
        inspectRes,
      );
    }
  }
}

export namespace ecdsa_r1 {
  export namespace builder {
    export function secp256r1Ecrecover(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        number | TransactionArgument,
      ],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));
      _args.push(transactionArgumentOrPure(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::ecdsa_r1::secp256r1_ecrecover",
        arguments: _args,
      });
    }
    export function secp256r1Verify(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        number | TransactionArgument,
      ],
    ): TransactionArgument &
      [
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
      ] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));
      _args.push(transactionArgumentOrObject(args[2], tx));
      _args.push(transactionArgumentOrPure(args[3], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::ecdsa_r1::secp256r1_verify",
        arguments: _args,
      });
    }
  }
  export namespace view {
    export async function secp256r1Ecrecover(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        number | TransactionArgument,
      ],
    ): Promise<TypedDevInspectResults<[number[]]>> {
      const tx = new TransactionBlock();
      builder.secp256r1Ecrecover(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[number[]]>(
        inspectRes,
      );
    }
    export async function secp256r1Verify(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        number | TransactionArgument,
      ],
    ): Promise<TypedDevInspectResults<[Boolean]>> {
      const tx = new TransactionBlock();
      builder.secp256r1Verify(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[Boolean]>(
        inspectRes,
      );
    }
  }
}

export namespace ecvrf {
  export namespace builder {
    export function ecvrfVerify(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
    ): TransactionArgument &
      [
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
      ] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));
      _args.push(transactionArgumentOrObject(args[2], tx));
      _args.push(transactionArgumentOrObject(args[3], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::ecvrf::ecvrf_verify",
        arguments: _args,
      });
    }
  }
  export namespace view {
    export async function ecvrfVerify(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
    ): Promise<TypedDevInspectResults<[Boolean]>> {
      const tx = new TransactionBlock();
      builder.ecvrfVerify(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[Boolean]>(
        inspectRes,
      );
    }
  }
}

export namespace ed25519 {
  export namespace builder {
    export function ed25519Verify(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));
      _args.push(transactionArgumentOrObject(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::ed25519::ed25519_verify",
        arguments: _args,
      });
    }
  }
  export namespace view {
    export async function ed25519Verify(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
    ): Promise<TypedDevInspectResults<[Boolean]>> {
      const tx = new TransactionBlock();
      builder.ed25519Verify(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[Boolean]>(
        inspectRes,
      );
    }
  }
}

export namespace event {
  export namespace builder {
    export function emit<T0 = any>(
      tx: TransactionBlock,
      args: [T0 | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::event::emit",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
  }
  export namespace view {
    export async function emit<T0 = any>(
      client: SuiClient,
      args: [T0 | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.emit(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
  }
}

export namespace groth16 {
  export interface Curve {
    id: number;
  }

  export namespace Curve {
    export const TYPE_QNAME = "0x2::groth16::Curve";

    const TYPE = new TypeDescriptor<Curve>(Curve.TYPE_QNAME);

    export function type(): TypeDescriptor<Curve> {
      return TYPE.apply();
    }
  }

  export interface CurveInstance extends TypedEventInstance<Curve> {
    data_decoded: Curve;
    type_arguments: [];
  }

  export interface PreparedVerifyingKey {
    vk_gamma_abc_g1_bytes: number[];
    alpha_g1_beta_g2_bytes: number[];
    gamma_g2_neg_pc_bytes: number[];
    delta_g2_neg_pc_bytes: number[];
  }

  export namespace PreparedVerifyingKey {
    export const TYPE_QNAME = "0x2::groth16::PreparedVerifyingKey";

    const TYPE = new TypeDescriptor<PreparedVerifyingKey>(
      PreparedVerifyingKey.TYPE_QNAME,
    );

    export function type(): TypeDescriptor<PreparedVerifyingKey> {
      return TYPE.apply();
    }
  }

  export interface PreparedVerifyingKeyInstance
    extends TypedEventInstance<PreparedVerifyingKey> {
    data_decoded: PreparedVerifyingKey;
    type_arguments: [];
  }

  export interface ProofPoints {
    bytes: number[];
  }

  export namespace ProofPoints {
    export const TYPE_QNAME = "0x2::groth16::ProofPoints";

    const TYPE = new TypeDescriptor<ProofPoints>(ProofPoints.TYPE_QNAME);

    export function type(): TypeDescriptor<ProofPoints> {
      return TYPE.apply();
    }
  }

  export interface ProofPointsInstance extends TypedEventInstance<ProofPoints> {
    data_decoded: ProofPoints;
    type_arguments: [];
  }

  export interface PublicProofInputs {
    bytes: number[];
  }

  export namespace PublicProofInputs {
    export const TYPE_QNAME = "0x2::groth16::PublicProofInputs";

    const TYPE = new TypeDescriptor<PublicProofInputs>(
      PublicProofInputs.TYPE_QNAME,
    );

    export function type(): TypeDescriptor<PublicProofInputs> {
      return TYPE.apply();
    }
  }

  export interface PublicProofInputsInstance
    extends TypedEventInstance<PublicProofInputs> {
    data_decoded: PublicProofInputs;
    type_arguments: [];
  }

  export namespace builder {
    export function bls12381(
      tx: TransactionBlock,
      args: [],
    ): TransactionArgument & [] {
      const _args: any[] = [];

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::groth16::bls12381",
        arguments: _args,
      });
    }
    export function bn254(
      tx: TransactionBlock,
      args: [],
    ): TransactionArgument & [] {
      const _args: any[] = [];

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::groth16::bn254",
        arguments: _args,
      });
    }
    export function prepareVerifyingKey(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::groth16::prepare_verifying_key",
        arguments: _args,
      });
    }
    export function proofPointsFromBytes(
      tx: TransactionBlock,
      args: [(string | TransactionObjectArgument)[] | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrVec(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::groth16::proof_points_from_bytes",
        arguments: _args,
      });
    }
    export function publicProofInputsFromBytes(
      tx: TransactionBlock,
      args: [(string | TransactionObjectArgument)[] | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrVec(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::groth16::public_proof_inputs_from_bytes",
        arguments: _args,
      });
    }
    export function pvkFromBytes(
      tx: TransactionBlock,
      args: [
        (string | TransactionObjectArgument)[] | TransactionArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
      ],
    ): TransactionArgument &
      [
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
      ] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrVec(args[0], tx));
      _args.push(transactionArgumentOrVec(args[1], tx));
      _args.push(transactionArgumentOrVec(args[2], tx));
      _args.push(transactionArgumentOrVec(args[3], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::groth16::pvk_from_bytes",
        arguments: _args,
      });
    }
    export function pvkToBytes(
      tx: TransactionBlock,
      args: [groth16.PreparedVerifyingKey | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::groth16::pvk_to_bytes",
        arguments: _args,
      });
    }
    export function verifyGroth16Proof(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
    ): TransactionArgument &
      [
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
      ] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));
      _args.push(transactionArgumentOrObject(args[2], tx));
      _args.push(transactionArgumentOrObject(args[3], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::groth16::verify_groth16_proof",
        arguments: _args,
      });
    }
  }
  export namespace view {
    export async function bls12381(
      client: SuiClient,
      args: [],
    ): Promise<TypedDevInspectResults<[groth16.Curve]>> {
      const tx = new TransactionBlock();
      builder.bls12381(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [groth16.Curve]
      >(inspectRes);
    }
    export async function bn254(
      client: SuiClient,
      args: [],
    ): Promise<TypedDevInspectResults<[groth16.Curve]>> {
      const tx = new TransactionBlock();
      builder.bn254(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [groth16.Curve]
      >(inspectRes);
    }
    export async function prepareVerifyingKey(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
    ): Promise<TypedDevInspectResults<[groth16.PreparedVerifyingKey]>> {
      const tx = new TransactionBlock();
      builder.prepareVerifyingKey(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [groth16.PreparedVerifyingKey]
      >(inspectRes);
    }
    export async function proofPointsFromBytes(
      client: SuiClient,
      args: [(string | TransactionObjectArgument)[] | TransactionArgument],
    ): Promise<TypedDevInspectResults<[groth16.ProofPoints]>> {
      const tx = new TransactionBlock();
      builder.proofPointsFromBytes(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [groth16.ProofPoints]
      >(inspectRes);
    }
    export async function publicProofInputsFromBytes(
      client: SuiClient,
      args: [(string | TransactionObjectArgument)[] | TransactionArgument],
    ): Promise<TypedDevInspectResults<[groth16.PublicProofInputs]>> {
      const tx = new TransactionBlock();
      builder.publicProofInputsFromBytes(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [groth16.PublicProofInputs]
      >(inspectRes);
    }
    export async function pvkFromBytes(
      client: SuiClient,
      args: [
        (string | TransactionObjectArgument)[] | TransactionArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
      ],
    ): Promise<TypedDevInspectResults<[groth16.PreparedVerifyingKey]>> {
      const tx = new TransactionBlock();
      builder.pvkFromBytes(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [groth16.PreparedVerifyingKey]
      >(inspectRes);
    }
    export async function pvkToBytes(
      client: SuiClient,
      args: [groth16.PreparedVerifyingKey | TransactionArgument],
    ): Promise<TypedDevInspectResults<[number[][]]>> {
      const tx = new TransactionBlock();
      builder.pvkToBytes(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[number[][]]>(
        inspectRes,
      );
    }
    export async function verifyGroth16Proof(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
    ): Promise<TypedDevInspectResults<[Boolean]>> {
      const tx = new TransactionBlock();
      builder.verifyGroth16Proof(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[Boolean]>(
        inspectRes,
      );
    }
  }
}

export namespace group_ops {
  export interface Element<T0> {
    bytes: number[];
  }

  export namespace Element {
    export const TYPE_QNAME = "0x2::group_ops::Element";

    const TYPE = new TypeDescriptor<Element<any>>(Element.TYPE_QNAME);

    export function type<T0>(
      arg0: TypeDescriptor<T0> = ANY_TYPE,
    ): TypeDescriptor<Element<T0>> {
      return TYPE.apply(arg0);
    }
  }

  export interface ElementInstance extends TypedEventInstance<Element<any>> {
    data_decoded: Element<any>;
    type_arguments: [string];
  }

  export namespace builder {
    export function add<T0 = any>(
      tx: TransactionBlock,
      args: [
        number | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));
      _args.push(transactionArgumentOrObject(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::group_ops::add",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function bytes<T0 = any>(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::group_ops::bytes",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function div<T0 = any, T1 = any>(
      tx: TransactionBlock,
      args: [
        number | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));
      _args.push(transactionArgumentOrObject(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::group_ops::div",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function equal<T0 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::group_ops::equal",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function fromBytes<T0 = any>(
      tx: TransactionBlock,
      args: [
        number | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        Boolean | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));
      _args.push(transactionArgumentOrPure(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::group_ops::from_bytes",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function hashTo<T0 = any>(
      tx: TransactionBlock,
      args: [
        number | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::group_ops::hash_to",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function mul<T0 = any, T1 = any>(
      tx: TransactionBlock,
      args: [
        number | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));
      _args.push(transactionArgumentOrObject(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::group_ops::mul",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function multiScalarMultiplication<T0 = any, T1 = any>(
      tx: TransactionBlock,
      args: [
        number | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));
      _args.push(transactionArgumentOrObject(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::group_ops::multi_scalar_multiplication",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function pairing<T0 = any, T1 = any, T2 = any>(
      tx: TransactionBlock,
      args: [
        number | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
      typeArguments: [
        TypeDescriptor<T0> | string,
        TypeDescriptor<T1> | string,
        TypeDescriptor<T2> | string,
      ],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));
      _args.push(transactionArgumentOrObject(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::group_ops::pairing",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
          typeof typeArguments[2] === "string"
            ? typeArguments[2]
            : typeArguments[2].getSignature(),
        ],
      });
    }
    export function setAsPrefix(
      tx: TransactionBlock,
      args: [
        bigint | TransactionArgument,
        Boolean | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));
      _args.push(transactionArgumentOrObject(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::group_ops::set_as_prefix",
        arguments: _args,
      });
    }
    export function sub<T0 = any>(
      tx: TransactionBlock,
      args: [
        number | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));
      _args.push(transactionArgumentOrObject(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::group_ops::sub",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
  }
  export namespace view {
    export async function add<T0 = any>(
      client: SuiClient,
      args: [
        number | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[group_ops.Element<T0>]>> {
      const tx = new TransactionBlock();
      builder.add(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [group_ops.Element<T0>]
      >(inspectRes);
    }
    export async function bytes<T0 = any>(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new TransactionBlock();
      builder.bytes(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function div<T0 = any, T1 = any>(
      client: SuiClient,
      args: [
        number | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[group_ops.Element<T1>]>> {
      const tx = new TransactionBlock();
      builder.div(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [group_ops.Element<T1>]
      >(inspectRes);
    }
    export async function equal<T0 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[Boolean]>> {
      const tx = new TransactionBlock();
      builder.equal(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[Boolean]>(
        inspectRes,
      );
    }
    export async function fromBytes<T0 = any>(
      client: SuiClient,
      args: [
        number | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        Boolean | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[group_ops.Element<T0>]>> {
      const tx = new TransactionBlock();
      builder.fromBytes(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [group_ops.Element<T0>]
      >(inspectRes);
    }
    export async function hashTo<T0 = any>(
      client: SuiClient,
      args: [
        number | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[group_ops.Element<T0>]>> {
      const tx = new TransactionBlock();
      builder.hashTo(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [group_ops.Element<T0>]
      >(inspectRes);
    }
    export async function mul<T0 = any, T1 = any>(
      client: SuiClient,
      args: [
        number | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[group_ops.Element<T1>]>> {
      const tx = new TransactionBlock();
      builder.mul(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [group_ops.Element<T1>]
      >(inspectRes);
    }
    export async function multiScalarMultiplication<T0 = any, T1 = any>(
      client: SuiClient,
      args: [
        number | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[group_ops.Element<T1>]>> {
      const tx = new TransactionBlock();
      builder.multiScalarMultiplication(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [group_ops.Element<T1>]
      >(inspectRes);
    }
    export async function pairing<T0 = any, T1 = any, T2 = any>(
      client: SuiClient,
      args: [
        number | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
      typeArguments: [
        TypeDescriptor<T0> | string,
        TypeDescriptor<T1> | string,
        TypeDescriptor<T2> | string,
      ],
    ): Promise<TypedDevInspectResults<[group_ops.Element<T2>]>> {
      const tx = new TransactionBlock();
      builder.pairing(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [group_ops.Element<T2>]
      >(inspectRes);
    }
    export async function setAsPrefix(
      client: SuiClient,
      args: [
        bigint | TransactionArgument,
        Boolean | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.setAsPrefix(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function sub<T0 = any>(
      client: SuiClient,
      args: [
        number | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[group_ops.Element<T0>]>> {
      const tx = new TransactionBlock();
      builder.sub(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [group_ops.Element<T0>]
      >(inspectRes);
    }
  }
}

export namespace hash {
  export namespace builder {
    export function blake2b256(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::hash::blake2b256",
        arguments: _args,
      });
    }
    export function keccak256(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::hash::keccak256",
        arguments: _args,
      });
    }
  }
  export namespace view {
    export async function blake2b256(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): Promise<TypedDevInspectResults<[number[]]>> {
      const tx = new TransactionBlock();
      builder.blake2b256(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[number[]]>(
        inspectRes,
      );
    }
    export async function keccak256(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): Promise<TypedDevInspectResults<[number[]]>> {
      const tx = new TransactionBlock();
      builder.keccak256(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[number[]]>(
        inspectRes,
      );
    }
  }
}

export namespace hex {
  export namespace builder {
    export function decode(
      tx: TransactionBlock,
      args: [(string | TransactionObjectArgument)[] | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrVec(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::hex::decode",
        arguments: _args,
      });
    }
    export function encode(
      tx: TransactionBlock,
      args: [(string | TransactionObjectArgument)[] | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrVec(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::hex::encode",
        arguments: _args,
      });
    }
  }
  export namespace view {
    export async function decode(
      client: SuiClient,
      args: [(string | TransactionObjectArgument)[] | TransactionArgument],
    ): Promise<TypedDevInspectResults<[number[]]>> {
      const tx = new TransactionBlock();
      builder.decode(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[number[]]>(
        inspectRes,
      );
    }
    export async function encode(
      client: SuiClient,
      args: [(string | TransactionObjectArgument)[] | TransactionArgument],
    ): Promise<TypedDevInspectResults<[number[]]>> {
      const tx = new TransactionBlock();
      builder.encode(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[number[]]>(
        inspectRes,
      );
    }
  }
}

export namespace hmac {
  export namespace builder {
    export function hmacSha3256(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::hmac::hmac_sha3_256",
        arguments: _args,
      });
    }
  }
  export namespace view {
    export async function hmacSha3256(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
    ): Promise<TypedDevInspectResults<[number[]]>> {
      const tx = new TransactionBlock();
      builder.hmacSha3256(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[number[]]>(
        inspectRes,
      );
    }
  }
}

export namespace kiosk {
  export interface Borrow {
    kiosk_id: object_.ID;
    item_id: object_.ID;
  }

  export namespace Borrow {
    export const TYPE_QNAME = "0x2::kiosk::Borrow";

    const TYPE = new TypeDescriptor<Borrow>(Borrow.TYPE_QNAME);

    export function type(): TypeDescriptor<Borrow> {
      return TYPE.apply();
    }
  }

  export interface Item {
    id: object_.ID;
  }

  export namespace Item {
    export const TYPE_QNAME = "0x2::kiosk::Item";

    const TYPE = new TypeDescriptor<Item>(Item.TYPE_QNAME);

    export function type(): TypeDescriptor<Item> {
      return TYPE.apply();
    }
  }

  export interface ItemInstance extends TypedEventInstance<Item> {
    data_decoded: Item;
    type_arguments: [];
  }

  export interface ItemDelisted<T0> {
    kiosk: object_.ID;
    id: object_.ID;
  }

  export namespace ItemDelisted {
    export const TYPE_QNAME = "0x2::kiosk::ItemDelisted";

    const TYPE = new TypeDescriptor<ItemDelisted<any>>(ItemDelisted.TYPE_QNAME);

    export function type<T0>(
      arg0: TypeDescriptor<T0> = ANY_TYPE,
    ): TypeDescriptor<ItemDelisted<T0>> {
      return TYPE.apply(arg0);
    }
  }

  export interface ItemDelistedInstance
    extends TypedEventInstance<ItemDelisted<any>> {
    data_decoded: ItemDelisted<any>;
    type_arguments: [string];
  }

  export interface ItemListed<T0> {
    kiosk: object_.ID;
    id: object_.ID;
    price: bigint;
  }

  export namespace ItemListed {
    export const TYPE_QNAME = "0x2::kiosk::ItemListed";

    const TYPE = new TypeDescriptor<ItemListed<any>>(ItemListed.TYPE_QNAME);

    export function type<T0>(
      arg0: TypeDescriptor<T0> = ANY_TYPE,
    ): TypeDescriptor<ItemListed<T0>> {
      return TYPE.apply(arg0);
    }
  }

  export interface ItemListedInstance
    extends TypedEventInstance<ItemListed<any>> {
    data_decoded: ItemListed<any>;
    type_arguments: [string];
  }

  export interface ItemPurchased<T0> {
    kiosk: object_.ID;
    id: object_.ID;
    price: bigint;
  }

  export namespace ItemPurchased {
    export const TYPE_QNAME = "0x2::kiosk::ItemPurchased";

    const TYPE = new TypeDescriptor<ItemPurchased<any>>(
      ItemPurchased.TYPE_QNAME,
    );

    export function type<T0>(
      arg0: TypeDescriptor<T0> = ANY_TYPE,
    ): TypeDescriptor<ItemPurchased<T0>> {
      return TYPE.apply(arg0);
    }
  }

  export interface ItemPurchasedInstance
    extends TypedEventInstance<ItemPurchased<any>> {
    data_decoded: ItemPurchased<any>;
    type_arguments: [string];
  }

  export interface Kiosk {
    id: object_.UID;
    profits: balance.Balance<sui.SUI>;
    owner: string;
    item_count: number;
    allow_extensions: Boolean;
  }

  export namespace Kiosk {
    export const TYPE_QNAME = "0x2::kiosk::Kiosk";

    const TYPE = new TypeDescriptor<Kiosk>(Kiosk.TYPE_QNAME);

    export function type(): TypeDescriptor<Kiosk> {
      return TYPE.apply();
    }
  }

  export interface KioskOwnerCap {
    id: object_.UID;
    for: object_.ID;
  }

  export namespace KioskOwnerCap {
    export const TYPE_QNAME = "0x2::kiosk::KioskOwnerCap";

    const TYPE = new TypeDescriptor<KioskOwnerCap>(KioskOwnerCap.TYPE_QNAME);

    export function type(): TypeDescriptor<KioskOwnerCap> {
      return TYPE.apply();
    }
  }

  export interface Listing {
    id: object_.ID;
    is_exclusive: Boolean;
  }

  export namespace Listing {
    export const TYPE_QNAME = "0x2::kiosk::Listing";

    const TYPE = new TypeDescriptor<Listing>(Listing.TYPE_QNAME);

    export function type(): TypeDescriptor<Listing> {
      return TYPE.apply();
    }
  }

  export interface ListingInstance extends TypedEventInstance<Listing> {
    data_decoded: Listing;
    type_arguments: [];
  }

  export interface Lock {
    id: object_.ID;
  }

  export namespace Lock {
    export const TYPE_QNAME = "0x2::kiosk::Lock";

    const TYPE = new TypeDescriptor<Lock>(Lock.TYPE_QNAME);

    export function type(): TypeDescriptor<Lock> {
      return TYPE.apply();
    }
  }

  export interface LockInstance extends TypedEventInstance<Lock> {
    data_decoded: Lock;
    type_arguments: [];
  }

  export interface PurchaseCap<T0> {
    id: object_.UID;
    kiosk_id: object_.ID;
    item_id: object_.ID;
    min_price: bigint;
  }

  export namespace PurchaseCap {
    export const TYPE_QNAME = "0x2::kiosk::PurchaseCap";

    const TYPE = new TypeDescriptor<PurchaseCap<any>>(PurchaseCap.TYPE_QNAME);

    export function type<T0>(
      arg0: TypeDescriptor<T0> = ANY_TYPE,
    ): TypeDescriptor<PurchaseCap<T0>> {
      return TYPE.apply(arg0);
    }
  }

  export namespace builder {
    export function borrow<T0 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        object_.ID | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));
      _args.push(transactionArgumentOrPure(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::kiosk::borrow",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function borrowMut<T0 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        object_.ID | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));
      _args.push(transactionArgumentOrPure(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::kiosk::borrow_mut",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function borrowVal<T0 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        object_.ID | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));
      _args.push(transactionArgumentOrPure(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::kiosk::borrow_val",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function closeAndWithdraw(
      tx: TransactionBlock,
      args: [
        kiosk.Kiosk | TransactionArgument,
        kiosk.KioskOwnerCap | TransactionArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::kiosk::close_and_withdraw",
        arguments: _args,
      });
    }
    export function default_(
      tx: TransactionBlock,
      args: [],
    ): TransactionArgument & [] {
      const _args: any[] = [];

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::kiosk::default",
        arguments: _args,
      });
    }
    export function delist<T0 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        object_.ID | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));
      _args.push(transactionArgumentOrPure(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::kiosk::delist",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function hasAccess(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::kiosk::has_access",
        arguments: _args,
      });
    }
    export function hasItem(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        object_.ID | TransactionArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::kiosk::has_item",
        arguments: _args,
      });
    }
    export function hasItemWithType<T0 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        object_.ID | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::kiosk::has_item_with_type",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function isListed(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        object_.ID | TransactionArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::kiosk::is_listed",
        arguments: _args,
      });
    }
    export function isListedExclusively(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        object_.ID | TransactionArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::kiosk::is_listed_exclusively",
        arguments: _args,
      });
    }
    export function isLocked(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        object_.ID | TransactionArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::kiosk::is_locked",
        arguments: _args,
      });
    }
    export function itemCount(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::kiosk::item_count",
        arguments: _args,
      });
    }
    export function kioskOwnerCapFor(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::kiosk::kiosk_owner_cap_for",
        arguments: _args,
      });
    }
    export function list<T0 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        object_.ID | TransactionArgument,
        bigint | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument &
      [
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
      ] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));
      _args.push(transactionArgumentOrPure(args[2], tx));
      _args.push(transactionArgumentOrPure(args[3], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::kiosk::list",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function listWithPurchaseCap<T0 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        object_.ID | TransactionArgument,
        bigint | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument &
      [
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
      ] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));
      _args.push(transactionArgumentOrPure(args[2], tx));
      _args.push(transactionArgumentOrPure(args[3], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::kiosk::list_with_purchase_cap",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function lock<T0 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        T0 | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument &
      [
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
      ] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));
      _args.push(transactionArgumentOrObject(args[2], tx));
      _args.push(transactionArgumentOrPure(args[3], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::kiosk::lock",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function lockInternal<T0 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        T0 | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::kiosk::lock_internal",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function new_(
      tx: TransactionBlock,
      args: [],
    ): TransactionArgument & [] {
      const _args: any[] = [];

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::kiosk::new",
        arguments: _args,
      });
    }
    export function owner(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::kiosk::owner",
        arguments: _args,
      });
    }
    export function place<T0 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        T0 | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));
      _args.push(transactionArgumentOrPure(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::kiosk::place",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function placeAndList<T0 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        T0 | TransactionArgument,
        bigint | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument &
      [
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
      ] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));
      _args.push(transactionArgumentOrPure(args[2], tx));
      _args.push(transactionArgumentOrPure(args[3], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::kiosk::place_and_list",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function placeInternal<T0 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        T0 | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::kiosk::place_internal",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function profitsAmount(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::kiosk::profits_amount",
        arguments: _args,
      });
    }
    export function profitsMut(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::kiosk::profits_mut",
        arguments: _args,
      });
    }
    export function purchase<T0 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        object_.ID | TransactionArgument,
        coin.Coin<sui.SUI> | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));
      _args.push(transactionArgumentOrPure(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::kiosk::purchase",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function purchaseCapItem<T0 = any>(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::kiosk::purchase_cap_item",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function purchaseCapKiosk<T0 = any>(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::kiosk::purchase_cap_kiosk",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function purchaseCapMinPrice<T0 = any>(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::kiosk::purchase_cap_min_price",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function purchaseWithCap<T0 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        kiosk.PurchaseCap<T0> | TransactionArgument,
        coin.Coin<sui.SUI> | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));
      _args.push(transactionArgumentOrPure(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::kiosk::purchase_with_cap",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function returnPurchaseCap<T0 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        kiosk.PurchaseCap<T0> | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::kiosk::return_purchase_cap",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function returnVal<T0 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        T0 | TransactionArgument,
        kiosk.Borrow | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));
      _args.push(transactionArgumentOrPure(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::kiosk::return_val",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function setAllowExtensions(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        Boolean | TransactionArgument,
      ],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));
      _args.push(transactionArgumentOrPure(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::kiosk::set_allow_extensions",
        arguments: _args,
      });
    }
    export function setOwner(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::kiosk::set_owner",
        arguments: _args,
      });
    }
    export function setOwnerCustom(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionArgument,
      ],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));
      _args.push(transactionArgumentOrPure(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::kiosk::set_owner_custom",
        arguments: _args,
      });
    }
    export function take<T0 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        object_.ID | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));
      _args.push(transactionArgumentOrPure(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::kiosk::take",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function uid(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::kiosk::uid",
        arguments: _args,
      });
    }
    export function uidMut(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::kiosk::uid_mut",
        arguments: _args,
      });
    }
    export function uidMutAsOwner(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::kiosk::uid_mut_as_owner",
        arguments: _args,
      });
    }
    export function uidMutInternal(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::kiosk::uid_mut_internal",
        arguments: _args,
      });
    }
    export function withdraw(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        _0x1.option.Option<bigint> | TransactionArgument,
      ],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));
      _args.push(transactionArgumentOrPure(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::kiosk::withdraw",
        arguments: _args,
      });
    }
  }
  export namespace view {
    export async function borrow<T0 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        object_.ID | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new TransactionBlock();
      builder.borrow(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function borrowMut<T0 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        object_.ID | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new TransactionBlock();
      builder.borrowMut(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function borrowVal<T0 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        object_.ID | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[T0, kiosk.Borrow]>> {
      const tx = new TransactionBlock();
      builder.borrowVal(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [T0, kiosk.Borrow]
      >(inspectRes);
    }
    export async function closeAndWithdraw(
      client: SuiClient,
      args: [
        kiosk.Kiosk | TransactionArgument,
        kiosk.KioskOwnerCap | TransactionArgument,
      ],
    ): Promise<TypedDevInspectResults<[coin.Coin<sui.SUI>]>> {
      const tx = new TransactionBlock();
      builder.closeAndWithdraw(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [coin.Coin<sui.SUI>]
      >(inspectRes);
    }

    export async function delist<T0 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        object_.ID | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.delist(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function hasAccess(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
    ): Promise<TypedDevInspectResults<[Boolean]>> {
      const tx = new TransactionBlock();
      builder.hasAccess(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[Boolean]>(
        inspectRes,
      );
    }
    export async function hasItem(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        object_.ID | TransactionArgument,
      ],
    ): Promise<TypedDevInspectResults<[Boolean]>> {
      const tx = new TransactionBlock();
      builder.hasItem(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[Boolean]>(
        inspectRes,
      );
    }
    export async function hasItemWithType<T0 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        object_.ID | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[Boolean]>> {
      const tx = new TransactionBlock();
      builder.hasItemWithType(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[Boolean]>(
        inspectRes,
      );
    }
    export async function isListed(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        object_.ID | TransactionArgument,
      ],
    ): Promise<TypedDevInspectResults<[Boolean]>> {
      const tx = new TransactionBlock();
      builder.isListed(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[Boolean]>(
        inspectRes,
      );
    }
    export async function isListedExclusively(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        object_.ID | TransactionArgument,
      ],
    ): Promise<TypedDevInspectResults<[Boolean]>> {
      const tx = new TransactionBlock();
      builder.isListedExclusively(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[Boolean]>(
        inspectRes,
      );
    }
    export async function isLocked(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        object_.ID | TransactionArgument,
      ],
    ): Promise<TypedDevInspectResults<[Boolean]>> {
      const tx = new TransactionBlock();
      builder.isLocked(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[Boolean]>(
        inspectRes,
      );
    }
    export async function itemCount(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): Promise<TypedDevInspectResults<[number]>> {
      const tx = new TransactionBlock();
      builder.itemCount(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[number]>(
        inspectRes,
      );
    }
    export async function kioskOwnerCapFor(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): Promise<TypedDevInspectResults<[object_.ID]>> {
      const tx = new TransactionBlock();
      builder.kioskOwnerCapFor(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[object_.ID]>(
        inspectRes,
      );
    }
    export async function list<T0 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        object_.ID | TransactionArgument,
        bigint | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.list(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function listWithPurchaseCap<T0 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        object_.ID | TransactionArgument,
        bigint | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[kiosk.PurchaseCap<T0>]>> {
      const tx = new TransactionBlock();
      builder.listWithPurchaseCap(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [kiosk.PurchaseCap<T0>]
      >(inspectRes);
    }
    export async function lock<T0 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        T0 | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.lock(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function lockInternal<T0 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        T0 | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.lockInternal(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function new_(
      client: SuiClient,
      args: [],
    ): Promise<TypedDevInspectResults<[kiosk.Kiosk, kiosk.KioskOwnerCap]>> {
      const tx = new TransactionBlock();
      builder.new_(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [kiosk.Kiosk, kiosk.KioskOwnerCap]
      >(inspectRes);
    }
    export async function owner(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new TransactionBlock();
      builder.owner(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function place<T0 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        T0 | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.place(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function placeAndList<T0 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        T0 | TransactionArgument,
        bigint | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.placeAndList(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function placeInternal<T0 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        T0 | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.placeInternal(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function profitsAmount(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new TransactionBlock();
      builder.profitsAmount(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function profitsMut(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new TransactionBlock();
      builder.profitsMut(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function purchase<T0 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        object_.ID | TransactionArgument,
        coin.Coin<sui.SUI> | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<
      TypedDevInspectResults<[T0, transfer_policy.TransferRequest<T0>]>
    > {
      const tx = new TransactionBlock();
      builder.purchase(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [T0, transfer_policy.TransferRequest<T0>]
      >(inspectRes);
    }
    export async function purchaseCapItem<T0 = any>(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[object_.ID]>> {
      const tx = new TransactionBlock();
      builder.purchaseCapItem(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[object_.ID]>(
        inspectRes,
      );
    }
    export async function purchaseCapKiosk<T0 = any>(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[object_.ID]>> {
      const tx = new TransactionBlock();
      builder.purchaseCapKiosk(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[object_.ID]>(
        inspectRes,
      );
    }
    export async function purchaseCapMinPrice<T0 = any>(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new TransactionBlock();
      builder.purchaseCapMinPrice(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function purchaseWithCap<T0 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        kiosk.PurchaseCap<T0> | TransactionArgument,
        coin.Coin<sui.SUI> | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<
      TypedDevInspectResults<[T0, transfer_policy.TransferRequest<T0>]>
    > {
      const tx = new TransactionBlock();
      builder.purchaseWithCap(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [T0, transfer_policy.TransferRequest<T0>]
      >(inspectRes);
    }
    export async function returnPurchaseCap<T0 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        kiosk.PurchaseCap<T0> | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.returnPurchaseCap(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function returnVal<T0 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        T0 | TransactionArgument,
        kiosk.Borrow | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.returnVal(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function setAllowExtensions(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        Boolean | TransactionArgument,
      ],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.setAllowExtensions(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function setOwner(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.setOwner(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function setOwnerCustom(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionArgument,
      ],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.setOwnerCustom(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function take<T0 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        object_.ID | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[T0]>> {
      const tx = new TransactionBlock();
      builder.take(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[T0]>(
        inspectRes,
      );
    }
    export async function uid(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new TransactionBlock();
      builder.uid(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function uidMut(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new TransactionBlock();
      builder.uidMut(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function uidMutAsOwner(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new TransactionBlock();
      builder.uidMutAsOwner(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function uidMutInternal(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new TransactionBlock();
      builder.uidMutInternal(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function withdraw(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        _0x1.option.Option<bigint> | TransactionArgument,
      ],
    ): Promise<TypedDevInspectResults<[coin.Coin<sui.SUI>]>> {
      const tx = new TransactionBlock();
      builder.withdraw(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [coin.Coin<sui.SUI>]
      >(inspectRes);
    }
  }
}

export namespace kiosk_extension {
  export interface Extension {
    storage: bag.Bag;
    permissions: bigint;
    is_enabled: Boolean;
  }

  export namespace Extension {
    export const TYPE_QNAME = "0x2::kiosk_extension::Extension";

    const TYPE = new TypeDescriptor<Extension>(Extension.TYPE_QNAME);

    export function type(): TypeDescriptor<Extension> {
      return TYPE.apply();
    }
  }

  export interface ExtensionKey<T0> {
    dummy_field: Boolean;
  }

  export namespace ExtensionKey {
    export const TYPE_QNAME = "0x2::kiosk_extension::ExtensionKey";

    const TYPE = new TypeDescriptor<ExtensionKey<any>>(ExtensionKey.TYPE_QNAME);

    export function type<T0>(
      arg0: TypeDescriptor<T0> = ANY_TYPE,
    ): TypeDescriptor<ExtensionKey<T0>> {
      return TYPE.apply(arg0);
    }
  }

  export interface ExtensionKeyInstance
    extends TypedEventInstance<ExtensionKey<any>> {
    data_decoded: ExtensionKey<any>;
    type_arguments: [string];
  }

  export namespace builder {
    export function add<T0 = any>(
      tx: TransactionBlock,
      args: [
        T0 | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument &
      [
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
      ] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));
      _args.push(transactionArgumentOrObject(args[2], tx));
      _args.push(transactionArgumentOrPure(args[3], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::kiosk_extension::add",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function canLock<T0 = any>(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::kiosk_extension::can_lock",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function canPlace<T0 = any>(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::kiosk_extension::can_place",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function disable<T0 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::kiosk_extension::disable",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function enable<T0 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::kiosk_extension::enable",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function isEnabled<T0 = any>(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::kiosk_extension::is_enabled",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function isInstalled<T0 = any>(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::kiosk_extension::is_installed",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function lock<T0 = any, T1 = any>(
      tx: TransactionBlock,
      args: [
        T0 | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        T1 | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument &
      [
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
      ] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));
      _args.push(transactionArgumentOrPure(args[2], tx));
      _args.push(transactionArgumentOrObject(args[3], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::kiosk_extension::lock",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function place<T0 = any, T1 = any>(
      tx: TransactionBlock,
      args: [
        T0 | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        T1 | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument &
      [
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
      ] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));
      _args.push(transactionArgumentOrPure(args[2], tx));
      _args.push(transactionArgumentOrObject(args[3], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::kiosk_extension::place",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function remove<T0 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::kiosk_extension::remove",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function storage<T0 = any>(
      tx: TransactionBlock,
      args: [
        T0 | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::kiosk_extension::storage",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function storageMut<T0 = any>(
      tx: TransactionBlock,
      args: [
        T0 | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::kiosk_extension::storage_mut",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
  }
  export namespace view {
    export async function add<T0 = any>(
      client: SuiClient,
      args: [
        T0 | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.add(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function canLock<T0 = any>(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[Boolean]>> {
      const tx = new TransactionBlock();
      builder.canLock(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[Boolean]>(
        inspectRes,
      );
    }
    export async function canPlace<T0 = any>(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[Boolean]>> {
      const tx = new TransactionBlock();
      builder.canPlace(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[Boolean]>(
        inspectRes,
      );
    }
    export async function disable<T0 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.disable(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function enable<T0 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.enable(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function isEnabled<T0 = any>(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[Boolean]>> {
      const tx = new TransactionBlock();
      builder.isEnabled(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[Boolean]>(
        inspectRes,
      );
    }
    export async function isInstalled<T0 = any>(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[Boolean]>> {
      const tx = new TransactionBlock();
      builder.isInstalled(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[Boolean]>(
        inspectRes,
      );
    }
    export async function lock<T0 = any, T1 = any>(
      client: SuiClient,
      args: [
        T0 | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        T1 | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.lock(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function place<T0 = any, T1 = any>(
      client: SuiClient,
      args: [
        T0 | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        T1 | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.place(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function remove<T0 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.remove(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function storage<T0 = any>(
      client: SuiClient,
      args: [
        T0 | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new TransactionBlock();
      builder.storage(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function storageMut<T0 = any>(
      client: SuiClient,
      args: [
        T0 | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new TransactionBlock();
      builder.storageMut(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
  }
}

export namespace linked_table {
  export interface LinkedTable<T0, T1> {
    id: object_.UID;
    size: bigint;
    head: _0x1.option.Option<T0>;
    tail: _0x1.option.Option<T0>;
  }

  export namespace LinkedTable {
    export const TYPE_QNAME = "0x2::linked_table::LinkedTable";

    const TYPE = new TypeDescriptor<LinkedTable<any, any>>(
      LinkedTable.TYPE_QNAME,
    );

    export function type<T0, T1>(
      arg0: TypeDescriptor<T0> = ANY_TYPE,
      arg1: TypeDescriptor<T1> = ANY_TYPE,
    ): TypeDescriptor<LinkedTable<T0, T1>> {
      return TYPE.apply(arg0, arg1);
    }
  }

  export interface Node<T0, T1> {
    prev: _0x1.option.Option<T0>;
    next: _0x1.option.Option<T0>;
    value: T1;
  }

  export namespace Node {
    export const TYPE_QNAME = "0x2::linked_table::Node";

    const TYPE = new TypeDescriptor<Node<any, any>>(Node.TYPE_QNAME);

    export function type<T0, T1>(
      arg0: TypeDescriptor<T0> = ANY_TYPE,
      arg1: TypeDescriptor<T1> = ANY_TYPE,
    ): TypeDescriptor<Node<T0, T1>> {
      return TYPE.apply(arg0, arg1);
    }
  }

  export namespace builder {
    export function back<T0 = any, T1 = any>(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::linked_table::back",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function borrow<T0 = any, T1 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        T0 | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::linked_table::borrow",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function borrowMut<T0 = any, T1 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        T0 | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::linked_table::borrow_mut",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function contains<T0 = any, T1 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        T0 | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::linked_table::contains",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function destroyEmpty<T0 = any, T1 = any>(
      tx: TransactionBlock,
      args: [linked_table.LinkedTable<T0, T1> | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::linked_table::destroy_empty",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function drop<T0 = any, T1 = any>(
      tx: TransactionBlock,
      args: [linked_table.LinkedTable<T0, T1> | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::linked_table::drop",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function front<T0 = any, T1 = any>(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::linked_table::front",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function isEmpty<T0 = any, T1 = any>(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::linked_table::is_empty",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function length<T0 = any, T1 = any>(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::linked_table::length",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function new_<T0 = any, T1 = any>(
      tx: TransactionBlock,
      args: [],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [] {
      const _args: any[] = [];

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::linked_table::new",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function next<T0 = any, T1 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        T0 | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::linked_table::next",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function popBack<T0 = any, T1 = any>(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::linked_table::pop_back",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function popFront<T0 = any, T1 = any>(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::linked_table::pop_front",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function prev<T0 = any, T1 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        T0 | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::linked_table::prev",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function pushBack<T0 = any, T1 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        T0 | TransactionArgument,
        T1 | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));
      _args.push(transactionArgumentOrPure(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::linked_table::push_back",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function pushFront<T0 = any, T1 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        T0 | TransactionArgument,
        T1 | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));
      _args.push(transactionArgumentOrPure(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::linked_table::push_front",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function remove<T0 = any, T1 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        T0 | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::linked_table::remove",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
  }
  export namespace view {
    export async function back<T0 = any, T1 = any>(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new TransactionBlock();
      builder.back(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function borrow<T0 = any, T1 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        T0 | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new TransactionBlock();
      builder.borrow(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function borrowMut<T0 = any, T1 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        T0 | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new TransactionBlock();
      builder.borrowMut(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function contains<T0 = any, T1 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        T0 | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[Boolean]>> {
      const tx = new TransactionBlock();
      builder.contains(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[Boolean]>(
        inspectRes,
      );
    }
    export async function destroyEmpty<T0 = any, T1 = any>(
      client: SuiClient,
      args: [linked_table.LinkedTable<T0, T1> | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.destroyEmpty(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function drop<T0 = any, T1 = any>(
      client: SuiClient,
      args: [linked_table.LinkedTable<T0, T1> | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.drop(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function front<T0 = any, T1 = any>(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new TransactionBlock();
      builder.front(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function isEmpty<T0 = any, T1 = any>(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[Boolean]>> {
      const tx = new TransactionBlock();
      builder.isEmpty(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[Boolean]>(
        inspectRes,
      );
    }
    export async function length<T0 = any, T1 = any>(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new TransactionBlock();
      builder.length(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function new_<T0 = any, T1 = any>(
      client: SuiClient,
      args: [],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[linked_table.LinkedTable<T0, T1>]>> {
      const tx = new TransactionBlock();
      builder.new_(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [linked_table.LinkedTable<T0, T1>]
      >(inspectRes);
    }
    export async function next<T0 = any, T1 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        T0 | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new TransactionBlock();
      builder.next(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function popBack<T0 = any, T1 = any>(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[T0, T1]>> {
      const tx = new TransactionBlock();
      builder.popBack(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[T0, T1]>(
        inspectRes,
      );
    }
    export async function popFront<T0 = any, T1 = any>(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[T0, T1]>> {
      const tx = new TransactionBlock();
      builder.popFront(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[T0, T1]>(
        inspectRes,
      );
    }
    export async function prev<T0 = any, T1 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        T0 | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new TransactionBlock();
      builder.prev(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function pushBack<T0 = any, T1 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        T0 | TransactionArgument,
        T1 | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.pushBack(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function pushFront<T0 = any, T1 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        T0 | TransactionArgument,
        T1 | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.pushFront(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function remove<T0 = any, T1 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        T0 | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[T1]>> {
      const tx = new TransactionBlock();
      builder.remove(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[T1]>(
        inspectRes,
      );
    }
  }
}

export namespace math {
  export namespace builder {
    export function diff(
      tx: TransactionBlock,
      args: [bigint | TransactionArgument, bigint | TransactionArgument],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::math::diff",
        arguments: _args,
      });
    }
    export function divideAndRoundUp(
      tx: TransactionBlock,
      args: [bigint | TransactionArgument, bigint | TransactionArgument],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::math::divide_and_round_up",
        arguments: _args,
      });
    }
    export function max(
      tx: TransactionBlock,
      args: [bigint | TransactionArgument, bigint | TransactionArgument],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::math::max",
        arguments: _args,
      });
    }
    export function min(
      tx: TransactionBlock,
      args: [bigint | TransactionArgument, bigint | TransactionArgument],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::math::min",
        arguments: _args,
      });
    }
    export function pow(
      tx: TransactionBlock,
      args: [bigint | TransactionArgument, number | TransactionArgument],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::math::pow",
        arguments: _args,
      });
    }
    export function sqrt(
      tx: TransactionBlock,
      args: [bigint | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::math::sqrt",
        arguments: _args,
      });
    }
    export function sqrtU128(
      tx: TransactionBlock,
      args: [bigint | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::math::sqrt_u128",
        arguments: _args,
      });
    }
  }
  export namespace view {
    export async function diff(
      client: SuiClient,
      args: [bigint | TransactionArgument, bigint | TransactionArgument],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new TransactionBlock();
      builder.diff(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function divideAndRoundUp(
      client: SuiClient,
      args: [bigint | TransactionArgument, bigint | TransactionArgument],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new TransactionBlock();
      builder.divideAndRoundUp(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function max(
      client: SuiClient,
      args: [bigint | TransactionArgument, bigint | TransactionArgument],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new TransactionBlock();
      builder.max(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function min(
      client: SuiClient,
      args: [bigint | TransactionArgument, bigint | TransactionArgument],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new TransactionBlock();
      builder.min(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function pow(
      client: SuiClient,
      args: [bigint | TransactionArgument, number | TransactionArgument],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new TransactionBlock();
      builder.pow(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function sqrt(
      client: SuiClient,
      args: [bigint | TransactionArgument],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new TransactionBlock();
      builder.sqrt(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function sqrtU128(
      client: SuiClient,
      args: [bigint | TransactionArgument],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new TransactionBlock();
      builder.sqrtU128(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
  }
}

export namespace object_ {
  export type ID = string;
  export namespace ID {
    export const TYPE_QNAME = "0x2::object::ID";

    const TYPE = new TypeDescriptor<ID>(ID.TYPE_QNAME);

    export function type(): TypeDescriptor<ID> {
      return TYPE.apply();
    }
  }

  export interface UID {
    id: object_.ID;
  }

  export namespace UID {
    export const TYPE_QNAME = "0x2::object::UID";

    const TYPE = new TypeDescriptor<UID>(UID.TYPE_QNAME);

    export function type(): TypeDescriptor<UID> {
      return TYPE.apply();
    }
  }

  export namespace builder {
    export function authenticatorState(
      tx: TransactionBlock,
      args: [],
    ): TransactionArgument & [] {
      const _args: any[] = [];

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::object::authenticator_state",
        arguments: _args,
      });
    }
    export function borrowId<T0 = any>(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::object::borrow_id",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function clock(
      tx: TransactionBlock,
      args: [],
    ): TransactionArgument & [] {
      const _args: any[] = [];

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::object::clock",
        arguments: _args,
      });
    }
    export function delete_(
      tx: TransactionBlock,
      args: [object_.UID | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::object::delete",
        arguments: _args,
      });
    }
    export function id<T0 = any>(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::object::id",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function idAddress<T0 = any>(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::object::id_address",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function idBytes<T0 = any>(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::object::id_bytes",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function idFromAddress(
      tx: TransactionBlock,
      args: [string | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::object::id_from_address",
        arguments: _args,
      });
    }
    export function idFromBytes(
      tx: TransactionBlock,
      args: [(string | TransactionObjectArgument)[] | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrVec(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::object::id_from_bytes",
        arguments: _args,
      });
    }
    export function idToAddress(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::object::id_to_address",
        arguments: _args,
      });
    }
    export function idToBytes(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::object::id_to_bytes",
        arguments: _args,
      });
    }
    export function new_(
      tx: TransactionBlock,
      args: [],
    ): TransactionArgument & [] {
      const _args: any[] = [];

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::object::new",
        arguments: _args,
      });
    }
    export function newUidFromHash(
      tx: TransactionBlock,
      args: [string | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::object::new_uid_from_hash",
        arguments: _args,
      });
    }
    export function randomnessState(
      tx: TransactionBlock,
      args: [],
    ): TransactionArgument & [] {
      const _args: any[] = [];

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::object::randomness_state",
        arguments: _args,
      });
    }
    export function suiDenyListObjectId(
      tx: TransactionBlock,
      args: [],
    ): TransactionArgument & [] {
      const _args: any[] = [];

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::object::sui_deny_list_object_id",
        arguments: _args,
      });
    }
    export function uidAsInner(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::object::uid_as_inner",
        arguments: _args,
      });
    }
    export function uidToAddress(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::object::uid_to_address",
        arguments: _args,
      });
    }
    export function uidToBytes(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::object::uid_to_bytes",
        arguments: _args,
      });
    }
    export function uidToInner(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::object::uid_to_inner",
        arguments: _args,
      });
    }
  }
  export namespace view {
    export async function authenticatorState(
      client: SuiClient,
      args: [],
    ): Promise<TypedDevInspectResults<[object_.UID]>> {
      const tx = new TransactionBlock();
      builder.authenticatorState(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[object_.UID]>(
        inspectRes,
      );
    }
    export async function borrowId<T0 = any>(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new TransactionBlock();
      builder.borrowId(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function clock(
      client: SuiClient,
      args: [],
    ): Promise<TypedDevInspectResults<[object_.UID]>> {
      const tx = new TransactionBlock();
      builder.clock(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[object_.UID]>(
        inspectRes,
      );
    }
    export async function delete_(
      client: SuiClient,
      args: [object_.UID | TransactionArgument],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.delete_(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function id<T0 = any>(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[object_.ID]>> {
      const tx = new TransactionBlock();
      builder.id(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[object_.ID]>(
        inspectRes,
      );
    }
    export async function idAddress<T0 = any>(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new TransactionBlock();
      builder.idAddress(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function idBytes<T0 = any>(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[number[]]>> {
      const tx = new TransactionBlock();
      builder.idBytes(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[number[]]>(
        inspectRes,
      );
    }
    export async function idFromAddress(
      client: SuiClient,
      args: [string | TransactionArgument],
    ): Promise<TypedDevInspectResults<[object_.ID]>> {
      const tx = new TransactionBlock();
      builder.idFromAddress(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[object_.ID]>(
        inspectRes,
      );
    }
    export async function idFromBytes(
      client: SuiClient,
      args: [(string | TransactionObjectArgument)[] | TransactionArgument],
    ): Promise<TypedDevInspectResults<[object_.ID]>> {
      const tx = new TransactionBlock();
      builder.idFromBytes(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[object_.ID]>(
        inspectRes,
      );
    }
    export async function idToAddress(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new TransactionBlock();
      builder.idToAddress(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function idToBytes(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): Promise<TypedDevInspectResults<[number[]]>> {
      const tx = new TransactionBlock();
      builder.idToBytes(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[number[]]>(
        inspectRes,
      );
    }
    export async function new_(
      client: SuiClient,
      args: [],
    ): Promise<TypedDevInspectResults<[object_.UID]>> {
      const tx = new TransactionBlock();
      builder.new_(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[object_.UID]>(
        inspectRes,
      );
    }
    export async function newUidFromHash(
      client: SuiClient,
      args: [string | TransactionArgument],
    ): Promise<TypedDevInspectResults<[object_.UID]>> {
      const tx = new TransactionBlock();
      builder.newUidFromHash(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[object_.UID]>(
        inspectRes,
      );
    }
    export async function randomnessState(
      client: SuiClient,
      args: [],
    ): Promise<TypedDevInspectResults<[object_.UID]>> {
      const tx = new TransactionBlock();
      builder.randomnessState(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[object_.UID]>(
        inspectRes,
      );
    }
    export async function suiDenyListObjectId(
      client: SuiClient,
      args: [],
    ): Promise<TypedDevInspectResults<[object_.UID]>> {
      const tx = new TransactionBlock();
      builder.suiDenyListObjectId(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[object_.UID]>(
        inspectRes,
      );
    }
    export async function uidAsInner(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new TransactionBlock();
      builder.uidAsInner(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function uidToAddress(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new TransactionBlock();
      builder.uidToAddress(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function uidToBytes(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): Promise<TypedDevInspectResults<[number[]]>> {
      const tx = new TransactionBlock();
      builder.uidToBytes(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[number[]]>(
        inspectRes,
      );
    }
    export async function uidToInner(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): Promise<TypedDevInspectResults<[object_.ID]>> {
      const tx = new TransactionBlock();
      builder.uidToInner(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[object_.ID]>(
        inspectRes,
      );
    }
  }
}

export namespace object_bag {
  export interface ObjectBag {
    id: object_.UID;
    size: bigint;
  }

  export namespace ObjectBag {
    export const TYPE_QNAME = "0x2::object_bag::ObjectBag";

    const TYPE = new TypeDescriptor<ObjectBag>(ObjectBag.TYPE_QNAME);

    export function type(): TypeDescriptor<ObjectBag> {
      return TYPE.apply();
    }
  }

  export namespace builder {
    export function add<T0 = any, T1 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        T0 | TransactionArgument,
        T1 | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));
      _args.push(transactionArgumentOrPure(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::object_bag::add",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function borrow<T0 = any, T1 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        T0 | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::object_bag::borrow",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function borrowMut<T0 = any, T1 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        T0 | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::object_bag::borrow_mut",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function contains<T0 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        T0 | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::object_bag::contains",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function containsWithType<T0 = any, T1 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        T0 | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::object_bag::contains_with_type",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function destroyEmpty(
      tx: TransactionBlock,
      args: [object_bag.ObjectBag | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::object_bag::destroy_empty",
        arguments: _args,
      });
    }
    export function isEmpty(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::object_bag::is_empty",
        arguments: _args,
      });
    }
    export function length(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::object_bag::length",
        arguments: _args,
      });
    }
    export function new_(
      tx: TransactionBlock,
      args: [],
    ): TransactionArgument & [] {
      const _args: any[] = [];

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::object_bag::new",
        arguments: _args,
      });
    }
    export function remove<T0 = any, T1 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        T0 | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::object_bag::remove",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function valueId<T0 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        T0 | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::object_bag::value_id",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
  }
  export namespace view {
    export async function add<T0 = any, T1 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        T0 | TransactionArgument,
        T1 | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.add(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function borrow<T0 = any, T1 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        T0 | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new TransactionBlock();
      builder.borrow(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function borrowMut<T0 = any, T1 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        T0 | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new TransactionBlock();
      builder.borrowMut(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function contains<T0 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        T0 | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[Boolean]>> {
      const tx = new TransactionBlock();
      builder.contains(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[Boolean]>(
        inspectRes,
      );
    }
    export async function containsWithType<T0 = any, T1 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        T0 | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[Boolean]>> {
      const tx = new TransactionBlock();
      builder.containsWithType(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[Boolean]>(
        inspectRes,
      );
    }
    export async function destroyEmpty(
      client: SuiClient,
      args: [object_bag.ObjectBag | TransactionArgument],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.destroyEmpty(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function isEmpty(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): Promise<TypedDevInspectResults<[Boolean]>> {
      const tx = new TransactionBlock();
      builder.isEmpty(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[Boolean]>(
        inspectRes,
      );
    }
    export async function length(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new TransactionBlock();
      builder.length(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function new_(
      client: SuiClient,
      args: [],
    ): Promise<TypedDevInspectResults<[object_bag.ObjectBag]>> {
      const tx = new TransactionBlock();
      builder.new_(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [object_bag.ObjectBag]
      >(inspectRes);
    }
    export async function remove<T0 = any, T1 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        T0 | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[T1]>> {
      const tx = new TransactionBlock();
      builder.remove(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[T1]>(
        inspectRes,
      );
    }
    export async function valueId<T0 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        T0 | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[_0x1.option.Option<object_.ID>]>> {
      const tx = new TransactionBlock();
      builder.valueId(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [_0x1.option.Option<object_.ID>]
      >(inspectRes);
    }
  }
}

export namespace object_table {
  export interface ObjectTable<T0, T1> {
    id: object_.UID;
    size: bigint;
  }

  export namespace ObjectTable {
    export const TYPE_QNAME = "0x2::object_table::ObjectTable";

    const TYPE = new TypeDescriptor<ObjectTable<any, any>>(
      ObjectTable.TYPE_QNAME,
    );

    export function type<T0, T1>(
      arg0: TypeDescriptor<T0> = ANY_TYPE,
      arg1: TypeDescriptor<T1> = ANY_TYPE,
    ): TypeDescriptor<ObjectTable<T0, T1>> {
      return TYPE.apply(arg0, arg1);
    }
  }

  export namespace builder {
    export function add<T0 = any, T1 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        T0 | TransactionArgument,
        T1 | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));
      _args.push(transactionArgumentOrPure(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::object_table::add",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function borrow<T0 = any, T1 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        T0 | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::object_table::borrow",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function borrowMut<T0 = any, T1 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        T0 | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::object_table::borrow_mut",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function contains<T0 = any, T1 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        T0 | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::object_table::contains",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function destroyEmpty<T0 = any, T1 = any>(
      tx: TransactionBlock,
      args: [object_table.ObjectTable<T0, T1> | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::object_table::destroy_empty",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function isEmpty<T0 = any, T1 = any>(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::object_table::is_empty",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function length<T0 = any, T1 = any>(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::object_table::length",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function new_<T0 = any, T1 = any>(
      tx: TransactionBlock,
      args: [],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [] {
      const _args: any[] = [];

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::object_table::new",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function remove<T0 = any, T1 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        T0 | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::object_table::remove",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function valueId<T0 = any, T1 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        T0 | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::object_table::value_id",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
  }
  export namespace view {
    export async function add<T0 = any, T1 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        T0 | TransactionArgument,
        T1 | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.add(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function borrow<T0 = any, T1 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        T0 | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new TransactionBlock();
      builder.borrow(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function borrowMut<T0 = any, T1 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        T0 | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new TransactionBlock();
      builder.borrowMut(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function contains<T0 = any, T1 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        T0 | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[Boolean]>> {
      const tx = new TransactionBlock();
      builder.contains(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[Boolean]>(
        inspectRes,
      );
    }
    export async function destroyEmpty<T0 = any, T1 = any>(
      client: SuiClient,
      args: [object_table.ObjectTable<T0, T1> | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.destroyEmpty(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function isEmpty<T0 = any, T1 = any>(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[Boolean]>> {
      const tx = new TransactionBlock();
      builder.isEmpty(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[Boolean]>(
        inspectRes,
      );
    }
    export async function length<T0 = any, T1 = any>(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new TransactionBlock();
      builder.length(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function new_<T0 = any, T1 = any>(
      client: SuiClient,
      args: [],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[object_table.ObjectTable<T0, T1>]>> {
      const tx = new TransactionBlock();
      builder.new_(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [object_table.ObjectTable<T0, T1>]
      >(inspectRes);
    }
    export async function remove<T0 = any, T1 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        T0 | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[T1]>> {
      const tx = new TransactionBlock();
      builder.remove(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[T1]>(
        inspectRes,
      );
    }
    export async function valueId<T0 = any, T1 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        T0 | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[_0x1.option.Option<object_.ID>]>> {
      const tx = new TransactionBlock();
      builder.valueId(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [_0x1.option.Option<object_.ID>]
      >(inspectRes);
    }
  }
}

export namespace package_ {
  export interface Publisher {
    id: object_.UID;
    package: _0x1.ascii.String;
    module_name: _0x1.ascii.String;
  }

  export namespace Publisher {
    export const TYPE_QNAME = "0x2::package::Publisher";

    const TYPE = new TypeDescriptor<Publisher>(Publisher.TYPE_QNAME);

    export function type(): TypeDescriptor<Publisher> {
      return TYPE.apply();
    }
  }

  export interface UpgradeCap {
    id: object_.UID;
    package: object_.ID;
    version: bigint;
    policy: number;
  }

  export namespace UpgradeCap {
    export const TYPE_QNAME = "0x2::package::UpgradeCap";

    const TYPE = new TypeDescriptor<UpgradeCap>(UpgradeCap.TYPE_QNAME);

    export function type(): TypeDescriptor<UpgradeCap> {
      return TYPE.apply();
    }
  }

  export interface UpgradeReceipt {
    cap: object_.ID;
    package: object_.ID;
  }

  export namespace UpgradeReceipt {
    export const TYPE_QNAME = "0x2::package::UpgradeReceipt";

    const TYPE = new TypeDescriptor<UpgradeReceipt>(UpgradeReceipt.TYPE_QNAME);

    export function type(): TypeDescriptor<UpgradeReceipt> {
      return TYPE.apply();
    }
  }

  export interface UpgradeTicket {
    cap: object_.ID;
    package: object_.ID;
    policy: number;
    digest: number[];
  }

  export namespace UpgradeTicket {
    export const TYPE_QNAME = "0x2::package::UpgradeTicket";

    const TYPE = new TypeDescriptor<UpgradeTicket>(UpgradeTicket.TYPE_QNAME);

    export function type(): TypeDescriptor<UpgradeTicket> {
      return TYPE.apply();
    }
  }

  export namespace builder {
    export function additivePolicy(
      tx: TransactionBlock,
      args: [],
    ): TransactionArgument & [] {
      const _args: any[] = [];

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::package::additive_policy",
        arguments: _args,
      });
    }
    export function authorizeUpgrade(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        number | TransactionArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
      ],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));
      _args.push(transactionArgumentOrVec(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::package::authorize_upgrade",
        arguments: _args,
      });
    }
    export function burnPublisher(
      tx: TransactionBlock,
      args: [package_.Publisher | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::package::burn_publisher",
        arguments: _args,
      });
    }
    export function claim<T0 = any>(
      tx: TransactionBlock,
      args: [T0 | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::package::claim",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function claimAndKeep<T0 = any>(
      tx: TransactionBlock,
      args: [T0 | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::package::claim_and_keep",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function commitUpgrade(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        package_.UpgradeReceipt | TransactionArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::package::commit_upgrade",
        arguments: _args,
      });
    }
    export function compatiblePolicy(
      tx: TransactionBlock,
      args: [],
    ): TransactionArgument & [] {
      const _args: any[] = [];

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::package::compatible_policy",
        arguments: _args,
      });
    }
    export function depOnlyPolicy(
      tx: TransactionBlock,
      args: [],
    ): TransactionArgument & [] {
      const _args: any[] = [];

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::package::dep_only_policy",
        arguments: _args,
      });
    }
    export function fromModule<T0 = any>(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::package::from_module",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function fromPackage<T0 = any>(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::package::from_package",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function makeImmutable(
      tx: TransactionBlock,
      args: [package_.UpgradeCap | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::package::make_immutable",
        arguments: _args,
      });
    }
    export function onlyAdditiveUpgrades(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::package::only_additive_upgrades",
        arguments: _args,
      });
    }
    export function onlyDepUpgrades(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::package::only_dep_upgrades",
        arguments: _args,
      });
    }
    export function publishedModule(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::package::published_module",
        arguments: _args,
      });
    }
    export function publishedPackage(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::package::published_package",
        arguments: _args,
      });
    }
    export function receiptCap(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::package::receipt_cap",
        arguments: _args,
      });
    }
    export function receiptPackage(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::package::receipt_package",
        arguments: _args,
      });
    }
    export function ticketDigest(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::package::ticket_digest",
        arguments: _args,
      });
    }
    export function ticketPackage(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::package::ticket_package",
        arguments: _args,
      });
    }
    export function ticketPolicy(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::package::ticket_policy",
        arguments: _args,
      });
    }
    export function upgradePackage(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::package::upgrade_package",
        arguments: _args,
      });
    }
    export function upgradePolicy(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::package::upgrade_policy",
        arguments: _args,
      });
    }
    export function version(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::package::version",
        arguments: _args,
      });
    }
  }
  export namespace view {
    export async function additivePolicy(
      client: SuiClient,
      args: [],
    ): Promise<TypedDevInspectResults<[number]>> {
      const tx = new TransactionBlock();
      builder.additivePolicy(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[number]>(
        inspectRes,
      );
    }
    export async function authorizeUpgrade(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        number | TransactionArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
      ],
    ): Promise<TypedDevInspectResults<[package_.UpgradeTicket]>> {
      const tx = new TransactionBlock();
      builder.authorizeUpgrade(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [package_.UpgradeTicket]
      >(inspectRes);
    }
    export async function burnPublisher(
      client: SuiClient,
      args: [package_.Publisher | TransactionArgument],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.burnPublisher(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function claim<T0 = any>(
      client: SuiClient,
      args: [T0 | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[package_.Publisher]>> {
      const tx = new TransactionBlock();
      builder.claim(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [package_.Publisher]
      >(inspectRes);
    }
    export async function claimAndKeep<T0 = any>(
      client: SuiClient,
      args: [T0 | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.claimAndKeep(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function commitUpgrade(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        package_.UpgradeReceipt | TransactionArgument,
      ],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.commitUpgrade(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function compatiblePolicy(
      client: SuiClient,
      args: [],
    ): Promise<TypedDevInspectResults<[number]>> {
      const tx = new TransactionBlock();
      builder.compatiblePolicy(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[number]>(
        inspectRes,
      );
    }
    export async function depOnlyPolicy(
      client: SuiClient,
      args: [],
    ): Promise<TypedDevInspectResults<[number]>> {
      const tx = new TransactionBlock();
      builder.depOnlyPolicy(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[number]>(
        inspectRes,
      );
    }
    export async function fromModule<T0 = any>(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[Boolean]>> {
      const tx = new TransactionBlock();
      builder.fromModule(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[Boolean]>(
        inspectRes,
      );
    }
    export async function fromPackage<T0 = any>(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[Boolean]>> {
      const tx = new TransactionBlock();
      builder.fromPackage(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[Boolean]>(
        inspectRes,
      );
    }
    export async function makeImmutable(
      client: SuiClient,
      args: [package_.UpgradeCap | TransactionArgument],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.makeImmutable(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function onlyAdditiveUpgrades(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.onlyAdditiveUpgrades(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function onlyDepUpgrades(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.onlyDepUpgrades(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function publishedModule(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new TransactionBlock();
      builder.publishedModule(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function publishedPackage(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new TransactionBlock();
      builder.publishedPackage(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function receiptCap(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): Promise<TypedDevInspectResults<[object_.ID]>> {
      const tx = new TransactionBlock();
      builder.receiptCap(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[object_.ID]>(
        inspectRes,
      );
    }
    export async function receiptPackage(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): Promise<TypedDevInspectResults<[object_.ID]>> {
      const tx = new TransactionBlock();
      builder.receiptPackage(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[object_.ID]>(
        inspectRes,
      );
    }
    export async function ticketDigest(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new TransactionBlock();
      builder.ticketDigest(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function ticketPackage(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): Promise<TypedDevInspectResults<[object_.ID]>> {
      const tx = new TransactionBlock();
      builder.ticketPackage(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[object_.ID]>(
        inspectRes,
      );
    }
    export async function ticketPolicy(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): Promise<TypedDevInspectResults<[number]>> {
      const tx = new TransactionBlock();
      builder.ticketPolicy(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[number]>(
        inspectRes,
      );
    }
    export async function upgradePackage(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): Promise<TypedDevInspectResults<[object_.ID]>> {
      const tx = new TransactionBlock();
      builder.upgradePackage(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[object_.ID]>(
        inspectRes,
      );
    }
    export async function upgradePolicy(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): Promise<TypedDevInspectResults<[number]>> {
      const tx = new TransactionBlock();
      builder.upgradePolicy(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[number]>(
        inspectRes,
      );
    }
    export async function version(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new TransactionBlock();
      builder.version(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
  }
}

export namespace pay {
  export namespace builder {
    export function divideAndKeep<T0 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::pay::divide_and_keep",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function join<T0 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        coin.Coin<T0> | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::pay::join",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function joinVec<T0 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrVec(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::pay::join_vec",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function joinVecAndTransfer<T0 = any>(
      tx: TransactionBlock,
      args: [
        (string | TransactionObjectArgument)[] | TransactionArgument,
        string | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrVec(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::pay::join_vec_and_transfer",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function keep<T0 = any>(
      tx: TransactionBlock,
      args: [coin.Coin<T0> | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::pay::keep",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function split<T0 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::pay::split",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function splitAndTransfer<T0 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
        string | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));
      _args.push(transactionArgumentOrPure(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::pay::split_and_transfer",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function splitVec<T0 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrVec(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::pay::split_vec",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
  }
  export namespace view {
    export async function divideAndKeep<T0 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.divideAndKeep(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function join<T0 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        coin.Coin<T0> | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.join(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function joinVec<T0 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.joinVec(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function joinVecAndTransfer<T0 = any>(
      client: SuiClient,
      args: [
        (string | TransactionObjectArgument)[] | TransactionArgument,
        string | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.joinVecAndTransfer(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function keep<T0 = any>(
      client: SuiClient,
      args: [coin.Coin<T0> | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.keep(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function split<T0 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.split(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function splitAndTransfer<T0 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
        string | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.splitAndTransfer(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function splitVec<T0 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.splitVec(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
  }
}

export namespace poseidon {
  export namespace builder {
    export function poseidonBn254(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::poseidon::poseidon_bn254",
        arguments: _args,
      });
    }
  }
  export namespace view {
    export async function poseidonBn254(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new TransactionBlock();
      builder.poseidonBn254(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
  }
}

export namespace priority_queue {
  export interface Entry<T0> {
    priority: bigint;
    value: T0;
  }

  export namespace Entry {
    export const TYPE_QNAME = "0x2::priority_queue::Entry";

    const TYPE = new TypeDescriptor<Entry<any>>(Entry.TYPE_QNAME);

    export function type<T0>(
      arg0: TypeDescriptor<T0> = ANY_TYPE,
    ): TypeDescriptor<Entry<T0>> {
      return TYPE.apply(arg0);
    }
  }

  export interface PriorityQueue<T0> {
    entries: priority_queue.Entry<T0>[];
  }

  export namespace PriorityQueue {
    export const TYPE_QNAME = "0x2::priority_queue::PriorityQueue";

    const TYPE = new TypeDescriptor<PriorityQueue<any>>(
      PriorityQueue.TYPE_QNAME,
    );

    export function type<T0>(
      arg0: TypeDescriptor<T0> = ANY_TYPE,
    ): TypeDescriptor<PriorityQueue<T0>> {
      return TYPE.apply(arg0);
    }
  }

  export namespace builder {
    export function createEntries<T0 = any>(
      tx: TransactionBlock,
      args: [
        (string | TransactionObjectArgument)[] | TransactionArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrVec(args[0], tx));
      _args.push(transactionArgumentOrVec(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::priority_queue::create_entries",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function insert<T0 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
        T0 | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));
      _args.push(transactionArgumentOrPure(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::priority_queue::insert",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function new_<T0 = any>(
      tx: TransactionBlock,
      args: [(string | TransactionObjectArgument)[] | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrVec(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::priority_queue::new",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function newEntry<T0 = any>(
      tx: TransactionBlock,
      args: [bigint | TransactionArgument, T0 | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::priority_queue::new_entry",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function popMax<T0 = any>(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::priority_queue::pop_max",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function priorities<T0 = any>(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::priority_queue::priorities",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
  }
  export namespace view {
    export async function createEntries<T0 = any>(
      client: SuiClient,
      args: [
        (string | TransactionObjectArgument)[] | TransactionArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[priority_queue.Entry<T0>[]]>> {
      const tx = new TransactionBlock();
      builder.createEntries(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [priority_queue.Entry<T0>[]]
      >(inspectRes);
    }
    export async function insert<T0 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
        T0 | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.insert(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function new_<T0 = any>(
      client: SuiClient,
      args: [(string | TransactionObjectArgument)[] | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[priority_queue.PriorityQueue<T0>]>> {
      const tx = new TransactionBlock();
      builder.new_(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [priority_queue.PriorityQueue<T0>]
      >(inspectRes);
    }
    export async function newEntry<T0 = any>(
      client: SuiClient,
      args: [bigint | TransactionArgument, T0 | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[priority_queue.Entry<T0>]>> {
      const tx = new TransactionBlock();
      builder.newEntry(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [priority_queue.Entry<T0>]
      >(inspectRes);
    }
    export async function popMax<T0 = any>(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[bigint, T0]>> {
      const tx = new TransactionBlock();
      builder.popMax(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint, T0]>(
        inspectRes,
      );
    }
    export async function priorities<T0 = any>(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[bigint[]]>> {
      const tx = new TransactionBlock();
      builder.priorities(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint[]]>(
        inspectRes,
      );
    }
  }
}

export namespace prover {
  export namespace builder {}
  export namespace view {}
}

export namespace random {
  export interface Random {
    id: object_.UID;
    inner: versioned.Versioned;
  }

  export namespace Random {
    export const TYPE_QNAME = "0x2::random::Random";

    const TYPE = new TypeDescriptor<Random>(Random.TYPE_QNAME);

    export function type(): TypeDescriptor<Random> {
      return TYPE.apply();
    }
  }

  export interface RandomGenerator {
    seed: number[];
    counter: number;
    buffer: number[];
  }

  export namespace RandomGenerator {
    export const TYPE_QNAME = "0x2::random::RandomGenerator";

    const TYPE = new TypeDescriptor<RandomGenerator>(
      RandomGenerator.TYPE_QNAME,
    );

    export function type(): TypeDescriptor<RandomGenerator> {
      return TYPE.apply();
    }
  }

  export interface RandomInner {
    version: bigint;
    epoch: bigint;
    randomness_round: bigint;
    random_bytes: number[];
  }

  export namespace RandomInner {
    export const TYPE_QNAME = "0x2::random::RandomInner";

    const TYPE = new TypeDescriptor<RandomInner>(RandomInner.TYPE_QNAME);

    export function type(): TypeDescriptor<RandomInner> {
      return TYPE.apply();
    }
  }

  export namespace builder {
    export function generateBool(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::random::generate_bool",
        arguments: _args,
      });
    }
    export function generateBytes(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        number | TransactionArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::random::generate_bytes",
        arguments: _args,
      });
    }
    export function generateU128(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::random::generate_u128",
        arguments: _args,
      });
    }
    export function generateU128InRange(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
        bigint | TransactionArgument,
      ],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));
      _args.push(transactionArgumentOrPure(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::random::generate_u128_in_range",
        arguments: _args,
      });
    }
    export function generateU16(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::random::generate_u16",
        arguments: _args,
      });
    }
    export function generateU16InRange(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        number | TransactionArgument,
        number | TransactionArgument,
      ],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));
      _args.push(transactionArgumentOrPure(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::random::generate_u16_in_range",
        arguments: _args,
      });
    }
    export function generateU256(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::random::generate_u256",
        arguments: _args,
      });
    }
    export function generateU32(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::random::generate_u32",
        arguments: _args,
      });
    }
    export function generateU32InRange(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        number | TransactionArgument,
        number | TransactionArgument,
      ],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));
      _args.push(transactionArgumentOrPure(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::random::generate_u32_in_range",
        arguments: _args,
      });
    }
    export function generateU64(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::random::generate_u64",
        arguments: _args,
      });
    }
    export function generateU64InRange(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
        bigint | TransactionArgument,
      ],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));
      _args.push(transactionArgumentOrPure(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::random::generate_u64_in_range",
        arguments: _args,
      });
    }
    export function generateU8(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::random::generate_u8",
        arguments: _args,
      });
    }
    export function generateU8InRange(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        number | TransactionArgument,
        number | TransactionArgument,
      ],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));
      _args.push(transactionArgumentOrPure(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::random::generate_u8_in_range",
        arguments: _args,
      });
    }
    export function newGenerator(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::random::new_generator",
        arguments: _args,
      });
    }
    export function shuffle<T0 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::random::shuffle",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
  }
  export namespace view {
    export async function generateBool(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): Promise<TypedDevInspectResults<[Boolean]>> {
      const tx = new TransactionBlock();
      builder.generateBool(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[Boolean]>(
        inspectRes,
      );
    }
    export async function generateBytes(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        number | TransactionArgument,
      ],
    ): Promise<TypedDevInspectResults<[number[]]>> {
      const tx = new TransactionBlock();
      builder.generateBytes(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[number[]]>(
        inspectRes,
      );
    }
    export async function generateU128(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new TransactionBlock();
      builder.generateU128(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function generateU128InRange(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
        bigint | TransactionArgument,
      ],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new TransactionBlock();
      builder.generateU128InRange(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function generateU16(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): Promise<TypedDevInspectResults<[number]>> {
      const tx = new TransactionBlock();
      builder.generateU16(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[number]>(
        inspectRes,
      );
    }
    export async function generateU16InRange(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        number | TransactionArgument,
        number | TransactionArgument,
      ],
    ): Promise<TypedDevInspectResults<[number]>> {
      const tx = new TransactionBlock();
      builder.generateU16InRange(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[number]>(
        inspectRes,
      );
    }
    export async function generateU256(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new TransactionBlock();
      builder.generateU256(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function generateU32(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): Promise<TypedDevInspectResults<[number]>> {
      const tx = new TransactionBlock();
      builder.generateU32(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[number]>(
        inspectRes,
      );
    }
    export async function generateU32InRange(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        number | TransactionArgument,
        number | TransactionArgument,
      ],
    ): Promise<TypedDevInspectResults<[number]>> {
      const tx = new TransactionBlock();
      builder.generateU32InRange(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[number]>(
        inspectRes,
      );
    }
    export async function generateU64(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new TransactionBlock();
      builder.generateU64(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function generateU64InRange(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
        bigint | TransactionArgument,
      ],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new TransactionBlock();
      builder.generateU64InRange(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function generateU8(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): Promise<TypedDevInspectResults<[number]>> {
      const tx = new TransactionBlock();
      builder.generateU8(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[number]>(
        inspectRes,
      );
    }
    export async function generateU8InRange(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        number | TransactionArgument,
        number | TransactionArgument,
      ],
    ): Promise<TypedDevInspectResults<[number]>> {
      const tx = new TransactionBlock();
      builder.generateU8InRange(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[number]>(
        inspectRes,
      );
    }
    export async function newGenerator(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): Promise<TypedDevInspectResults<[random.RandomGenerator]>> {
      const tx = new TransactionBlock();
      builder.newGenerator(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [random.RandomGenerator]
      >(inspectRes);
    }
    export async function shuffle<T0 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.shuffle(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
  }
}

export namespace sui {
  export interface SUI {
    dummy_field: Boolean;
  }

  export namespace SUI {
    export const TYPE_QNAME = "0x2::sui::SUI";

    const TYPE = new TypeDescriptor<SUI>(SUI.TYPE_QNAME);

    export function type(): TypeDescriptor<SUI> {
      return TYPE.apply();
    }
  }

  export namespace builder {
    export function transfer(
      tx: TransactionBlock,
      args: [
        coin.Coin<sui.SUI> | TransactionArgument,
        string | TransactionArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::sui::transfer",
        arguments: _args,
      });
    }
  }
  export namespace view {
    export async function transfer(
      client: SuiClient,
      args: [
        coin.Coin<sui.SUI> | TransactionArgument,
        string | TransactionArgument,
      ],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.transfer(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
  }
}

export namespace table {
  export interface Table<T0, T1> {
    id: object_.UID;
    size: bigint;
  }

  export namespace Table {
    export const TYPE_QNAME = "0x2::table::Table";

    const TYPE = new TypeDescriptor<Table<any, any>>(Table.TYPE_QNAME);

    export function type<T0, T1>(
      arg0: TypeDescriptor<T0> = ANY_TYPE,
      arg1: TypeDescriptor<T1> = ANY_TYPE,
    ): TypeDescriptor<Table<T0, T1>> {
      return TYPE.apply(arg0, arg1);
    }
  }

  export namespace builder {
    export function add<T0 = any, T1 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        T0 | TransactionArgument,
        T1 | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));
      _args.push(transactionArgumentOrPure(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::table::add",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function borrow<T0 = any, T1 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        T0 | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::table::borrow",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function borrowMut<T0 = any, T1 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        T0 | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::table::borrow_mut",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function contains<T0 = any, T1 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        T0 | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::table::contains",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function destroyEmpty<T0 = any, T1 = any>(
      tx: TransactionBlock,
      args: [table.Table<T0, T1> | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::table::destroy_empty",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function drop<T0 = any, T1 = any>(
      tx: TransactionBlock,
      args: [table.Table<T0, T1> | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::table::drop",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function isEmpty<T0 = any, T1 = any>(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::table::is_empty",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function length<T0 = any, T1 = any>(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::table::length",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function new_<T0 = any, T1 = any>(
      tx: TransactionBlock,
      args: [],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [] {
      const _args: any[] = [];

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::table::new",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function remove<T0 = any, T1 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        T0 | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::table::remove",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
  }
  export namespace view {
    export async function add<T0 = any, T1 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        T0 | TransactionArgument,
        T1 | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.add(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function borrow<T0 = any, T1 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        T0 | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new TransactionBlock();
      builder.borrow(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function borrowMut<T0 = any, T1 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        T0 | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new TransactionBlock();
      builder.borrowMut(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function contains<T0 = any, T1 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        T0 | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[Boolean]>> {
      const tx = new TransactionBlock();
      builder.contains(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[Boolean]>(
        inspectRes,
      );
    }
    export async function destroyEmpty<T0 = any, T1 = any>(
      client: SuiClient,
      args: [table.Table<T0, T1> | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.destroyEmpty(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function drop<T0 = any, T1 = any>(
      client: SuiClient,
      args: [table.Table<T0, T1> | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.drop(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function isEmpty<T0 = any, T1 = any>(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[Boolean]>> {
      const tx = new TransactionBlock();
      builder.isEmpty(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[Boolean]>(
        inspectRes,
      );
    }
    export async function length<T0 = any, T1 = any>(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new TransactionBlock();
      builder.length(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function new_<T0 = any, T1 = any>(
      client: SuiClient,
      args: [],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[table.Table<T0, T1>]>> {
      const tx = new TransactionBlock();
      builder.new_(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [table.Table<T0, T1>]
      >(inspectRes);
    }
    export async function remove<T0 = any, T1 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        T0 | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[T1]>> {
      const tx = new TransactionBlock();
      builder.remove(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[T1]>(
        inspectRes,
      );
    }
  }
}

export namespace table_vec {
  export interface TableVec<T0> {
    contents: table.Table<bigint, T0>;
  }

  export namespace TableVec {
    export const TYPE_QNAME = "0x2::table_vec::TableVec";

    const TYPE = new TypeDescriptor<TableVec<any>>(TableVec.TYPE_QNAME);

    export function type<T0>(
      arg0: TypeDescriptor<T0> = ANY_TYPE,
    ): TypeDescriptor<TableVec<T0>> {
      return TYPE.apply(arg0);
    }
  }

  export namespace builder {
    export function borrow<T0 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::table_vec::borrow",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function borrowMut<T0 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::table_vec::borrow_mut",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function destroyEmpty<T0 = any>(
      tx: TransactionBlock,
      args: [table_vec.TableVec<T0> | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::table_vec::destroy_empty",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function drop<T0 = any>(
      tx: TransactionBlock,
      args: [table_vec.TableVec<T0> | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::table_vec::drop",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function empty<T0 = any>(
      tx: TransactionBlock,
      args: [],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [] {
      const _args: any[] = [];

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::table_vec::empty",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function isEmpty<T0 = any>(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::table_vec::is_empty",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function length<T0 = any>(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::table_vec::length",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function popBack<T0 = any>(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::table_vec::pop_back",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function pushBack<T0 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        T0 | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::table_vec::push_back",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function singleton<T0 = any>(
      tx: TransactionBlock,
      args: [T0 | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::table_vec::singleton",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function swap<T0 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
        bigint | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));
      _args.push(transactionArgumentOrPure(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::table_vec::swap",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function swapRemove<T0 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::table_vec::swap_remove",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
  }
  export namespace view {
    export async function borrow<T0 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new TransactionBlock();
      builder.borrow(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function borrowMut<T0 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new TransactionBlock();
      builder.borrowMut(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function destroyEmpty<T0 = any>(
      client: SuiClient,
      args: [table_vec.TableVec<T0> | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.destroyEmpty(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function drop<T0 = any>(
      client: SuiClient,
      args: [table_vec.TableVec<T0> | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.drop(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function empty<T0 = any>(
      client: SuiClient,
      args: [],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[table_vec.TableVec<T0>]>> {
      const tx = new TransactionBlock();
      builder.empty(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [table_vec.TableVec<T0>]
      >(inspectRes);
    }
    export async function isEmpty<T0 = any>(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[Boolean]>> {
      const tx = new TransactionBlock();
      builder.isEmpty(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[Boolean]>(
        inspectRes,
      );
    }
    export async function length<T0 = any>(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new TransactionBlock();
      builder.length(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function popBack<T0 = any>(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[T0]>> {
      const tx = new TransactionBlock();
      builder.popBack(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[T0]>(
        inspectRes,
      );
    }
    export async function pushBack<T0 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        T0 | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.pushBack(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function singleton<T0 = any>(
      client: SuiClient,
      args: [T0 | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[table_vec.TableVec<T0>]>> {
      const tx = new TransactionBlock();
      builder.singleton(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [table_vec.TableVec<T0>]
      >(inspectRes);
    }
    export async function swap<T0 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
        bigint | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.swap(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function swapRemove<T0 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[T0]>> {
      const tx = new TransactionBlock();
      builder.swapRemove(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[T0]>(
        inspectRes,
      );
    }
  }
}

export namespace token {
  export interface ActionRequest<T0> {
    name: string;
    amount: bigint;
    sender: string;
    recipient: _0x1.option.Option<string>;
    spent_balance: _0x1.option.Option<balance.Balance<T0>>;
    approvals: vec_set.VecSet<_0x1.type_name.TypeName>;
  }

  export namespace ActionRequest {
    export const TYPE_QNAME = "0x2::token::ActionRequest";

    const TYPE = new TypeDescriptor<ActionRequest<any>>(
      ActionRequest.TYPE_QNAME,
    );

    export function type<T0>(
      arg0: TypeDescriptor<T0> = ANY_TYPE,
    ): TypeDescriptor<ActionRequest<T0>> {
      return TYPE.apply(arg0);
    }
  }

  export interface RuleKey<T0> {
    is_protected: Boolean;
  }

  export namespace RuleKey {
    export const TYPE_QNAME = "0x2::token::RuleKey";

    const TYPE = new TypeDescriptor<RuleKey<any>>(RuleKey.TYPE_QNAME);

    export function type<T0>(
      arg0: TypeDescriptor<T0> = ANY_TYPE,
    ): TypeDescriptor<RuleKey<T0>> {
      return TYPE.apply(arg0);
    }
  }

  export interface RuleKeyInstance extends TypedEventInstance<RuleKey<any>> {
    data_decoded: RuleKey<any>;
    type_arguments: [string];
  }

  export interface Token<T0> {
    id: object_.UID;
    balance: balance.Balance<T0>;
  }

  export namespace Token {
    export const TYPE_QNAME = "0x2::token::Token";

    const TYPE = new TypeDescriptor<Token<any>>(Token.TYPE_QNAME);

    export function type<T0>(
      arg0: TypeDescriptor<T0> = ANY_TYPE,
    ): TypeDescriptor<Token<T0>> {
      return TYPE.apply(arg0);
    }
  }

  export interface TokenPolicy<T0> {
    id: object_.UID;
    spent_balance: balance.Balance<T0>;
    rules: vec_map.VecMap<string, vec_set.VecSet<_0x1.type_name.TypeName>>;
  }

  export namespace TokenPolicy {
    export const TYPE_QNAME = "0x2::token::TokenPolicy";

    const TYPE = new TypeDescriptor<TokenPolicy<any>>(TokenPolicy.TYPE_QNAME);

    export function type<T0>(
      arg0: TypeDescriptor<T0> = ANY_TYPE,
    ): TypeDescriptor<TokenPolicy<T0>> {
      return TYPE.apply(arg0);
    }
  }

  export interface TokenPolicyCap<T0> {
    id: object_.UID;
    for: object_.ID;
  }

  export namespace TokenPolicyCap {
    export const TYPE_QNAME = "0x2::token::TokenPolicyCap";

    const TYPE = new TypeDescriptor<TokenPolicyCap<any>>(
      TokenPolicyCap.TYPE_QNAME,
    );

    export function type<T0>(
      arg0: TypeDescriptor<T0> = ANY_TYPE,
    ): TypeDescriptor<TokenPolicyCap<T0>> {
      return TYPE.apply(arg0);
    }
  }

  export interface TokenPolicyCreated<T0> {
    id: object_.ID;
    is_mutable: Boolean;
  }

  export namespace TokenPolicyCreated {
    export const TYPE_QNAME = "0x2::token::TokenPolicyCreated";

    const TYPE = new TypeDescriptor<TokenPolicyCreated<any>>(
      TokenPolicyCreated.TYPE_QNAME,
    );

    export function type<T0>(
      arg0: TypeDescriptor<T0> = ANY_TYPE,
    ): TypeDescriptor<TokenPolicyCreated<T0>> {
      return TYPE.apply(arg0);
    }
  }

  export interface TokenPolicyCreatedInstance
    extends TypedEventInstance<TokenPolicyCreated<any>> {
    data_decoded: TokenPolicyCreated<any>;
    type_arguments: [string];
  }

  export namespace builder {
    export function action<T0 = any>(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::token::action",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function addApproval<T0 = any, T1 = any>(
      tx: TransactionBlock,
      args: [
        T1 | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::token::add_approval",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function addRuleConfig<T0 = any, T1 = any, T2 = any>(
      tx: TransactionBlock,
      args: [
        T1 | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        T2 | TransactionArgument,
      ],
      typeArguments: [
        TypeDescriptor<T0> | string,
        TypeDescriptor<T1> | string,
        TypeDescriptor<T2> | string,
      ],
    ): TransactionArgument &
      [
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
      ] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));
      _args.push(transactionArgumentOrObject(args[2], tx));
      _args.push(transactionArgumentOrPure(args[3], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::token::add_rule_config",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
          typeof typeArguments[2] === "string"
            ? typeArguments[2]
            : typeArguments[2].getSignature(),
        ],
      });
    }
    export function addRuleForAction<T0 = any, T1 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));
      _args.push(transactionArgumentOrPure(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::token::add_rule_for_action",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function allow<T0 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));
      _args.push(transactionArgumentOrPure(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::token::allow",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function amount<T0 = any>(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::token::amount",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function approvals<T0 = any>(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::token::approvals",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function burn<T0 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        token.Token<T0> | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::token::burn",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function confirmRequest<T0 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        token.ActionRequest<T0> | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::token::confirm_request",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function confirmRequestMut<T0 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        token.ActionRequest<T0> | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::token::confirm_request_mut",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function confirmWithPolicyCap<T0 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        token.ActionRequest<T0> | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::token::confirm_with_policy_cap",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function confirmWithTreasuryCap<T0 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        token.ActionRequest<T0> | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::token::confirm_with_treasury_cap",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function destroyZero<T0 = any>(
      tx: TransactionBlock,
      args: [token.Token<T0> | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::token::destroy_zero",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function disallow<T0 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));
      _args.push(transactionArgumentOrPure(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::token::disallow",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function flush<T0 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::token::flush",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function fromCoin<T0 = any>(
      tx: TransactionBlock,
      args: [coin.Coin<T0> | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::token::from_coin",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function fromCoinAction(
      tx: TransactionBlock,
      args: [],
    ): TransactionArgument & [] {
      const _args: any[] = [];

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::token::from_coin_action",
        arguments: _args,
      });
    }
    export function hasRuleConfig<T0 = any, T1 = any>(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::token::has_rule_config",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function hasRuleConfigWithType<T0 = any, T1 = any, T2 = any>(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [
        TypeDescriptor<T0> | string,
        TypeDescriptor<T1> | string,
        TypeDescriptor<T2> | string,
      ],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::token::has_rule_config_with_type",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
          typeof typeArguments[2] === "string"
            ? typeArguments[2]
            : typeArguments[2].getSignature(),
        ],
      });
    }
    export function isAllowed<T0 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::token::is_allowed",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function join<T0 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        token.Token<T0> | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::token::join",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function keep<T0 = any>(
      tx: TransactionBlock,
      args: [token.Token<T0> | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::token::keep",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function mint<T0 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::token::mint",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function newPolicy<T0 = any>(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::token::new_policy",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function newRequest<T0 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionArgument,
        bigint | TransactionArgument,
        _0x1.option.Option<string> | TransactionArgument,
        _0x1.option.Option<balance.Balance<T0>> | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument &
      [
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
      ] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));
      _args.push(transactionArgumentOrPure(args[2], tx));
      _args.push(transactionArgumentOrPure(args[3], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::token::new_request",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function recipient<T0 = any>(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::token::recipient",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function removeRuleConfig<T0 = any, T1 = any, T2 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
      typeArguments: [
        TypeDescriptor<T0> | string,
        TypeDescriptor<T1> | string,
        TypeDescriptor<T2> | string,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::token::remove_rule_config",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
          typeof typeArguments[2] === "string"
            ? typeArguments[2]
            : typeArguments[2].getSignature(),
        ],
      });
    }
    export function removeRuleForAction<T0 = any, T1 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));
      _args.push(transactionArgumentOrPure(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::token::remove_rule_for_action",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function ruleConfig<T0 = any, T1 = any, T2 = any>(
      tx: TransactionBlock,
      args: [
        T1 | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
      typeArguments: [
        TypeDescriptor<T0> | string,
        TypeDescriptor<T1> | string,
        TypeDescriptor<T2> | string,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::token::rule_config",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
          typeof typeArguments[2] === "string"
            ? typeArguments[2]
            : typeArguments[2].getSignature(),
        ],
      });
    }
    export function ruleConfigMut<T0 = any, T1 = any, T2 = any>(
      tx: TransactionBlock,
      args: [
        T1 | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
      typeArguments: [
        TypeDescriptor<T0> | string,
        TypeDescriptor<T1> | string,
        TypeDescriptor<T2> | string,
      ],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));
      _args.push(transactionArgumentOrObject(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::token::rule_config_mut",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
          typeof typeArguments[2] === "string"
            ? typeArguments[2]
            : typeArguments[2].getSignature(),
        ],
      });
    }
    export function rules<T0 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::token::rules",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function sender<T0 = any>(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::token::sender",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function sharePolicy<T0 = any>(
      tx: TransactionBlock,
      args: [token.TokenPolicy<T0> | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::token::share_policy",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function spend<T0 = any>(
      tx: TransactionBlock,
      args: [token.Token<T0> | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::token::spend",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function spendAction(
      tx: TransactionBlock,
      args: [],
    ): TransactionArgument & [] {
      const _args: any[] = [];

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::token::spend_action",
        arguments: _args,
      });
    }
    export function spent<T0 = any>(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::token::spent",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function spentBalance<T0 = any>(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::token::spent_balance",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function split<T0 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::token::split",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function toCoin<T0 = any>(
      tx: TransactionBlock,
      args: [token.Token<T0> | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::token::to_coin",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function toCoinAction(
      tx: TransactionBlock,
      args: [],
    ): TransactionArgument & [] {
      const _args: any[] = [];

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::token::to_coin_action",
        arguments: _args,
      });
    }
    export function transfer<T0 = any>(
      tx: TransactionBlock,
      args: [
        token.Token<T0> | TransactionArgument,
        string | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::token::transfer",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function transferAction(
      tx: TransactionBlock,
      args: [],
    ): TransactionArgument & [] {
      const _args: any[] = [];

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::token::transfer_action",
        arguments: _args,
      });
    }
    export function value<T0 = any>(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::token::value",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function zero<T0 = any>(
      tx: TransactionBlock,
      args: [],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [] {
      const _args: any[] = [];

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::token::zero",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
  }
  export namespace view {
    export async function action<T0 = any>(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new TransactionBlock();
      builder.action(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function addApproval<T0 = any, T1 = any>(
      client: SuiClient,
      args: [
        T1 | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.addApproval(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function addRuleConfig<T0 = any, T1 = any, T2 = any>(
      client: SuiClient,
      args: [
        T1 | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        T2 | TransactionArgument,
      ],
      typeArguments: [
        TypeDescriptor<T0> | string,
        TypeDescriptor<T1> | string,
        TypeDescriptor<T2> | string,
      ],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.addRuleConfig(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function addRuleForAction<T0 = any, T1 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.addRuleForAction(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function allow<T0 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.allow(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function amount<T0 = any>(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new TransactionBlock();
      builder.amount(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function approvals<T0 = any>(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<
      TypedDevInspectResults<[vec_set.VecSet<_0x1.type_name.TypeName>]>
    > {
      const tx = new TransactionBlock();
      builder.approvals(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [vec_set.VecSet<_0x1.type_name.TypeName>]
      >(inspectRes);
    }
    export async function burn<T0 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        token.Token<T0> | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.burn(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function confirmRequest<T0 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        token.ActionRequest<T0> | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<
      TypedDevInspectResults<
        [string, bigint, string, _0x1.option.Option<string>]
      >
    > {
      const tx = new TransactionBlock();
      builder.confirmRequest(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [string, bigint, string, _0x1.option.Option<string>]
      >(inspectRes);
    }
    export async function confirmRequestMut<T0 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        token.ActionRequest<T0> | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<
      TypedDevInspectResults<
        [string, bigint, string, _0x1.option.Option<string>]
      >
    > {
      const tx = new TransactionBlock();
      builder.confirmRequestMut(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [string, bigint, string, _0x1.option.Option<string>]
      >(inspectRes);
    }
    export async function confirmWithPolicyCap<T0 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        token.ActionRequest<T0> | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<
      TypedDevInspectResults<
        [string, bigint, string, _0x1.option.Option<string>]
      >
    > {
      const tx = new TransactionBlock();
      builder.confirmWithPolicyCap(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [string, bigint, string, _0x1.option.Option<string>]
      >(inspectRes);
    }
    export async function confirmWithTreasuryCap<T0 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        token.ActionRequest<T0> | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<
      TypedDevInspectResults<
        [string, bigint, string, _0x1.option.Option<string>]
      >
    > {
      const tx = new TransactionBlock();
      builder.confirmWithTreasuryCap(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [string, bigint, string, _0x1.option.Option<string>]
      >(inspectRes);
    }
    export async function destroyZero<T0 = any>(
      client: SuiClient,
      args: [token.Token<T0> | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.destroyZero(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function disallow<T0 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.disallow(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function flush<T0 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new TransactionBlock();
      builder.flush(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function fromCoin<T0 = any>(
      client: SuiClient,
      args: [coin.Coin<T0> | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<
      TypedDevInspectResults<[token.Token<T0>, token.ActionRequest<T0>]>
    > {
      const tx = new TransactionBlock();
      builder.fromCoin(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [token.Token<T0>, token.ActionRequest<T0>]
      >(inspectRes);
    }
    export async function fromCoinAction(
      client: SuiClient,
      args: [],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new TransactionBlock();
      builder.fromCoinAction(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function hasRuleConfig<T0 = any, T1 = any>(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[Boolean]>> {
      const tx = new TransactionBlock();
      builder.hasRuleConfig(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[Boolean]>(
        inspectRes,
      );
    }
    export async function hasRuleConfigWithType<T0 = any, T1 = any, T2 = any>(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [
        TypeDescriptor<T0> | string,
        TypeDescriptor<T1> | string,
        TypeDescriptor<T2> | string,
      ],
    ): Promise<TypedDevInspectResults<[Boolean]>> {
      const tx = new TransactionBlock();
      builder.hasRuleConfigWithType(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[Boolean]>(
        inspectRes,
      );
    }
    export async function isAllowed<T0 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[Boolean]>> {
      const tx = new TransactionBlock();
      builder.isAllowed(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[Boolean]>(
        inspectRes,
      );
    }
    export async function join<T0 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        token.Token<T0> | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.join(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function keep<T0 = any>(
      client: SuiClient,
      args: [token.Token<T0> | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.keep(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function mint<T0 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[token.Token<T0>]>> {
      const tx = new TransactionBlock();
      builder.mint(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [token.Token<T0>]
      >(inspectRes);
    }
    export async function newPolicy<T0 = any>(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<
      TypedDevInspectResults<[token.TokenPolicy<T0>, token.TokenPolicyCap<T0>]>
    > {
      const tx = new TransactionBlock();
      builder.newPolicy(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [token.TokenPolicy<T0>, token.TokenPolicyCap<T0>]
      >(inspectRes);
    }
    export async function newRequest<T0 = any>(
      client: SuiClient,
      args: [
        string | TransactionArgument,
        bigint | TransactionArgument,
        _0x1.option.Option<string> | TransactionArgument,
        _0x1.option.Option<balance.Balance<T0>> | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[token.ActionRequest<T0>]>> {
      const tx = new TransactionBlock();
      builder.newRequest(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [token.ActionRequest<T0>]
      >(inspectRes);
    }
    export async function recipient<T0 = any>(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[_0x1.option.Option<string>]>> {
      const tx = new TransactionBlock();
      builder.recipient(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [_0x1.option.Option<string>]
      >(inspectRes);
    }
    export async function removeRuleConfig<T0 = any, T1 = any, T2 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
      typeArguments: [
        TypeDescriptor<T0> | string,
        TypeDescriptor<T1> | string,
        TypeDescriptor<T2> | string,
      ],
    ): Promise<TypedDevInspectResults<[T2]>> {
      const tx = new TransactionBlock();
      builder.removeRuleConfig(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[T2]>(
        inspectRes,
      );
    }
    export async function removeRuleForAction<T0 = any, T1 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.removeRuleForAction(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function ruleConfig<T0 = any, T1 = any, T2 = any>(
      client: SuiClient,
      args: [
        T1 | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
      typeArguments: [
        TypeDescriptor<T0> | string,
        TypeDescriptor<T1> | string,
        TypeDescriptor<T2> | string,
      ],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new TransactionBlock();
      builder.ruleConfig(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function ruleConfigMut<T0 = any, T1 = any, T2 = any>(
      client: SuiClient,
      args: [
        T1 | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
      typeArguments: [
        TypeDescriptor<T0> | string,
        TypeDescriptor<T1> | string,
        TypeDescriptor<T2> | string,
      ],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new TransactionBlock();
      builder.ruleConfigMut(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function rules<T0 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<
      TypedDevInspectResults<[vec_set.VecSet<_0x1.type_name.TypeName>]>
    > {
      const tx = new TransactionBlock();
      builder.rules(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [vec_set.VecSet<_0x1.type_name.TypeName>]
      >(inspectRes);
    }
    export async function sender<T0 = any>(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new TransactionBlock();
      builder.sender(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function sharePolicy<T0 = any>(
      client: SuiClient,
      args: [token.TokenPolicy<T0> | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.sharePolicy(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function spend<T0 = any>(
      client: SuiClient,
      args: [token.Token<T0> | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[token.ActionRequest<T0>]>> {
      const tx = new TransactionBlock();
      builder.spend(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [token.ActionRequest<T0>]
      >(inspectRes);
    }
    export async function spendAction(
      client: SuiClient,
      args: [],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new TransactionBlock();
      builder.spendAction(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function spent<T0 = any>(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[_0x1.option.Option<bigint>]>> {
      const tx = new TransactionBlock();
      builder.spent(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [_0x1.option.Option<bigint>]
      >(inspectRes);
    }
    export async function spentBalance<T0 = any>(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new TransactionBlock();
      builder.spentBalance(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function split<T0 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[token.Token<T0>]>> {
      const tx = new TransactionBlock();
      builder.split(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [token.Token<T0>]
      >(inspectRes);
    }
    export async function toCoin<T0 = any>(
      client: SuiClient,
      args: [token.Token<T0> | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<
      TypedDevInspectResults<[coin.Coin<T0>, token.ActionRequest<T0>]>
    > {
      const tx = new TransactionBlock();
      builder.toCoin(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [coin.Coin<T0>, token.ActionRequest<T0>]
      >(inspectRes);
    }
    export async function toCoinAction(
      client: SuiClient,
      args: [],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new TransactionBlock();
      builder.toCoinAction(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function transfer<T0 = any>(
      client: SuiClient,
      args: [
        token.Token<T0> | TransactionArgument,
        string | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[token.ActionRequest<T0>]>> {
      const tx = new TransactionBlock();
      builder.transfer(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [token.ActionRequest<T0>]
      >(inspectRes);
    }
    export async function transferAction(
      client: SuiClient,
      args: [],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new TransactionBlock();
      builder.transferAction(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function value<T0 = any>(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new TransactionBlock();
      builder.value(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function zero<T0 = any>(
      client: SuiClient,
      args: [],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[token.Token<T0>]>> {
      const tx = new TransactionBlock();
      builder.zero(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [token.Token<T0>]
      >(inspectRes);
    }
  }
}

export namespace transfer {
  export interface Receiving<T0> {
    id: object_.ID;
    version: bigint;
  }

  export namespace Receiving {
    export const TYPE_QNAME = "0x2::transfer::Receiving";

    const TYPE = new TypeDescriptor<Receiving<any>>(Receiving.TYPE_QNAME);

    export function type<T0>(
      arg0: TypeDescriptor<T0> = ANY_TYPE,
    ): TypeDescriptor<Receiving<T0>> {
      return TYPE.apply(arg0);
    }
  }

  export namespace builder {
    export function freezeObject<T0 = any>(
      tx: TransactionBlock,
      args: [T0 | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::transfer::freeze_object",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function freezeObjectImpl<T0 = any>(
      tx: TransactionBlock,
      args: [T0 | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::transfer::freeze_object_impl",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function publicFreezeObject<T0 = any>(
      tx: TransactionBlock,
      args: [T0 | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::transfer::public_freeze_object",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function publicReceive<T0 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        transfer.Receiving<T0> | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::transfer::public_receive",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function publicShareObject<T0 = any>(
      tx: TransactionBlock,
      args: [T0 | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::transfer::public_share_object",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function publicTransfer<T0 = any>(
      tx: TransactionBlock,
      args: [T0 | TransactionArgument, string | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::transfer::public_transfer",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function receive<T0 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        transfer.Receiving<T0> | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::transfer::receive",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function receivingObjectId<T0 = any>(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::transfer::receiving_object_id",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function shareObject<T0 = any>(
      tx: TransactionBlock,
      args: [T0 | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::transfer::share_object",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function shareObjectImpl<T0 = any>(
      tx: TransactionBlock,
      args: [T0 | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::transfer::share_object_impl",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function transfer<T0 = any>(
      tx: TransactionBlock,
      args: [T0 | TransactionArgument, string | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::transfer::transfer",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function transferImpl<T0 = any>(
      tx: TransactionBlock,
      args: [T0 | TransactionArgument, string | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::transfer::transfer_impl",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
  }
  export namespace view {
    export async function freezeObject<T0 = any>(
      client: SuiClient,
      args: [T0 | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.freezeObject(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function freezeObjectImpl<T0 = any>(
      client: SuiClient,
      args: [T0 | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.freezeObjectImpl(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function publicFreezeObject<T0 = any>(
      client: SuiClient,
      args: [T0 | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.publicFreezeObject(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function publicReceive<T0 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        transfer.Receiving<T0> | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[T0]>> {
      const tx = new TransactionBlock();
      builder.publicReceive(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[T0]>(
        inspectRes,
      );
    }
    export async function publicShareObject<T0 = any>(
      client: SuiClient,
      args: [T0 | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.publicShareObject(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function publicTransfer<T0 = any>(
      client: SuiClient,
      args: [T0 | TransactionArgument, string | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.publicTransfer(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function receive<T0 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        transfer.Receiving<T0> | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[T0]>> {
      const tx = new TransactionBlock();
      builder.receive(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[T0]>(
        inspectRes,
      );
    }
    export async function receivingObjectId<T0 = any>(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[object_.ID]>> {
      const tx = new TransactionBlock();
      builder.receivingObjectId(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[object_.ID]>(
        inspectRes,
      );
    }
    export async function shareObject<T0 = any>(
      client: SuiClient,
      args: [T0 | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.shareObject(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function shareObjectImpl<T0 = any>(
      client: SuiClient,
      args: [T0 | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.shareObjectImpl(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function transfer<T0 = any>(
      client: SuiClient,
      args: [T0 | TransactionArgument, string | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.transfer(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function transferImpl<T0 = any>(
      client: SuiClient,
      args: [T0 | TransactionArgument, string | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.transferImpl(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
  }
}

export namespace transfer_policy {
  export interface RuleKey<T0> {
    dummy_field: Boolean;
  }

  export namespace RuleKey {
    export const TYPE_QNAME = "0x2::transfer_policy::RuleKey";

    const TYPE = new TypeDescriptor<RuleKey<any>>(RuleKey.TYPE_QNAME);

    export function type<T0>(
      arg0: TypeDescriptor<T0> = ANY_TYPE,
    ): TypeDescriptor<RuleKey<T0>> {
      return TYPE.apply(arg0);
    }
  }

  export interface RuleKeyInstance extends TypedEventInstance<RuleKey<any>> {
    data_decoded: RuleKey<any>;
    type_arguments: [string];
  }

  export interface TransferPolicy<T0> {
    id: object_.UID;
    balance: balance.Balance<sui.SUI>;
    rules: vec_set.VecSet<_0x1.type_name.TypeName>;
  }

  export namespace TransferPolicy {
    export const TYPE_QNAME = "0x2::transfer_policy::TransferPolicy";

    const TYPE = new TypeDescriptor<TransferPolicy<any>>(
      TransferPolicy.TYPE_QNAME,
    );

    export function type<T0>(
      arg0: TypeDescriptor<T0> = ANY_TYPE,
    ): TypeDescriptor<TransferPolicy<T0>> {
      return TYPE.apply(arg0);
    }
  }

  export interface TransferPolicyCap<T0> {
    id: object_.UID;
    policy_id: object_.ID;
  }

  export namespace TransferPolicyCap {
    export const TYPE_QNAME = "0x2::transfer_policy::TransferPolicyCap";

    const TYPE = new TypeDescriptor<TransferPolicyCap<any>>(
      TransferPolicyCap.TYPE_QNAME,
    );

    export function type<T0>(
      arg0: TypeDescriptor<T0> = ANY_TYPE,
    ): TypeDescriptor<TransferPolicyCap<T0>> {
      return TYPE.apply(arg0);
    }
  }

  export interface TransferPolicyCreated<T0> {
    id: object_.ID;
  }

  export namespace TransferPolicyCreated {
    export const TYPE_QNAME = "0x2::transfer_policy::TransferPolicyCreated";

    const TYPE = new TypeDescriptor<TransferPolicyCreated<any>>(
      TransferPolicyCreated.TYPE_QNAME,
    );

    export function type<T0>(
      arg0: TypeDescriptor<T0> = ANY_TYPE,
    ): TypeDescriptor<TransferPolicyCreated<T0>> {
      return TYPE.apply(arg0);
    }
  }

  export interface TransferPolicyCreatedInstance
    extends TypedEventInstance<TransferPolicyCreated<any>> {
    data_decoded: TransferPolicyCreated<any>;
    type_arguments: [string];
  }

  export interface TransferPolicyDestroyed<T0> {
    id: object_.ID;
  }

  export namespace TransferPolicyDestroyed {
    export const TYPE_QNAME = "0x2::transfer_policy::TransferPolicyDestroyed";

    const TYPE = new TypeDescriptor<TransferPolicyDestroyed<any>>(
      TransferPolicyDestroyed.TYPE_QNAME,
    );

    export function type<T0>(
      arg0: TypeDescriptor<T0> = ANY_TYPE,
    ): TypeDescriptor<TransferPolicyDestroyed<T0>> {
      return TYPE.apply(arg0);
    }
  }

  export interface TransferPolicyDestroyedInstance
    extends TypedEventInstance<TransferPolicyDestroyed<any>> {
    data_decoded: TransferPolicyDestroyed<any>;
    type_arguments: [string];
  }

  export interface TransferRequest<T0> {
    item: object_.ID;
    paid: bigint;
    from: object_.ID;
    receipts: vec_set.VecSet<_0x1.type_name.TypeName>;
  }

  export namespace TransferRequest {
    export const TYPE_QNAME = "0x2::transfer_policy::TransferRequest";

    const TYPE = new TypeDescriptor<TransferRequest<any>>(
      TransferRequest.TYPE_QNAME,
    );

    export function type<T0>(
      arg0: TypeDescriptor<T0> = ANY_TYPE,
    ): TypeDescriptor<TransferRequest<T0>> {
      return TYPE.apply(arg0);
    }
  }

  export namespace builder {
    export function addReceipt<T0 = any, T1 = any>(
      tx: TransactionBlock,
      args: [
        T1 | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::transfer_policy::add_receipt",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function addRule<T0 = any, T1 = any, T2 = any>(
      tx: TransactionBlock,
      args: [
        T1 | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        T2 | TransactionArgument,
      ],
      typeArguments: [
        TypeDescriptor<T0> | string,
        TypeDescriptor<T1> | string,
        TypeDescriptor<T2> | string,
      ],
    ): TransactionArgument &
      [
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
      ] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));
      _args.push(transactionArgumentOrObject(args[2], tx));
      _args.push(transactionArgumentOrPure(args[3], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::transfer_policy::add_rule",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
          typeof typeArguments[2] === "string"
            ? typeArguments[2]
            : typeArguments[2].getSignature(),
        ],
      });
    }
    export function addToBalance<T0 = any, T1 = any>(
      tx: TransactionBlock,
      args: [
        T1 | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        coin.Coin<sui.SUI> | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));
      _args.push(transactionArgumentOrPure(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::transfer_policy::add_to_balance",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function confirmRequest<T0 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        transfer_policy.TransferRequest<T0> | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::transfer_policy::confirm_request",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function default_<T0 = any>(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::transfer_policy::default",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function destroyAndWithdraw<T0 = any>(
      tx: TransactionBlock,
      args: [
        transfer_policy.TransferPolicy<T0> | TransactionArgument,
        transfer_policy.TransferPolicyCap<T0> | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::transfer_policy::destroy_and_withdraw",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function from<T0 = any>(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::transfer_policy::from",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function getRule<T0 = any, T1 = any, T2 = any>(
      tx: TransactionBlock,
      args: [
        T1 | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
      typeArguments: [
        TypeDescriptor<T0> | string,
        TypeDescriptor<T1> | string,
        TypeDescriptor<T2> | string,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::transfer_policy::get_rule",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
          typeof typeArguments[2] === "string"
            ? typeArguments[2]
            : typeArguments[2].getSignature(),
        ],
      });
    }
    export function hasRule<T0 = any, T1 = any>(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::transfer_policy::has_rule",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function item<T0 = any>(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::transfer_policy::item",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function new_<T0 = any>(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::transfer_policy::new",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function newRequest<T0 = any>(
      tx: TransactionBlock,
      args: [
        object_.ID | TransactionArgument,
        bigint | TransactionArgument,
        object_.ID | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));
      _args.push(transactionArgumentOrPure(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::transfer_policy::new_request",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function paid<T0 = any>(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::transfer_policy::paid",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function removeRule<T0 = any, T1 = any, T2 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
      typeArguments: [
        TypeDescriptor<T0> | string,
        TypeDescriptor<T1> | string,
        TypeDescriptor<T2> | string,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::transfer_policy::remove_rule",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
          typeof typeArguments[2] === "string"
            ? typeArguments[2]
            : typeArguments[2].getSignature(),
        ],
      });
    }
    export function rules<T0 = any>(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::transfer_policy::rules",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function uid<T0 = any>(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::transfer_policy::uid",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function uidMutAsOwner<T0 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::transfer_policy::uid_mut_as_owner",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function withdraw<T0 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        _0x1.option.Option<bigint> | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));
      _args.push(transactionArgumentOrPure(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::transfer_policy::withdraw",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
  }
  export namespace view {
    export async function addReceipt<T0 = any, T1 = any>(
      client: SuiClient,
      args: [
        T1 | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.addReceipt(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function addRule<T0 = any, T1 = any, T2 = any>(
      client: SuiClient,
      args: [
        T1 | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        T2 | TransactionArgument,
      ],
      typeArguments: [
        TypeDescriptor<T0> | string,
        TypeDescriptor<T1> | string,
        TypeDescriptor<T2> | string,
      ],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.addRule(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function addToBalance<T0 = any, T1 = any>(
      client: SuiClient,
      args: [
        T1 | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        coin.Coin<sui.SUI> | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.addToBalance(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function confirmRequest<T0 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        transfer_policy.TransferRequest<T0> | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[object_.ID, bigint, object_.ID]>> {
      const tx = new TransactionBlock();
      builder.confirmRequest(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [object_.ID, bigint, object_.ID]
      >(inspectRes);
    }

    export async function destroyAndWithdraw<T0 = any>(
      client: SuiClient,
      args: [
        transfer_policy.TransferPolicy<T0> | TransactionArgument,
        transfer_policy.TransferPolicyCap<T0> | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[coin.Coin<sui.SUI>]>> {
      const tx = new TransactionBlock();
      builder.destroyAndWithdraw(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [coin.Coin<sui.SUI>]
      >(inspectRes);
    }
    export async function from<T0 = any>(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[object_.ID]>> {
      const tx = new TransactionBlock();
      builder.from(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[object_.ID]>(
        inspectRes,
      );
    }
    export async function getRule<T0 = any, T1 = any, T2 = any>(
      client: SuiClient,
      args: [
        T1 | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
      typeArguments: [
        TypeDescriptor<T0> | string,
        TypeDescriptor<T1> | string,
        TypeDescriptor<T2> | string,
      ],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new TransactionBlock();
      builder.getRule(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function hasRule<T0 = any, T1 = any>(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[Boolean]>> {
      const tx = new TransactionBlock();
      builder.hasRule(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[Boolean]>(
        inspectRes,
      );
    }
    export async function item<T0 = any>(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[object_.ID]>> {
      const tx = new TransactionBlock();
      builder.item(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[object_.ID]>(
        inspectRes,
      );
    }
    export async function new_<T0 = any>(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<
      TypedDevInspectResults<
        [
          transfer_policy.TransferPolicy<T0>,
          transfer_policy.TransferPolicyCap<T0>,
        ]
      >
    > {
      const tx = new TransactionBlock();
      builder.new_(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [
          transfer_policy.TransferPolicy<T0>,
          transfer_policy.TransferPolicyCap<T0>,
        ]
      >(inspectRes);
    }
    export async function newRequest<T0 = any>(
      client: SuiClient,
      args: [
        object_.ID | TransactionArgument,
        bigint | TransactionArgument,
        object_.ID | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[transfer_policy.TransferRequest<T0>]>> {
      const tx = new TransactionBlock();
      builder.newRequest(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [transfer_policy.TransferRequest<T0>]
      >(inspectRes);
    }
    export async function paid<T0 = any>(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new TransactionBlock();
      builder.paid(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function removeRule<T0 = any, T1 = any, T2 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
      typeArguments: [
        TypeDescriptor<T0> | string,
        TypeDescriptor<T1> | string,
        TypeDescriptor<T2> | string,
      ],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.removeRule(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function rules<T0 = any>(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new TransactionBlock();
      builder.rules(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function uid<T0 = any>(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new TransactionBlock();
      builder.uid(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function uidMutAsOwner<T0 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new TransactionBlock();
      builder.uidMutAsOwner(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function withdraw<T0 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        _0x1.option.Option<bigint> | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[coin.Coin<sui.SUI>]>> {
      const tx = new TransactionBlock();
      builder.withdraw(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [coin.Coin<sui.SUI>]
      >(inspectRes);
    }
  }
}

export namespace tx_context {
  export interface TxContext {
    sender: string;
    tx_hash: number[];
    epoch: bigint;
    epoch_timestamp_ms: bigint;
    ids_created: bigint;
  }

  export namespace TxContext {
    export const TYPE_QNAME = "0x2::tx_context::TxContext";

    const TYPE = new TypeDescriptor<TxContext>(TxContext.TYPE_QNAME);

    export function type(): TypeDescriptor<TxContext> {
      return TYPE.apply();
    }
  }

  export namespace builder {
    export function digest(
      tx: TransactionBlock,
      args: [],
    ): TransactionArgument & [] {
      const _args: any[] = [];

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::tx_context::digest",
        arguments: _args,
      });
    }
    export function epoch(
      tx: TransactionBlock,
      args: [],
    ): TransactionArgument & [] {
      const _args: any[] = [];

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::tx_context::epoch",
        arguments: _args,
      });
    }
    export function epochTimestampMs(
      tx: TransactionBlock,
      args: [],
    ): TransactionArgument & [] {
      const _args: any[] = [];

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::tx_context::epoch_timestamp_ms",
        arguments: _args,
      });
    }
    export function freshObjectAddress(
      tx: TransactionBlock,
      args: [],
    ): TransactionArgument & [] {
      const _args: any[] = [];

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::tx_context::fresh_object_address",
        arguments: _args,
      });
    }
    export function sender(
      tx: TransactionBlock,
      args: [],
    ): TransactionArgument & [] {
      const _args: any[] = [];

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::tx_context::sender",
        arguments: _args,
      });
    }
  }
  export namespace view {
    export async function digest(
      client: SuiClient,
      args: [],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new TransactionBlock();
      builder.digest(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function epoch(
      client: SuiClient,
      args: [],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new TransactionBlock();
      builder.epoch(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function epochTimestampMs(
      client: SuiClient,
      args: [],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new TransactionBlock();
      builder.epochTimestampMs(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function freshObjectAddress(
      client: SuiClient,
      args: [],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new TransactionBlock();
      builder.freshObjectAddress(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function sender(
      client: SuiClient,
      args: [],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new TransactionBlock();
      builder.sender(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
  }
}

export namespace types {
  export namespace builder {
    export function isOneTimeWitness<T0 = any>(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::types::is_one_time_witness",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
  }
  export namespace view {
    export async function isOneTimeWitness<T0 = any>(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[Boolean]>> {
      const tx = new TransactionBlock();
      builder.isOneTimeWitness(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[Boolean]>(
        inspectRes,
      );
    }
  }
}

export namespace url {
  export interface Url {
    url: _0x1.ascii.String;
  }

  export namespace Url {
    export const TYPE_QNAME = "0x2::url::Url";

    const TYPE = new TypeDescriptor<Url>(Url.TYPE_QNAME);

    export function type(): TypeDescriptor<Url> {
      return TYPE.apply();
    }
  }

  export interface UrlInstance extends TypedEventInstance<Url> {
    data_decoded: Url;
    type_arguments: [];
  }

  export namespace builder {
    export function innerUrl(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::url::inner_url",
        arguments: _args,
      });
    }
    export function newUnsafe(
      tx: TransactionBlock,
      args: [_0x1.ascii.String | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::url::new_unsafe",
        arguments: _args,
      });
    }
    export function newUnsafeFromBytes(
      tx: TransactionBlock,
      args: [(string | TransactionObjectArgument)[] | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrVec(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::url::new_unsafe_from_bytes",
        arguments: _args,
      });
    }
    export function update(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        _0x1.ascii.String | TransactionArgument,
      ],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::url::update",
        arguments: _args,
      });
    }
  }
  export namespace view {
    export async function innerUrl(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): Promise<TypedDevInspectResults<[_0x1.ascii.String]>> {
      const tx = new TransactionBlock();
      builder.innerUrl(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [_0x1.ascii.String]
      >(inspectRes);
    }
    export async function newUnsafe(
      client: SuiClient,
      args: [_0x1.ascii.String | TransactionArgument],
    ): Promise<TypedDevInspectResults<[url.Url]>> {
      const tx = new TransactionBlock();
      builder.newUnsafe(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[url.Url]>(
        inspectRes,
      );
    }
    export async function newUnsafeFromBytes(
      client: SuiClient,
      args: [(string | TransactionObjectArgument)[] | TransactionArgument],
    ): Promise<TypedDevInspectResults<[url.Url]>> {
      const tx = new TransactionBlock();
      builder.newUnsafeFromBytes(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[url.Url]>(
        inspectRes,
      );
    }
    export async function update(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        _0x1.ascii.String | TransactionArgument,
      ],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.update(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
  }
}

export namespace vdf {
  export namespace builder {
    export function hashToInput(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::vdf::hash_to_input",
        arguments: _args,
      });
    }
    export function vdfVerify(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
      ],
    ): TransactionArgument &
      [
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
      ] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));
      _args.push(transactionArgumentOrObject(args[2], tx));
      _args.push(transactionArgumentOrPure(args[3], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::vdf::vdf_verify",
        arguments: _args,
      });
    }
  }
  export namespace view {
    export async function hashToInput(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): Promise<TypedDevInspectResults<[number[]]>> {
      const tx = new TransactionBlock();
      builder.hashToInput(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[number[]]>(
        inspectRes,
      );
    }
    export async function vdfVerify(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
      ],
    ): Promise<TypedDevInspectResults<[Boolean]>> {
      const tx = new TransactionBlock();
      builder.vdfVerify(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[Boolean]>(
        inspectRes,
      );
    }
  }
}

export namespace vec_map {
  export interface Entry<T0, T1> {
    key: T0;
    value: T1;
  }

  export namespace Entry {
    export const TYPE_QNAME = "0x2::vec_map::Entry";

    const TYPE = new TypeDescriptor<Entry<any, any>>(Entry.TYPE_QNAME);

    export function type<T0, T1>(
      arg0: TypeDescriptor<T0> = ANY_TYPE,
      arg1: TypeDescriptor<T1> = ANY_TYPE,
    ): TypeDescriptor<Entry<T0, T1>> {
      return TYPE.apply(arg0, arg1);
    }
  }

  export interface EntryInstance extends TypedEventInstance<Entry<any, any>> {
    data_decoded: Entry<any, any>;
    type_arguments: [string, string];
  }

  export interface VecMap<T0, T1> {
    contents: vec_map.Entry<T0, T1>[];
  }

  export namespace VecMap {
    export const TYPE_QNAME = "0x2::vec_map::VecMap";

    const TYPE = new TypeDescriptor<VecMap<any, any>>(VecMap.TYPE_QNAME);

    export function type<T0, T1>(
      arg0: TypeDescriptor<T0> = ANY_TYPE,
      arg1: TypeDescriptor<T1> = ANY_TYPE,
    ): TypeDescriptor<VecMap<T0, T1>> {
      return TYPE.apply(arg0, arg1);
    }
  }

  export interface VecMapInstance extends TypedEventInstance<VecMap<any, any>> {
    data_decoded: VecMap<any, any>;
    type_arguments: [string, string];
  }

  export namespace builder {
    export function contains<T0 = any, T1 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::vec_map::contains",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function destroyEmpty<T0 = any, T1 = any>(
      tx: TransactionBlock,
      args: [vec_map.VecMap<T0, T1> | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::vec_map::destroy_empty",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function empty<T0 = any, T1 = any>(
      tx: TransactionBlock,
      args: [],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [] {
      const _args: any[] = [];

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::vec_map::empty",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function fromKeysValues<T0 = any, T1 = any>(
      tx: TransactionBlock,
      args: [
        (string | TransactionObjectArgument)[] | TransactionArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrVec(args[0], tx));
      _args.push(transactionArgumentOrVec(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::vec_map::from_keys_values",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function get<T0 = any, T1 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::vec_map::get",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function getEntryByIdx<T0 = any, T1 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::vec_map::get_entry_by_idx",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function getEntryByIdxMut<T0 = any, T1 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::vec_map::get_entry_by_idx_mut",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function getIdx<T0 = any, T1 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::vec_map::get_idx",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function getIdxOpt<T0 = any, T1 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::vec_map::get_idx_opt",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function getMut<T0 = any, T1 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::vec_map::get_mut",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function insert<T0 = any, T1 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        T0 | TransactionArgument,
        T1 | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));
      _args.push(transactionArgumentOrPure(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::vec_map::insert",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function intoKeysValues<T0 = any, T1 = any>(
      tx: TransactionBlock,
      args: [vec_map.VecMap<T0, T1> | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::vec_map::into_keys_values",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function isEmpty<T0 = any, T1 = any>(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::vec_map::is_empty",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function keys<T0 = any, T1 = any>(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::vec_map::keys",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function pop<T0 = any, T1 = any>(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::vec_map::pop",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function remove<T0 = any, T1 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::vec_map::remove",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function removeEntryByIdx<T0 = any, T1 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::vec_map::remove_entry_by_idx",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function size<T0 = any, T1 = any>(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::vec_map::size",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function tryGet<T0 = any, T1 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::vec_map::try_get",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
  }
  export namespace view {
    export async function contains<T0 = any, T1 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[Boolean]>> {
      const tx = new TransactionBlock();
      builder.contains(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[Boolean]>(
        inspectRes,
      );
    }
    export async function destroyEmpty<T0 = any, T1 = any>(
      client: SuiClient,
      args: [vec_map.VecMap<T0, T1> | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.destroyEmpty(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function empty<T0 = any, T1 = any>(
      client: SuiClient,
      args: [],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[vec_map.VecMap<T0, T1>]>> {
      const tx = new TransactionBlock();
      builder.empty(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [vec_map.VecMap<T0, T1>]
      >(inspectRes);
    }
    export async function fromKeysValues<T0 = any, T1 = any>(
      client: SuiClient,
      args: [
        (string | TransactionObjectArgument)[] | TransactionArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[vec_map.VecMap<T0, T1>]>> {
      const tx = new TransactionBlock();
      builder.fromKeysValues(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [vec_map.VecMap<T0, T1>]
      >(inspectRes);
    }
    export async function get<T0 = any, T1 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new TransactionBlock();
      builder.get(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function getEntryByIdx<T0 = any, T1 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[string, string]>> {
      const tx = new TransactionBlock();
      builder.getEntryByIdx(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [string, string]
      >(inspectRes);
    }
    export async function getEntryByIdxMut<T0 = any, T1 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[string, string]>> {
      const tx = new TransactionBlock();
      builder.getEntryByIdxMut(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [string, string]
      >(inspectRes);
    }
    export async function getIdx<T0 = any, T1 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new TransactionBlock();
      builder.getIdx(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function getIdxOpt<T0 = any, T1 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[_0x1.option.Option<bigint>]>> {
      const tx = new TransactionBlock();
      builder.getIdxOpt(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [_0x1.option.Option<bigint>]
      >(inspectRes);
    }
    export async function getMut<T0 = any, T1 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new TransactionBlock();
      builder.getMut(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function insert<T0 = any, T1 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        T0 | TransactionArgument,
        T1 | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.insert(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function intoKeysValues<T0 = any, T1 = any>(
      client: SuiClient,
      args: [vec_map.VecMap<T0, T1> | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[T0[] | string, T1[] | string]>> {
      const tx = new TransactionBlock();
      builder.intoKeysValues(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [T0[] | string, T1[] | string]
      >(inspectRes);
    }
    export async function isEmpty<T0 = any, T1 = any>(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[Boolean]>> {
      const tx = new TransactionBlock();
      builder.isEmpty(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[Boolean]>(
        inspectRes,
      );
    }
    export async function keys<T0 = any, T1 = any>(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[T0[] | string]>> {
      const tx = new TransactionBlock();
      builder.keys(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [T0[] | string]
      >(inspectRes);
    }
    export async function pop<T0 = any, T1 = any>(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[T0, T1]>> {
      const tx = new TransactionBlock();
      builder.pop(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[T0, T1]>(
        inspectRes,
      );
    }
    export async function remove<T0 = any, T1 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[T0, T1]>> {
      const tx = new TransactionBlock();
      builder.remove(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[T0, T1]>(
        inspectRes,
      );
    }
    export async function removeEntryByIdx<T0 = any, T1 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[T0, T1]>> {
      const tx = new TransactionBlock();
      builder.removeEntryByIdx(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[T0, T1]>(
        inspectRes,
      );
    }
    export async function size<T0 = any, T1 = any>(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new TransactionBlock();
      builder.size(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function tryGet<T0 = any, T1 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[_0x1.option.Option<T1>]>> {
      const tx = new TransactionBlock();
      builder.tryGet(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [_0x1.option.Option<T1>]
      >(inspectRes);
    }
  }
}

export namespace vec_set {
  export interface VecSet<T0> {
    contents: T0[] | string;
  }

  export namespace VecSet {
    export const TYPE_QNAME = "0x2::vec_set::VecSet";

    const TYPE = new TypeDescriptor<VecSet<any>>(VecSet.TYPE_QNAME);

    export function type<T0>(
      arg0: TypeDescriptor<T0> = ANY_TYPE,
    ): TypeDescriptor<VecSet<T0>> {
      return TYPE.apply(arg0);
    }
  }

  export interface VecSetInstance extends TypedEventInstance<VecSet<any>> {
    data_decoded: VecSet<any>;
    type_arguments: [string];
  }

  export namespace builder {
    export function contains<T0 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::vec_set::contains",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function empty<T0 = any>(
      tx: TransactionBlock,
      args: [],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [] {
      const _args: any[] = [];

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::vec_set::empty",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function fromKeys<T0 = any>(
      tx: TransactionBlock,
      args: [(string | TransactionObjectArgument)[] | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrVec(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::vec_set::from_keys",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function insert<T0 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        T0 | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::vec_set::insert",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function intoKeys<T0 = any>(
      tx: TransactionBlock,
      args: [vec_set.VecSet<T0> | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::vec_set::into_keys",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function isEmpty<T0 = any>(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::vec_set::is_empty",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function keys<T0 = any>(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::vec_set::keys",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function remove<T0 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::vec_set::remove",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function singleton<T0 = any>(
      tx: TransactionBlock,
      args: [T0 | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::vec_set::singleton",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function size<T0 = any>(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::vec_set::size",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
  }
  export namespace view {
    export async function contains<T0 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[Boolean]>> {
      const tx = new TransactionBlock();
      builder.contains(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[Boolean]>(
        inspectRes,
      );
    }
    export async function empty<T0 = any>(
      client: SuiClient,
      args: [],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[vec_set.VecSet<T0>]>> {
      const tx = new TransactionBlock();
      builder.empty(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [vec_set.VecSet<T0>]
      >(inspectRes);
    }
    export async function fromKeys<T0 = any>(
      client: SuiClient,
      args: [(string | TransactionObjectArgument)[] | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[vec_set.VecSet<T0>]>> {
      const tx = new TransactionBlock();
      builder.fromKeys(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [vec_set.VecSet<T0>]
      >(inspectRes);
    }
    export async function insert<T0 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        T0 | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.insert(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function intoKeys<T0 = any>(
      client: SuiClient,
      args: [vec_set.VecSet<T0> | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[T0[] | string]>> {
      const tx = new TransactionBlock();
      builder.intoKeys(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [T0[] | string]
      >(inspectRes);
    }
    export async function isEmpty<T0 = any>(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[Boolean]>> {
      const tx = new TransactionBlock();
      builder.isEmpty(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[Boolean]>(
        inspectRes,
      );
    }
    export async function keys<T0 = any>(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new TransactionBlock();
      builder.keys(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function remove<T0 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.remove(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function singleton<T0 = any>(
      client: SuiClient,
      args: [T0 | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[vec_set.VecSet<T0>]>> {
      const tx = new TransactionBlock();
      builder.singleton(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [vec_set.VecSet<T0>]
      >(inspectRes);
    }
    export async function size<T0 = any>(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new TransactionBlock();
      builder.size(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
  }
}

export namespace versioned {
  export interface VersionChangeCap {
    versioned_id: object_.ID;
    old_version: bigint;
  }

  export namespace VersionChangeCap {
    export const TYPE_QNAME = "0x2::versioned::VersionChangeCap";

    const TYPE = new TypeDescriptor<VersionChangeCap>(
      VersionChangeCap.TYPE_QNAME,
    );

    export function type(): TypeDescriptor<VersionChangeCap> {
      return TYPE.apply();
    }
  }

  export interface Versioned {
    id: object_.UID;
    version: bigint;
  }

  export namespace Versioned {
    export const TYPE_QNAME = "0x2::versioned::Versioned";

    const TYPE = new TypeDescriptor<Versioned>(Versioned.TYPE_QNAME);

    export function type(): TypeDescriptor<Versioned> {
      return TYPE.apply();
    }
  }

  export namespace builder {
    export function create<T0 = any>(
      tx: TransactionBlock,
      args: [bigint | TransactionArgument, T0 | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::versioned::create",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function destroy<T0 = any>(
      tx: TransactionBlock,
      args: [versioned.Versioned | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::versioned::destroy",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function loadValue<T0 = any>(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::versioned::load_value",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function loadValueMut<T0 = any>(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::versioned::load_value_mut",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function removeValueForUpgrade<T0 = any>(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::versioned::remove_value_for_upgrade",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function upgrade<T0 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
        T0 | TransactionArgument,
        versioned.VersionChangeCap | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument &
      [
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
      ] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));
      _args.push(transactionArgumentOrPure(args[2], tx));
      _args.push(transactionArgumentOrPure(args[3], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::versioned::upgrade",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function version(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::versioned::version",
        arguments: _args,
      });
    }
  }
  export namespace view {
    export async function create<T0 = any>(
      client: SuiClient,
      args: [bigint | TransactionArgument, T0 | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[versioned.Versioned]>> {
      const tx = new TransactionBlock();
      builder.create(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [versioned.Versioned]
      >(inspectRes);
    }
    export async function destroy<T0 = any>(
      client: SuiClient,
      args: [versioned.Versioned | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[T0]>> {
      const tx = new TransactionBlock();
      builder.destroy(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[T0]>(
        inspectRes,
      );
    }
    export async function loadValue<T0 = any>(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new TransactionBlock();
      builder.loadValue(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function loadValueMut<T0 = any>(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new TransactionBlock();
      builder.loadValueMut(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function removeValueForUpgrade<T0 = any>(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[T0, versioned.VersionChangeCap]>> {
      const tx = new TransactionBlock();
      builder.removeValueForUpgrade(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [T0, versioned.VersionChangeCap]
      >(inspectRes);
    }
    export async function upgrade<T0 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
        T0 | TransactionArgument,
        versioned.VersionChangeCap | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.upgrade(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function version(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new TransactionBlock();
      builder.version(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
  }
}

export namespace zklogin_verified_id {
  export interface VerifiedID {
    id: object_.UID;
    owner: string;
    key_claim_name: string;
    key_claim_value: string;
    issuer: string;
    audience: string;
  }

  export namespace VerifiedID {
    export const TYPE_QNAME = "0x2::zklogin_verified_id::VerifiedID";

    const TYPE = new TypeDescriptor<VerifiedID>(VerifiedID.TYPE_QNAME);

    export function type(): TypeDescriptor<VerifiedID> {
      return TYPE.apply();
    }
  }

  export namespace builder {
    export function audience(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::zklogin_verified_id::audience",
        arguments: _args,
      });
    }
    export function checkZkloginId(
      tx: TransactionBlock,
      args: [
        string | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
      ],
    ): TransactionArgument &
      [
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
      ] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));
      _args.push(transactionArgumentOrObject(args[2], tx));
      _args.push(transactionArgumentOrObject(args[3], tx));
      _args.push(transactionArgumentOrObject(args[4], tx));
      _args.push(transactionArgumentOrPure(args[5], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::zklogin_verified_id::check_zklogin_id",
        arguments: _args,
      });
    }
    export function delete_(
      tx: TransactionBlock,
      args: [zklogin_verified_id.VerifiedID | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::zklogin_verified_id::delete",
        arguments: _args,
      });
    }
    export function issuer(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::zklogin_verified_id::issuer",
        arguments: _args,
      });
    }
    export function keyClaimName(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::zklogin_verified_id::key_claim_name",
        arguments: _args,
      });
    }
    export function keyClaimValue(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::zklogin_verified_id::key_claim_value",
        arguments: _args,
      });
    }
    export function owner(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::zklogin_verified_id::owner",
        arguments: _args,
      });
    }
    export function verifyZkloginId(
      tx: TransactionBlock,
      args: [
        string | TransactionArgument,
        string | TransactionArgument,
        string | TransactionArgument,
        string | TransactionArgument,
        bigint | TransactionArgument,
      ],
    ): TransactionArgument &
      [
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
      ] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));
      _args.push(transactionArgumentOrPure(args[2], tx));
      _args.push(transactionArgumentOrPure(args[3], tx));
      _args.push(transactionArgumentOrPure(args[4], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::zklogin_verified_id::verify_zklogin_id",
        arguments: _args,
      });
    }
  }
  export namespace view {
    export async function audience(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new TransactionBlock();
      builder.audience(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function checkZkloginId(
      client: SuiClient,
      args: [
        string | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
      ],
    ): Promise<TypedDevInspectResults<[Boolean]>> {
      const tx = new TransactionBlock();
      builder.checkZkloginId(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[Boolean]>(
        inspectRes,
      );
    }
    export async function delete_(
      client: SuiClient,
      args: [zklogin_verified_id.VerifiedID | TransactionArgument],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.delete_(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function issuer(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new TransactionBlock();
      builder.issuer(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function keyClaimName(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new TransactionBlock();
      builder.keyClaimName(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function keyClaimValue(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new TransactionBlock();
      builder.keyClaimValue(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function owner(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new TransactionBlock();
      builder.owner(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function verifyZkloginId(
      client: SuiClient,
      args: [
        string | TransactionArgument,
        string | TransactionArgument,
        string | TransactionArgument,
        string | TransactionArgument,
        bigint | TransactionArgument,
      ],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.verifyZkloginId(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
  }
}

export namespace zklogin_verified_issuer {
  export interface VerifiedIssuer {
    id: object_.UID;
    owner: string;
    issuer: string;
  }

  export namespace VerifiedIssuer {
    export const TYPE_QNAME = "0x2::zklogin_verified_issuer::VerifiedIssuer";

    const TYPE = new TypeDescriptor<VerifiedIssuer>(VerifiedIssuer.TYPE_QNAME);

    export function type(): TypeDescriptor<VerifiedIssuer> {
      return TYPE.apply();
    }
  }

  export namespace builder {
    export function checkZkloginIssuer(
      tx: TransactionBlock,
      args: [
        string | TransactionArgument,
        bigint | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));
      _args.push(transactionArgumentOrObject(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::zklogin_verified_issuer::check_zklogin_issuer",
        arguments: _args,
      });
    }
    export function delete_(
      tx: TransactionBlock,
      args: [zklogin_verified_issuer.VerifiedIssuer | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::zklogin_verified_issuer::delete",
        arguments: _args,
      });
    }
    export function issuer(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::zklogin_verified_issuer::issuer",
        arguments: _args,
      });
    }
    export function owner(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::zklogin_verified_issuer::owner",
        arguments: _args,
      });
    }
    export function verifyZkloginIssuer(
      tx: TransactionBlock,
      args: [bigint | TransactionArgument, string | TransactionArgument],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0x2::zklogin_verified_issuer::verify_zklogin_issuer",
        arguments: _args,
      });
    }
  }
  export namespace view {
    export async function checkZkloginIssuer(
      client: SuiClient,
      args: [
        string | TransactionArgument,
        bigint | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
    ): Promise<TypedDevInspectResults<[Boolean]>> {
      const tx = new TransactionBlock();
      builder.checkZkloginIssuer(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[Boolean]>(
        inspectRes,
      );
    }
    export async function delete_(
      client: SuiClient,
      args: [zklogin_verified_issuer.VerifiedIssuer | TransactionArgument],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.delete_(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function issuer(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new TransactionBlock();
      builder.issuer(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function owner(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new TransactionBlock();
      builder.owner(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function verifyZkloginIssuer(
      client: SuiClient,
      args: [bigint | TransactionArgument, string | TransactionArgument],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.verifyZkloginIssuer(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
  }
}

const MODULES = JSON.parse(
  '{"address":{"fileFormatVersion":6,"address":"0x2","name":"address","friends":[],"structs":{},"exposedFunctions":{"from_ascii_bytes":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Vector":"U8"}}],"return":["Address"]},"from_bytes":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Vector":"U8"}],"return":["Address"]},"from_u256":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U256"],"return":["Address"]},"length":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[],"return":["U64"]},"max":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[],"return":["U256"]},"to_ascii_string":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["Address"],"return":[{"Struct":{"address":"0x1","module":"ascii","name":"String","typeArguments":[]}}]},"to_bytes":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["Address"],"return":[{"Vector":"U8"}]},"to_string":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["Address"],"return":[{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}]},"to_u256":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["Address"],"return":["U256"]}}},"authenticator_state":{"fileFormatVersion":6,"address":"0x2","name":"authenticator_state","friends":[],"structs":{"ActiveJwk":{"abilities":{"abilities":["Copy","Drop","Store"]},"typeParameters":[],"fields":[{"name":"jwk_id","type":{"Struct":{"address":"0x2","module":"authenticator_state","name":"JwkId","typeArguments":[]}}},{"name":"jwk","type":{"Struct":{"address":"0x2","module":"authenticator_state","name":"JWK","typeArguments":[]}}},{"name":"epoch","type":"U64"}]},"AuthenticatorState":{"abilities":{"abilities":["Key"]},"typeParameters":[],"fields":[{"name":"id","type":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}},{"name":"version","type":"U64"}]},"AuthenticatorStateInner":{"abilities":{"abilities":["Store"]},"typeParameters":[],"fields":[{"name":"version","type":"U64"},{"name":"active_jwks","type":{"Vector":{"Struct":{"address":"0x2","module":"authenticator_state","name":"ActiveJwk","typeArguments":[]}}}}]},"JWK":{"abilities":{"abilities":["Copy","Drop","Store"]},"typeParameters":[],"fields":[{"name":"kty","type":{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}},{"name":"e","type":{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}},{"name":"n","type":{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}},{"name":"alg","type":{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}}]},"JwkId":{"abilities":{"abilities":["Copy","Drop","Store"]},"typeParameters":[],"fields":[{"name":"iss","type":{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}},{"name":"kid","type":{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}}]}},"exposedFunctions":{}},"bag":{"fileFormatVersion":6,"address":"0x2","name":"bag","friends":[],"structs":{"Bag":{"abilities":{"abilities":["Store","Key"]},"typeParameters":[],"fields":[{"name":"id","type":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}},{"name":"size","type":"U64"}]}},"exposedFunctions":{"add":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop","Store"]},{"abilities":["Store"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"bag","name":"Bag","typeArguments":[]}}},{"TypeParameter":0},{"TypeParameter":1}],"return":[]},"borrow":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop","Store"]},{"abilities":["Store"]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"bag","name":"Bag","typeArguments":[]}}},{"TypeParameter":0}],"return":[{"Reference":{"TypeParameter":1}}]},"borrow_mut":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop","Store"]},{"abilities":["Store"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"bag","name":"Bag","typeArguments":[]}}},{"TypeParameter":0}],"return":[{"MutableReference":{"TypeParameter":1}}]},"contains":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop","Store"]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"bag","name":"Bag","typeArguments":[]}}},{"TypeParameter":0}],"return":["Bool"]},"contains_with_type":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop","Store"]},{"abilities":["Store"]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"bag","name":"Bag","typeArguments":[]}}},{"TypeParameter":0}],"return":["Bool"]},"destroy_empty":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Struct":{"address":"0x2","module":"bag","name":"Bag","typeArguments":[]}}],"return":[]},"is_empty":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"bag","name":"Bag","typeArguments":[]}}}],"return":["Bool"]},"length":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"bag","name":"Bag","typeArguments":[]}}}],"return":["U64"]},"new":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x2","module":"bag","name":"Bag","typeArguments":[]}}]},"remove":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop","Store"]},{"abilities":["Store"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"bag","name":"Bag","typeArguments":[]}}},{"TypeParameter":0}],"return":[{"TypeParameter":1}]}}},"balance":{"fileFormatVersion":6,"address":"0x2","name":"balance","friends":[{"address":"0x2","name":"sui"}],"structs":{"Balance":{"abilities":{"abilities":["Store"]},"typeParameters":[{"constraints":{"abilities":[]},"isPhantom":true}],"fields":[{"name":"value","type":"U64"}]},"Supply":{"abilities":{"abilities":["Store"]},"typeParameters":[{"constraints":{"abilities":[]},"isPhantom":true}],"fields":[{"name":"value","type":"U64"}]}},"exposedFunctions":{"create_supply":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Drop"]}],"parameters":[{"TypeParameter":0}],"return":[{"Struct":{"address":"0x2","module":"balance","name":"Supply","typeArguments":[{"TypeParameter":0}]}}]},"decrease_supply":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"balance","name":"Supply","typeArguments":[{"TypeParameter":0}]}}},{"Struct":{"address":"0x2","module":"balance","name":"Balance","typeArguments":[{"TypeParameter":0}]}}],"return":["U64"]},"destroy_supply":{"visibility":"Friend","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Struct":{"address":"0x2","module":"balance","name":"Supply","typeArguments":[{"TypeParameter":0}]}}],"return":["U64"]},"destroy_zero":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Struct":{"address":"0x2","module":"balance","name":"Balance","typeArguments":[{"TypeParameter":0}]}}],"return":[]},"increase_supply":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"balance","name":"Supply","typeArguments":[{"TypeParameter":0}]}}},"U64"],"return":[{"Struct":{"address":"0x2","module":"balance","name":"Balance","typeArguments":[{"TypeParameter":0}]}}]},"join":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"balance","name":"Balance","typeArguments":[{"TypeParameter":0}]}}},{"Struct":{"address":"0x2","module":"balance","name":"Balance","typeArguments":[{"TypeParameter":0}]}}],"return":["U64"]},"split":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"balance","name":"Balance","typeArguments":[{"TypeParameter":0}]}}},"U64"],"return":[{"Struct":{"address":"0x2","module":"balance","name":"Balance","typeArguments":[{"TypeParameter":0}]}}]},"supply_value":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"balance","name":"Supply","typeArguments":[{"TypeParameter":0}]}}}],"return":["U64"]},"value":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"balance","name":"Balance","typeArguments":[{"TypeParameter":0}]}}}],"return":["U64"]},"withdraw_all":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"balance","name":"Balance","typeArguments":[{"TypeParameter":0}]}}}],"return":[{"Struct":{"address":"0x2","module":"balance","name":"Balance","typeArguments":[{"TypeParameter":0}]}}]},"zero":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[],"return":[{"Struct":{"address":"0x2","module":"balance","name":"Balance","typeArguments":[{"TypeParameter":0}]}}]}}},"bcs":{"fileFormatVersion":6,"address":"0x2","name":"bcs","friends":[],"structs":{"BCS":{"abilities":{"abilities":["Copy","Drop","Store"]},"typeParameters":[],"fields":[{"name":"bytes","type":{"Vector":"U8"}}]}},"exposedFunctions":{"into_remainder_bytes":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Struct":{"address":"0x2","module":"bcs","name":"BCS","typeArguments":[]}}],"return":[{"Vector":"U8"}]},"new":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Vector":"U8"}],"return":[{"Struct":{"address":"0x2","module":"bcs","name":"BCS","typeArguments":[]}}]},"peel_address":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"bcs","name":"BCS","typeArguments":[]}}}],"return":["Address"]},"peel_bool":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"bcs","name":"BCS","typeArguments":[]}}}],"return":["Bool"]},"peel_option_address":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"bcs","name":"BCS","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":["Address"]}}]},"peel_option_bool":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"bcs","name":"BCS","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":["Bool"]}}]},"peel_option_u128":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"bcs","name":"BCS","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":["U128"]}}]},"peel_option_u64":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"bcs","name":"BCS","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":["U64"]}}]},"peel_option_u8":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"bcs","name":"BCS","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":["U8"]}}]},"peel_u128":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"bcs","name":"BCS","typeArguments":[]}}}],"return":["U128"]},"peel_u256":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"bcs","name":"BCS","typeArguments":[]}}}],"return":["U256"]},"peel_u64":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"bcs","name":"BCS","typeArguments":[]}}}],"return":["U64"]},"peel_u8":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"bcs","name":"BCS","typeArguments":[]}}}],"return":["U8"]},"peel_vec_address":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"bcs","name":"BCS","typeArguments":[]}}}],"return":[{"Vector":"Address"}]},"peel_vec_bool":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"bcs","name":"BCS","typeArguments":[]}}}],"return":[{"Vector":"Bool"}]},"peel_vec_length":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"bcs","name":"BCS","typeArguments":[]}}}],"return":["U64"]},"peel_vec_u128":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"bcs","name":"BCS","typeArguments":[]}}}],"return":[{"Vector":"U128"}]},"peel_vec_u64":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"bcs","name":"BCS","typeArguments":[]}}}],"return":[{"Vector":"U64"}]},"peel_vec_u8":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"bcs","name":"BCS","typeArguments":[]}}}],"return":[{"Vector":"U8"}]},"peel_vec_vec_u8":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"bcs","name":"BCS","typeArguments":[]}}}],"return":[{"Vector":{"Vector":"U8"}}]},"to_bytes":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"TypeParameter":0}}],"return":[{"Vector":"U8"}]}}},"bls12381":{"fileFormatVersion":6,"address":"0x2","name":"bls12381","friends":[],"structs":{"G1":{"abilities":{"abilities":[]},"typeParameters":[],"fields":[{"name":"dummy_field","type":"Bool"}]},"G2":{"abilities":{"abilities":[]},"typeParameters":[],"fields":[{"name":"dummy_field","type":"Bool"}]},"GT":{"abilities":{"abilities":[]},"typeParameters":[],"fields":[{"name":"dummy_field","type":"Bool"}]},"Scalar":{"abilities":{"abilities":[]},"typeParameters":[],"fields":[{"name":"dummy_field","type":"Bool"}]}},"exposedFunctions":{"bls12381_min_pk_verify":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Vector":"U8"}},{"Reference":{"Vector":"U8"}},{"Reference":{"Vector":"U8"}}],"return":["Bool"]},"bls12381_min_sig_verify":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Vector":"U8"}},{"Reference":{"Vector":"U8"}},{"Reference":{"Vector":"U8"}}],"return":["Bool"]},"g1_add":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"G1","typeArguments":[]}}]}}},{"Reference":{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"G1","typeArguments":[]}}]}}}],"return":[{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"G1","typeArguments":[]}}]}}]},"g1_div":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"Scalar","typeArguments":[]}}]}}},{"Reference":{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"G1","typeArguments":[]}}]}}}],"return":[{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"G1","typeArguments":[]}}]}}]},"g1_from_bytes":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Vector":"U8"}}],"return":[{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"G1","typeArguments":[]}}]}}]},"g1_generator":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[],"return":[{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"G1","typeArguments":[]}}]}}]},"g1_identity":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[],"return":[{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"G1","typeArguments":[]}}]}}]},"g1_mul":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"Scalar","typeArguments":[]}}]}}},{"Reference":{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"G1","typeArguments":[]}}]}}}],"return":[{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"G1","typeArguments":[]}}]}}]},"g1_multi_scalar_multiplication":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Vector":{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"Scalar","typeArguments":[]}}]}}}},{"Reference":{"Vector":{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"G1","typeArguments":[]}}]}}}}],"return":[{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"G1","typeArguments":[]}}]}}]},"g1_neg":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"G1","typeArguments":[]}}]}}}],"return":[{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"G1","typeArguments":[]}}]}}]},"g1_sub":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"G1","typeArguments":[]}}]}}},{"Reference":{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"G1","typeArguments":[]}}]}}}],"return":[{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"G1","typeArguments":[]}}]}}]},"g2_add":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"G2","typeArguments":[]}}]}}},{"Reference":{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"G2","typeArguments":[]}}]}}}],"return":[{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"G2","typeArguments":[]}}]}}]},"g2_div":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"Scalar","typeArguments":[]}}]}}},{"Reference":{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"G2","typeArguments":[]}}]}}}],"return":[{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"G2","typeArguments":[]}}]}}]},"g2_from_bytes":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Vector":"U8"}}],"return":[{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"G2","typeArguments":[]}}]}}]},"g2_generator":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[],"return":[{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"G2","typeArguments":[]}}]}}]},"g2_identity":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[],"return":[{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"G2","typeArguments":[]}}]}}]},"g2_mul":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"Scalar","typeArguments":[]}}]}}},{"Reference":{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"G2","typeArguments":[]}}]}}}],"return":[{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"G2","typeArguments":[]}}]}}]},"g2_multi_scalar_multiplication":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Vector":{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"Scalar","typeArguments":[]}}]}}}},{"Reference":{"Vector":{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"G2","typeArguments":[]}}]}}}}],"return":[{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"G2","typeArguments":[]}}]}}]},"g2_neg":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"G2","typeArguments":[]}}]}}}],"return":[{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"G2","typeArguments":[]}}]}}]},"g2_sub":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"G2","typeArguments":[]}}]}}},{"Reference":{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"G2","typeArguments":[]}}]}}}],"return":[{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"G2","typeArguments":[]}}]}}]},"gt_add":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"GT","typeArguments":[]}}]}}},{"Reference":{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"GT","typeArguments":[]}}]}}}],"return":[{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"GT","typeArguments":[]}}]}}]},"gt_div":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"Scalar","typeArguments":[]}}]}}},{"Reference":{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"GT","typeArguments":[]}}]}}}],"return":[{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"GT","typeArguments":[]}}]}}]},"gt_generator":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[],"return":[{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"GT","typeArguments":[]}}]}}]},"gt_identity":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[],"return":[{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"GT","typeArguments":[]}}]}}]},"gt_mul":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"Scalar","typeArguments":[]}}]}}},{"Reference":{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"GT","typeArguments":[]}}]}}}],"return":[{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"GT","typeArguments":[]}}]}}]},"gt_neg":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"GT","typeArguments":[]}}]}}}],"return":[{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"GT","typeArguments":[]}}]}}]},"gt_sub":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"GT","typeArguments":[]}}]}}},{"Reference":{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"GT","typeArguments":[]}}]}}}],"return":[{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"GT","typeArguments":[]}}]}}]},"hash_to_g1":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Vector":"U8"}}],"return":[{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"G1","typeArguments":[]}}]}}]},"hash_to_g2":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Vector":"U8"}}],"return":[{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"G2","typeArguments":[]}}]}}]},"pairing":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"G1","typeArguments":[]}}]}}},{"Reference":{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"G2","typeArguments":[]}}]}}}],"return":[{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"GT","typeArguments":[]}}]}}]},"scalar_add":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"Scalar","typeArguments":[]}}]}}},{"Reference":{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"Scalar","typeArguments":[]}}]}}}],"return":[{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"Scalar","typeArguments":[]}}]}}]},"scalar_div":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"Scalar","typeArguments":[]}}]}}},{"Reference":{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"Scalar","typeArguments":[]}}]}}}],"return":[{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"Scalar","typeArguments":[]}}]}}]},"scalar_from_bytes":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Vector":"U8"}}],"return":[{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"Scalar","typeArguments":[]}}]}}]},"scalar_from_u64":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U64"],"return":[{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"Scalar","typeArguments":[]}}]}}]},"scalar_inv":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"Scalar","typeArguments":[]}}]}}}],"return":[{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"Scalar","typeArguments":[]}}]}}]},"scalar_mul":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"Scalar","typeArguments":[]}}]}}},{"Reference":{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"Scalar","typeArguments":[]}}]}}}],"return":[{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"Scalar","typeArguments":[]}}]}}]},"scalar_neg":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"Scalar","typeArguments":[]}}]}}}],"return":[{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"Scalar","typeArguments":[]}}]}}]},"scalar_one":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[],"return":[{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"Scalar","typeArguments":[]}}]}}]},"scalar_sub":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"Scalar","typeArguments":[]}}]}}},{"Reference":{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"Scalar","typeArguments":[]}}]}}}],"return":[{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"Scalar","typeArguments":[]}}]}}]},"scalar_zero":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[],"return":[{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"Struct":{"address":"0x2","module":"bls12381","name":"Scalar","typeArguments":[]}}]}}]}}},"borrow":{"fileFormatVersion":6,"address":"0x2","name":"borrow","friends":[],"structs":{"Borrow":{"abilities":{"abilities":[]},"typeParameters":[],"fields":[{"name":"ref","type":"Address"},{"name":"obj","type":{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}}]},"Referent":{"abilities":{"abilities":["Store"]},"typeParameters":[{"constraints":{"abilities":["Store","Key"]},"isPhantom":false}],"fields":[{"name":"id","type":"Address"},{"name":"value","type":{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":[{"TypeParameter":0}]}}}]}},"exposedFunctions":{"borrow":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Store","Key"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"borrow","name":"Referent","typeArguments":[{"TypeParameter":0}]}}}],"return":[{"TypeParameter":0},{"Struct":{"address":"0x2","module":"borrow","name":"Borrow","typeArguments":[]}}]},"destroy":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Store","Key"]}],"parameters":[{"Struct":{"address":"0x2","module":"borrow","name":"Referent","typeArguments":[{"TypeParameter":0}]}}],"return":[{"TypeParameter":0}]},"new":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Store","Key"]}],"parameters":[{"TypeParameter":0},{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x2","module":"borrow","name":"Referent","typeArguments":[{"TypeParameter":0}]}}]},"put_back":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Store","Key"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"borrow","name":"Referent","typeArguments":[{"TypeParameter":0}]}}},{"TypeParameter":0},{"Struct":{"address":"0x2","module":"borrow","name":"Borrow","typeArguments":[]}}],"return":[]}}},"clock":{"fileFormatVersion":6,"address":"0x2","name":"clock","friends":[],"structs":{"Clock":{"abilities":{"abilities":["Key"]},"typeParameters":[],"fields":[{"name":"id","type":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}},{"name":"timestamp_ms","type":"U64"}]}},"exposedFunctions":{"timestamp_ms":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"clock","name":"Clock","typeArguments":[]}}}],"return":["U64"]}}},"coin":{"fileFormatVersion":6,"address":"0x2","name":"coin","friends":[],"structs":{"Coin":{"abilities":{"abilities":["Store","Key"]},"typeParameters":[{"constraints":{"abilities":[]},"isPhantom":true}],"fields":[{"name":"id","type":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}},{"name":"balance","type":{"Struct":{"address":"0x2","module":"balance","name":"Balance","typeArguments":[{"TypeParameter":0}]}}}]},"CoinMetadata":{"abilities":{"abilities":["Store","Key"]},"typeParameters":[{"constraints":{"abilities":[]},"isPhantom":true}],"fields":[{"name":"id","type":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}},{"name":"decimals","type":"U8"},{"name":"name","type":{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}},{"name":"symbol","type":{"Struct":{"address":"0x1","module":"ascii","name":"String","typeArguments":[]}}},{"name":"description","type":{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}},{"name":"icon_url","type":{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":[{"Struct":{"address":"0x2","module":"url","name":"Url","typeArguments":[]}}]}}}]},"CurrencyCreated":{"abilities":{"abilities":["Copy","Drop"]},"typeParameters":[{"constraints":{"abilities":[]},"isPhantom":true}],"fields":[{"name":"decimals","type":"U8"}]},"DenyCap":{"abilities":{"abilities":["Store","Key"]},"typeParameters":[{"constraints":{"abilities":[]},"isPhantom":true}],"fields":[{"name":"id","type":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}}]},"RegulatedCoinMetadata":{"abilities":{"abilities":["Key"]},"typeParameters":[{"constraints":{"abilities":[]},"isPhantom":true}],"fields":[{"name":"id","type":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}},{"name":"coin_metadata_object","type":{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}},{"name":"deny_cap_object","type":{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}}]},"TreasuryCap":{"abilities":{"abilities":["Store","Key"]},"typeParameters":[{"constraints":{"abilities":[]},"isPhantom":true}],"fields":[{"name":"id","type":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}},{"name":"total_supply","type":{"Struct":{"address":"0x2","module":"balance","name":"Supply","typeArguments":[{"TypeParameter":0}]}}}]}},"exposedFunctions":{"balance":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"TypeParameter":0}]}}}],"return":[{"Reference":{"Struct":{"address":"0x2","module":"balance","name":"Balance","typeArguments":[{"TypeParameter":0}]}}}]},"balance_mut":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"TypeParameter":0}]}}}],"return":[{"MutableReference":{"Struct":{"address":"0x2","module":"balance","name":"Balance","typeArguments":[{"TypeParameter":0}]}}}]},"burn":{"visibility":"Public","isEntry":true,"typeParameters":[{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"coin","name":"TreasuryCap","typeArguments":[{"TypeParameter":0}]}}},{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"TypeParameter":0}]}}],"return":["U64"]},"create_currency":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Drop"]}],"parameters":[{"TypeParameter":0},"U8",{"Vector":"U8"},{"Vector":"U8"},{"Vector":"U8"},{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":[{"Struct":{"address":"0x2","module":"url","name":"Url","typeArguments":[]}}]}},{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x2","module":"coin","name":"TreasuryCap","typeArguments":[{"TypeParameter":0}]}},{"Struct":{"address":"0x2","module":"coin","name":"CoinMetadata","typeArguments":[{"TypeParameter":0}]}}]},"create_regulated_currency":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Drop"]}],"parameters":[{"TypeParameter":0},"U8",{"Vector":"U8"},{"Vector":"U8"},{"Vector":"U8"},{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":[{"Struct":{"address":"0x2","module":"url","name":"Url","typeArguments":[]}}]}},{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x2","module":"coin","name":"TreasuryCap","typeArguments":[{"TypeParameter":0}]}},{"Struct":{"address":"0x2","module":"coin","name":"DenyCap","typeArguments":[{"TypeParameter":0}]}},{"Struct":{"address":"0x2","module":"coin","name":"CoinMetadata","typeArguments":[{"TypeParameter":0}]}}]},"deny_list_add":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"deny_list","name":"DenyList","typeArguments":[]}}},{"MutableReference":{"Struct":{"address":"0x2","module":"coin","name":"DenyCap","typeArguments":[{"TypeParameter":0}]}}},"Address",{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[]},"deny_list_contains":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"deny_list","name":"DenyList","typeArguments":[]}}},"Address"],"return":["Bool"]},"deny_list_remove":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"deny_list","name":"DenyList","typeArguments":[]}}},{"MutableReference":{"Struct":{"address":"0x2","module":"coin","name":"DenyCap","typeArguments":[{"TypeParameter":0}]}}},"Address",{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[]},"destroy_zero":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"TypeParameter":0}]}}],"return":[]},"divide_into_n":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"TypeParameter":0}]}}},"U64",{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Vector":{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"TypeParameter":0}]}}}]},"from_balance":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Struct":{"address":"0x2","module":"balance","name":"Balance","typeArguments":[{"TypeParameter":0}]}},{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"TypeParameter":0}]}}]},"get_decimals":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"coin","name":"CoinMetadata","typeArguments":[{"TypeParameter":0}]}}}],"return":["U8"]},"get_description":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"coin","name":"CoinMetadata","typeArguments":[{"TypeParameter":0}]}}}],"return":[{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}]},"get_icon_url":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"coin","name":"CoinMetadata","typeArguments":[{"TypeParameter":0}]}}}],"return":[{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":[{"Struct":{"address":"0x2","module":"url","name":"Url","typeArguments":[]}}]}}]},"get_name":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"coin","name":"CoinMetadata","typeArguments":[{"TypeParameter":0}]}}}],"return":[{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}]},"get_symbol":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"coin","name":"CoinMetadata","typeArguments":[{"TypeParameter":0}]}}}],"return":[{"Struct":{"address":"0x1","module":"ascii","name":"String","typeArguments":[]}}]},"into_balance":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"TypeParameter":0}]}}],"return":[{"Struct":{"address":"0x2","module":"balance","name":"Balance","typeArguments":[{"TypeParameter":0}]}}]},"join":{"visibility":"Public","isEntry":true,"typeParameters":[{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"TypeParameter":0}]}}},{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"TypeParameter":0}]}}],"return":[]},"mint":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"coin","name":"TreasuryCap","typeArguments":[{"TypeParameter":0}]}}},"U64",{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"TypeParameter":0}]}}]},"mint_and_transfer":{"visibility":"Public","isEntry":true,"typeParameters":[{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"coin","name":"TreasuryCap","typeArguments":[{"TypeParameter":0}]}}},"U64","Address",{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[]},"mint_balance":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"coin","name":"TreasuryCap","typeArguments":[{"TypeParameter":0}]}}},"U64"],"return":[{"Struct":{"address":"0x2","module":"balance","name":"Balance","typeArguments":[{"TypeParameter":0}]}}]},"put":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"balance","name":"Balance","typeArguments":[{"TypeParameter":0}]}}},{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"TypeParameter":0}]}}],"return":[]},"split":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"TypeParameter":0}]}}},"U64",{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"TypeParameter":0}]}}]},"supply":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"coin","name":"TreasuryCap","typeArguments":[{"TypeParameter":0}]}}}],"return":[{"Reference":{"Struct":{"address":"0x2","module":"balance","name":"Supply","typeArguments":[{"TypeParameter":0}]}}}]},"supply_immut":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"coin","name":"TreasuryCap","typeArguments":[{"TypeParameter":0}]}}}],"return":[{"Reference":{"Struct":{"address":"0x2","module":"balance","name":"Supply","typeArguments":[{"TypeParameter":0}]}}}]},"supply_mut":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"coin","name":"TreasuryCap","typeArguments":[{"TypeParameter":0}]}}}],"return":[{"MutableReference":{"Struct":{"address":"0x2","module":"balance","name":"Supply","typeArguments":[{"TypeParameter":0}]}}}]},"take":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"balance","name":"Balance","typeArguments":[{"TypeParameter":0}]}}},"U64",{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"TypeParameter":0}]}}]},"total_supply":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"coin","name":"TreasuryCap","typeArguments":[{"TypeParameter":0}]}}}],"return":["U64"]},"treasury_into_supply":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Struct":{"address":"0x2","module":"coin","name":"TreasuryCap","typeArguments":[{"TypeParameter":0}]}}],"return":[{"Struct":{"address":"0x2","module":"balance","name":"Supply","typeArguments":[{"TypeParameter":0}]}}]},"update_description":{"visibility":"Public","isEntry":true,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"coin","name":"TreasuryCap","typeArguments":[{"TypeParameter":0}]}}},{"MutableReference":{"Struct":{"address":"0x2","module":"coin","name":"CoinMetadata","typeArguments":[{"TypeParameter":0}]}}},{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}],"return":[]},"update_icon_url":{"visibility":"Public","isEntry":true,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"coin","name":"TreasuryCap","typeArguments":[{"TypeParameter":0}]}}},{"MutableReference":{"Struct":{"address":"0x2","module":"coin","name":"CoinMetadata","typeArguments":[{"TypeParameter":0}]}}},{"Struct":{"address":"0x1","module":"ascii","name":"String","typeArguments":[]}}],"return":[]},"update_name":{"visibility":"Public","isEntry":true,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"coin","name":"TreasuryCap","typeArguments":[{"TypeParameter":0}]}}},{"MutableReference":{"Struct":{"address":"0x2","module":"coin","name":"CoinMetadata","typeArguments":[{"TypeParameter":0}]}}},{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}],"return":[]},"update_symbol":{"visibility":"Public","isEntry":true,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"coin","name":"TreasuryCap","typeArguments":[{"TypeParameter":0}]}}},{"MutableReference":{"Struct":{"address":"0x2","module":"coin","name":"CoinMetadata","typeArguments":[{"TypeParameter":0}]}}},{"Struct":{"address":"0x1","module":"ascii","name":"String","typeArguments":[]}}],"return":[]},"value":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"TypeParameter":0}]}}}],"return":["U64"]},"zero":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"TypeParameter":0}]}}]}}},"deny_list":{"fileFormatVersion":6,"address":"0x2","name":"deny_list","friends":[{"address":"0x2","name":"coin"}],"structs":{"DenyList":{"abilities":{"abilities":["Key"]},"typeParameters":[],"fields":[{"name":"id","type":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}},{"name":"lists","type":{"Struct":{"address":"0x2","module":"bag","name":"Bag","typeArguments":[]}}}]},"PerTypeList":{"abilities":{"abilities":["Store","Key"]},"typeParameters":[],"fields":[{"name":"id","type":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}},{"name":"denied_count","type":{"Struct":{"address":"0x2","module":"table","name":"Table","typeArguments":["Address","U64"]}}},{"name":"denied_addresses","type":{"Struct":{"address":"0x2","module":"table","name":"Table","typeArguments":[{"Vector":"U8"},{"Struct":{"address":"0x2","module":"vec_set","name":"VecSet","typeArguments":["Address"]}}]}}}]}},"exposedFunctions":{"add":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"deny_list","name":"DenyList","typeArguments":[]}}},"U64",{"Vector":"U8"},"Address"],"return":[]},"contains":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"deny_list","name":"DenyList","typeArguments":[]}}},"U64",{"Vector":"U8"},"Address"],"return":["Bool"]},"remove":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"deny_list","name":"DenyList","typeArguments":[]}}},"U64",{"Vector":"U8"},"Address"],"return":[]}}},"display":{"fileFormatVersion":6,"address":"0x2","name":"display","friends":[],"structs":{"Display":{"abilities":{"abilities":["Store","Key"]},"typeParameters":[{"constraints":{"abilities":["Key"]},"isPhantom":true}],"fields":[{"name":"id","type":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}},{"name":"fields","type":{"Struct":{"address":"0x2","module":"vec_map","name":"VecMap","typeArguments":[{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}},{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}]}}},{"name":"version","type":"U16"}]},"DisplayCreated":{"abilities":{"abilities":["Copy","Drop"]},"typeParameters":[{"constraints":{"abilities":["Key"]},"isPhantom":true}],"fields":[{"name":"id","type":{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}}]},"VersionUpdated":{"abilities":{"abilities":["Copy","Drop"]},"typeParameters":[{"constraints":{"abilities":["Key"]},"isPhantom":true}],"fields":[{"name":"id","type":{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}},{"name":"version","type":"U16"},{"name":"fields","type":{"Struct":{"address":"0x2","module":"vec_map","name":"VecMap","typeArguments":[{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}},{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}]}}}]}},"exposedFunctions":{"add":{"visibility":"Public","isEntry":true,"typeParameters":[{"abilities":["Key"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"display","name":"Display","typeArguments":[{"TypeParameter":0}]}}},{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}},{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}],"return":[]},"add_multiple":{"visibility":"Public","isEntry":true,"typeParameters":[{"abilities":["Key"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"display","name":"Display","typeArguments":[{"TypeParameter":0}]}}},{"Vector":{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}},{"Vector":{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}}],"return":[]},"create_and_keep":{"visibility":"Public","isEntry":true,"typeParameters":[{"abilities":["Key"]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"package","name":"Publisher","typeArguments":[]}}},{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[]},"edit":{"visibility":"Public","isEntry":true,"typeParameters":[{"abilities":["Key"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"display","name":"Display","typeArguments":[{"TypeParameter":0}]}}},{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}},{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}],"return":[]},"fields":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Key"]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"display","name":"Display","typeArguments":[{"TypeParameter":0}]}}}],"return":[{"Reference":{"Struct":{"address":"0x2","module":"vec_map","name":"VecMap","typeArguments":[{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}},{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}]}}}]},"is_authorized":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Key"]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"package","name":"Publisher","typeArguments":[]}}}],"return":["Bool"]},"new":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Key"]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"package","name":"Publisher","typeArguments":[]}}},{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x2","module":"display","name":"Display","typeArguments":[{"TypeParameter":0}]}}]},"new_with_fields":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Key"]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"package","name":"Publisher","typeArguments":[]}}},{"Vector":{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}},{"Vector":{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}},{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x2","module":"display","name":"Display","typeArguments":[{"TypeParameter":0}]}}]},"remove":{"visibility":"Public","isEntry":true,"typeParameters":[{"abilities":["Key"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"display","name":"Display","typeArguments":[{"TypeParameter":0}]}}},{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}],"return":[]},"update_version":{"visibility":"Public","isEntry":true,"typeParameters":[{"abilities":["Key"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"display","name":"Display","typeArguments":[{"TypeParameter":0}]}}}],"return":[]},"version":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Key"]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"display","name":"Display","typeArguments":[{"TypeParameter":0}]}}}],"return":["U16"]}}},"dynamic_field":{"fileFormatVersion":6,"address":"0x2","name":"dynamic_field","friends":[{"address":"0x2","name":"dynamic_object_field"}],"structs":{"Field":{"abilities":{"abilities":["Key"]},"typeParameters":[{"constraints":{"abilities":["Copy","Drop","Store"]},"isPhantom":false},{"constraints":{"abilities":["Store"]},"isPhantom":false}],"fields":[{"name":"id","type":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}},{"name":"name","type":{"TypeParameter":0}},{"name":"value","type":{"TypeParameter":1}}]}},"exposedFunctions":{"add":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop","Store"]},{"abilities":["Store"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}},{"TypeParameter":0},{"TypeParameter":1}],"return":[]},"add_child_object":{"visibility":"Friend","isEntry":false,"typeParameters":[{"abilities":["Key"]}],"parameters":["Address",{"TypeParameter":0}],"return":[]},"borrow":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop","Store"]},{"abilities":["Store"]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}},{"TypeParameter":0}],"return":[{"Reference":{"TypeParameter":1}}]},"borrow_child_object":{"visibility":"Friend","isEntry":false,"typeParameters":[{"abilities":["Key"]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}},"Address"],"return":[{"Reference":{"TypeParameter":0}}]},"borrow_child_object_mut":{"visibility":"Friend","isEntry":false,"typeParameters":[{"abilities":["Key"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}},"Address"],"return":[{"MutableReference":{"TypeParameter":0}}]},"borrow_mut":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop","Store"]},{"abilities":["Store"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}},{"TypeParameter":0}],"return":[{"MutableReference":{"TypeParameter":1}}]},"exists_":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop","Store"]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}},{"TypeParameter":0}],"return":["Bool"]},"exists_with_type":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop","Store"]},{"abilities":["Store"]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}},{"TypeParameter":0}],"return":["Bool"]},"field_info":{"visibility":"Friend","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop","Store"]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}},{"TypeParameter":0}],"return":[{"Reference":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}},"Address"]},"field_info_mut":{"visibility":"Friend","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop","Store"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}},{"TypeParameter":0}],"return":[{"MutableReference":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}},"Address"]},"has_child_object":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":["Address","Address"],"return":["Bool"]},"has_child_object_with_ty":{"visibility":"Friend","isEntry":false,"typeParameters":[{"abilities":["Key"]}],"parameters":["Address","Address"],"return":["Bool"]},"hash_type_and_key":{"visibility":"Friend","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop","Store"]}],"parameters":["Address",{"TypeParameter":0}],"return":["Address"]},"remove":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop","Store"]},{"abilities":["Store"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}},{"TypeParameter":0}],"return":[{"TypeParameter":1}]},"remove_child_object":{"visibility":"Friend","isEntry":false,"typeParameters":[{"abilities":["Key"]}],"parameters":["Address","Address"],"return":[{"TypeParameter":0}]},"remove_if_exists":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop","Store"]},{"abilities":["Store"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}},{"TypeParameter":0}],"return":[{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":[{"TypeParameter":1}]}}]}}},"dynamic_object_field":{"fileFormatVersion":6,"address":"0x2","name":"dynamic_object_field","friends":[],"structs":{"Wrapper":{"abilities":{"abilities":["Copy","Drop","Store"]},"typeParameters":[{"constraints":{"abilities":[]},"isPhantom":false}],"fields":[{"name":"name","type":{"TypeParameter":0}}]}},"exposedFunctions":{"add":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop","Store"]},{"abilities":["Store","Key"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}},{"TypeParameter":0},{"TypeParameter":1}],"return":[]},"borrow":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop","Store"]},{"abilities":["Store","Key"]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}},{"TypeParameter":0}],"return":[{"Reference":{"TypeParameter":1}}]},"borrow_mut":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop","Store"]},{"abilities":["Store","Key"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}},{"TypeParameter":0}],"return":[{"MutableReference":{"TypeParameter":1}}]},"exists_":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop","Store"]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}},{"TypeParameter":0}],"return":["Bool"]},"exists_with_type":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop","Store"]},{"abilities":["Store","Key"]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}},{"TypeParameter":0}],"return":["Bool"]},"id":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop","Store"]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}},{"TypeParameter":0}],"return":[{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":[{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}]}}]},"remove":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop","Store"]},{"abilities":["Store","Key"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}},{"TypeParameter":0}],"return":[{"TypeParameter":1}]}}},"ecdsa_k1":{"fileFormatVersion":6,"address":"0x2","name":"ecdsa_k1","friends":[],"structs":{},"exposedFunctions":{"decompress_pubkey":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Vector":"U8"}}],"return":[{"Vector":"U8"}]},"secp256k1_ecrecover":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Vector":"U8"}},{"Reference":{"Vector":"U8"}},"U8"],"return":[{"Vector":"U8"}]},"secp256k1_verify":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Vector":"U8"}},{"Reference":{"Vector":"U8"}},{"Reference":{"Vector":"U8"}},"U8"],"return":["Bool"]}}},"ecdsa_r1":{"fileFormatVersion":6,"address":"0x2","name":"ecdsa_r1","friends":[],"structs":{},"exposedFunctions":{"secp256r1_ecrecover":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Vector":"U8"}},{"Reference":{"Vector":"U8"}},"U8"],"return":[{"Vector":"U8"}]},"secp256r1_verify":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Vector":"U8"}},{"Reference":{"Vector":"U8"}},{"Reference":{"Vector":"U8"}},"U8"],"return":["Bool"]}}},"ecvrf":{"fileFormatVersion":6,"address":"0x2","name":"ecvrf","friends":[],"structs":{},"exposedFunctions":{"ecvrf_verify":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Vector":"U8"}},{"Reference":{"Vector":"U8"}},{"Reference":{"Vector":"U8"}},{"Reference":{"Vector":"U8"}}],"return":["Bool"]}}},"ed25519":{"fileFormatVersion":6,"address":"0x2","name":"ed25519","friends":[],"structs":{},"exposedFunctions":{"ed25519_verify":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Vector":"U8"}},{"Reference":{"Vector":"U8"}},{"Reference":{"Vector":"U8"}}],"return":["Bool"]}}},"event":{"fileFormatVersion":6,"address":"0x2","name":"event","friends":[],"structs":{},"exposedFunctions":{"emit":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop"]}],"parameters":[{"TypeParameter":0}],"return":[]}}},"groth16":{"fileFormatVersion":6,"address":"0x2","name":"groth16","friends":[],"structs":{"Curve":{"abilities":{"abilities":["Copy","Drop","Store"]},"typeParameters":[],"fields":[{"name":"id","type":"U8"}]},"PreparedVerifyingKey":{"abilities":{"abilities":["Copy","Drop","Store"]},"typeParameters":[],"fields":[{"name":"vk_gamma_abc_g1_bytes","type":{"Vector":"U8"}},{"name":"alpha_g1_beta_g2_bytes","type":{"Vector":"U8"}},{"name":"gamma_g2_neg_pc_bytes","type":{"Vector":"U8"}},{"name":"delta_g2_neg_pc_bytes","type":{"Vector":"U8"}}]},"ProofPoints":{"abilities":{"abilities":["Copy","Drop","Store"]},"typeParameters":[],"fields":[{"name":"bytes","type":{"Vector":"U8"}}]},"PublicProofInputs":{"abilities":{"abilities":["Copy","Drop","Store"]},"typeParameters":[],"fields":[{"name":"bytes","type":{"Vector":"U8"}}]}},"exposedFunctions":{"bls12381":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[],"return":[{"Struct":{"address":"0x2","module":"groth16","name":"Curve","typeArguments":[]}}]},"bn254":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[],"return":[{"Struct":{"address":"0x2","module":"groth16","name":"Curve","typeArguments":[]}}]},"prepare_verifying_key":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"groth16","name":"Curve","typeArguments":[]}}},{"Reference":{"Vector":"U8"}}],"return":[{"Struct":{"address":"0x2","module":"groth16","name":"PreparedVerifyingKey","typeArguments":[]}}]},"proof_points_from_bytes":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Vector":"U8"}],"return":[{"Struct":{"address":"0x2","module":"groth16","name":"ProofPoints","typeArguments":[]}}]},"public_proof_inputs_from_bytes":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Vector":"U8"}],"return":[{"Struct":{"address":"0x2","module":"groth16","name":"PublicProofInputs","typeArguments":[]}}]},"pvk_from_bytes":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Vector":"U8"},{"Vector":"U8"},{"Vector":"U8"},{"Vector":"U8"}],"return":[{"Struct":{"address":"0x2","module":"groth16","name":"PreparedVerifyingKey","typeArguments":[]}}]},"pvk_to_bytes":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Struct":{"address":"0x2","module":"groth16","name":"PreparedVerifyingKey","typeArguments":[]}}],"return":[{"Vector":{"Vector":"U8"}}]},"verify_groth16_proof":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"groth16","name":"Curve","typeArguments":[]}}},{"Reference":{"Struct":{"address":"0x2","module":"groth16","name":"PreparedVerifyingKey","typeArguments":[]}}},{"Reference":{"Struct":{"address":"0x2","module":"groth16","name":"PublicProofInputs","typeArguments":[]}}},{"Reference":{"Struct":{"address":"0x2","module":"groth16","name":"ProofPoints","typeArguments":[]}}}],"return":["Bool"]}}},"group_ops":{"fileFormatVersion":6,"address":"0x2","name":"group_ops","friends":[{"address":"0x2","name":"bls12381"}],"structs":{"Element":{"abilities":{"abilities":["Copy","Drop","Store"]},"typeParameters":[{"constraints":{"abilities":[]},"isPhantom":true}],"fields":[{"name":"bytes","type":{"Vector":"U8"}}]}},"exposedFunctions":{"add":{"visibility":"Friend","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":["U8",{"Reference":{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"TypeParameter":0}]}}},{"Reference":{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"TypeParameter":0}]}}}],"return":[{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"TypeParameter":0}]}}]},"bytes":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"TypeParameter":0}]}}}],"return":[{"Reference":{"Vector":"U8"}}]},"div":{"visibility":"Friend","isEntry":false,"typeParameters":[{"abilities":[]},{"abilities":[]}],"parameters":["U8",{"Reference":{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"TypeParameter":0}]}}},{"Reference":{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"TypeParameter":1}]}}}],"return":[{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"TypeParameter":1}]}}]},"equal":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"TypeParameter":0}]}}},{"Reference":{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"TypeParameter":0}]}}}],"return":["Bool"]},"from_bytes":{"visibility":"Friend","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":["U8",{"Reference":{"Vector":"U8"}},"Bool"],"return":[{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"TypeParameter":0}]}}]},"hash_to":{"visibility":"Friend","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":["U8",{"Reference":{"Vector":"U8"}}],"return":[{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"TypeParameter":0}]}}]},"mul":{"visibility":"Friend","isEntry":false,"typeParameters":[{"abilities":[]},{"abilities":[]}],"parameters":["U8",{"Reference":{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"TypeParameter":0}]}}},{"Reference":{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"TypeParameter":1}]}}}],"return":[{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"TypeParameter":1}]}}]},"multi_scalar_multiplication":{"visibility":"Friend","isEntry":false,"typeParameters":[{"abilities":[]},{"abilities":[]}],"parameters":["U8",{"Reference":{"Vector":{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"TypeParameter":0}]}}}},{"Reference":{"Vector":{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"TypeParameter":1}]}}}}],"return":[{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"TypeParameter":1}]}}]},"pairing":{"visibility":"Friend","isEntry":false,"typeParameters":[{"abilities":[]},{"abilities":[]},{"abilities":[]}],"parameters":["U8",{"Reference":{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"TypeParameter":0}]}}},{"Reference":{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"TypeParameter":1}]}}}],"return":[{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"TypeParameter":2}]}}]},"set_as_prefix":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":["U64","Bool",{"MutableReference":{"Vector":"U8"}}],"return":[]},"sub":{"visibility":"Friend","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":["U8",{"Reference":{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"TypeParameter":0}]}}},{"Reference":{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"TypeParameter":0}]}}}],"return":[{"Struct":{"address":"0x2","module":"group_ops","name":"Element","typeArguments":[{"TypeParameter":0}]}}]}}},"hash":{"fileFormatVersion":6,"address":"0x2","name":"hash","friends":[],"structs":{},"exposedFunctions":{"blake2b256":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Vector":"U8"}}],"return":[{"Vector":"U8"}]},"keccak256":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Vector":"U8"}}],"return":[{"Vector":"U8"}]}}},"hex":{"fileFormatVersion":6,"address":"0x2","name":"hex","friends":[],"structs":{},"exposedFunctions":{"decode":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Vector":"U8"}],"return":[{"Vector":"U8"}]},"encode":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Vector":"U8"}],"return":[{"Vector":"U8"}]}}},"hmac":{"fileFormatVersion":6,"address":"0x2","name":"hmac","friends":[],"structs":{},"exposedFunctions":{"hmac_sha3_256":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Vector":"U8"}},{"Reference":{"Vector":"U8"}}],"return":[{"Vector":"U8"}]}}},"kiosk":{"fileFormatVersion":6,"address":"0x2","name":"kiosk","friends":[{"address":"0x2","name":"kiosk_extension"}],"structs":{"Borrow":{"abilities":{"abilities":[]},"typeParameters":[],"fields":[{"name":"kiosk_id","type":{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}},{"name":"item_id","type":{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}}]},"Item":{"abilities":{"abilities":["Copy","Drop","Store"]},"typeParameters":[],"fields":[{"name":"id","type":{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}}]},"ItemDelisted":{"abilities":{"abilities":["Copy","Drop"]},"typeParameters":[{"constraints":{"abilities":["Store","Key"]},"isPhantom":true}],"fields":[{"name":"kiosk","type":{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}},{"name":"id","type":{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}}]},"ItemListed":{"abilities":{"abilities":["Copy","Drop"]},"typeParameters":[{"constraints":{"abilities":["Store","Key"]},"isPhantom":true}],"fields":[{"name":"kiosk","type":{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}},{"name":"id","type":{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}},{"name":"price","type":"U64"}]},"ItemPurchased":{"abilities":{"abilities":["Copy","Drop"]},"typeParameters":[{"constraints":{"abilities":["Store","Key"]},"isPhantom":true}],"fields":[{"name":"kiosk","type":{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}},{"name":"id","type":{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}},{"name":"price","type":"U64"}]},"Kiosk":{"abilities":{"abilities":["Store","Key"]},"typeParameters":[],"fields":[{"name":"id","type":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}},{"name":"profits","type":{"Struct":{"address":"0x2","module":"balance","name":"Balance","typeArguments":[{"Struct":{"address":"0x2","module":"sui","name":"SUI","typeArguments":[]}}]}}},{"name":"owner","type":"Address"},{"name":"item_count","type":"U32"},{"name":"allow_extensions","type":"Bool"}]},"KioskOwnerCap":{"abilities":{"abilities":["Store","Key"]},"typeParameters":[],"fields":[{"name":"id","type":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}},{"name":"for","type":{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}}]},"Listing":{"abilities":{"abilities":["Copy","Drop","Store"]},"typeParameters":[],"fields":[{"name":"id","type":{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}},{"name":"is_exclusive","type":"Bool"}]},"Lock":{"abilities":{"abilities":["Copy","Drop","Store"]},"typeParameters":[],"fields":[{"name":"id","type":{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}}]},"PurchaseCap":{"abilities":{"abilities":["Store","Key"]},"typeParameters":[{"constraints":{"abilities":["Store","Key"]},"isPhantom":true}],"fields":[{"name":"id","type":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}},{"name":"kiosk_id","type":{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}},{"name":"item_id","type":{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}},{"name":"min_price","type":"U64"}]}},"exposedFunctions":{"borrow":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Store","Key"]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"kiosk","name":"Kiosk","typeArguments":[]}}},{"Reference":{"Struct":{"address":"0x2","module":"kiosk","name":"KioskOwnerCap","typeArguments":[]}}},{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}],"return":[{"Reference":{"TypeParameter":0}}]},"borrow_mut":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Store","Key"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"kiosk","name":"Kiosk","typeArguments":[]}}},{"Reference":{"Struct":{"address":"0x2","module":"kiosk","name":"KioskOwnerCap","typeArguments":[]}}},{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}],"return":[{"MutableReference":{"TypeParameter":0}}]},"borrow_val":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Store","Key"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"kiosk","name":"Kiosk","typeArguments":[]}}},{"Reference":{"Struct":{"address":"0x2","module":"kiosk","name":"KioskOwnerCap","typeArguments":[]}}},{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}],"return":[{"TypeParameter":0},{"Struct":{"address":"0x2","module":"kiosk","name":"Borrow","typeArguments":[]}}]},"close_and_withdraw":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Struct":{"address":"0x2","module":"kiosk","name":"Kiosk","typeArguments":[]}},{"Struct":{"address":"0x2","module":"kiosk","name":"KioskOwnerCap","typeArguments":[]}},{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"Struct":{"address":"0x2","module":"sui","name":"SUI","typeArguments":[]}}]}}]},"default":{"visibility":"Private","isEntry":true,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[]},"delist":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Store","Key"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"kiosk","name":"Kiosk","typeArguments":[]}}},{"Reference":{"Struct":{"address":"0x2","module":"kiosk","name":"KioskOwnerCap","typeArguments":[]}}},{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}],"return":[]},"has_access":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"kiosk","name":"Kiosk","typeArguments":[]}}},{"Reference":{"Struct":{"address":"0x2","module":"kiosk","name":"KioskOwnerCap","typeArguments":[]}}}],"return":["Bool"]},"has_item":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"kiosk","name":"Kiosk","typeArguments":[]}}},{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}],"return":["Bool"]},"has_item_with_type":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Store","Key"]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"kiosk","name":"Kiosk","typeArguments":[]}}},{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}],"return":["Bool"]},"is_listed":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"kiosk","name":"Kiosk","typeArguments":[]}}},{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}],"return":["Bool"]},"is_listed_exclusively":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"kiosk","name":"Kiosk","typeArguments":[]}}},{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}],"return":["Bool"]},"is_locked":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"kiosk","name":"Kiosk","typeArguments":[]}}},{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}],"return":["Bool"]},"item_count":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"kiosk","name":"Kiosk","typeArguments":[]}}}],"return":["U32"]},"kiosk_owner_cap_for":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"kiosk","name":"KioskOwnerCap","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}]},"list":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Store","Key"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"kiosk","name":"Kiosk","typeArguments":[]}}},{"Reference":{"Struct":{"address":"0x2","module":"kiosk","name":"KioskOwnerCap","typeArguments":[]}}},{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}},"U64"],"return":[]},"list_with_purchase_cap":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Store","Key"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"kiosk","name":"Kiosk","typeArguments":[]}}},{"Reference":{"Struct":{"address":"0x2","module":"kiosk","name":"KioskOwnerCap","typeArguments":[]}}},{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}},"U64",{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x2","module":"kiosk","name":"PurchaseCap","typeArguments":[{"TypeParameter":0}]}}]},"lock":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Store","Key"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"kiosk","name":"Kiosk","typeArguments":[]}}},{"Reference":{"Struct":{"address":"0x2","module":"kiosk","name":"KioskOwnerCap","typeArguments":[]}}},{"Reference":{"Struct":{"address":"0x2","module":"transfer_policy","name":"TransferPolicy","typeArguments":[{"TypeParameter":0}]}}},{"TypeParameter":0}],"return":[]},"lock_internal":{"visibility":"Friend","isEntry":false,"typeParameters":[{"abilities":["Store","Key"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"kiosk","name":"Kiosk","typeArguments":[]}}},{"TypeParameter":0}],"return":[]},"new":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x2","module":"kiosk","name":"Kiosk","typeArguments":[]}},{"Struct":{"address":"0x2","module":"kiosk","name":"KioskOwnerCap","typeArguments":[]}}]},"owner":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"kiosk","name":"Kiosk","typeArguments":[]}}}],"return":["Address"]},"place":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Store","Key"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"kiosk","name":"Kiosk","typeArguments":[]}}},{"Reference":{"Struct":{"address":"0x2","module":"kiosk","name":"KioskOwnerCap","typeArguments":[]}}},{"TypeParameter":0}],"return":[]},"place_and_list":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Store","Key"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"kiosk","name":"Kiosk","typeArguments":[]}}},{"Reference":{"Struct":{"address":"0x2","module":"kiosk","name":"KioskOwnerCap","typeArguments":[]}}},{"TypeParameter":0},"U64"],"return":[]},"place_internal":{"visibility":"Friend","isEntry":false,"typeParameters":[{"abilities":["Store","Key"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"kiosk","name":"Kiosk","typeArguments":[]}}},{"TypeParameter":0}],"return":[]},"profits_amount":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"kiosk","name":"Kiosk","typeArguments":[]}}}],"return":["U64"]},"profits_mut":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"kiosk","name":"Kiosk","typeArguments":[]}}},{"Reference":{"Struct":{"address":"0x2","module":"kiosk","name":"KioskOwnerCap","typeArguments":[]}}}],"return":[{"MutableReference":{"Struct":{"address":"0x2","module":"balance","name":"Balance","typeArguments":[{"Struct":{"address":"0x2","module":"sui","name":"SUI","typeArguments":[]}}]}}}]},"purchase":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Store","Key"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"kiosk","name":"Kiosk","typeArguments":[]}}},{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}},{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"Struct":{"address":"0x2","module":"sui","name":"SUI","typeArguments":[]}}]}}],"return":[{"TypeParameter":0},{"Struct":{"address":"0x2","module":"transfer_policy","name":"TransferRequest","typeArguments":[{"TypeParameter":0}]}}]},"purchase_cap_item":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Store","Key"]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"kiosk","name":"PurchaseCap","typeArguments":[{"TypeParameter":0}]}}}],"return":[{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}]},"purchase_cap_kiosk":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Store","Key"]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"kiosk","name":"PurchaseCap","typeArguments":[{"TypeParameter":0}]}}}],"return":[{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}]},"purchase_cap_min_price":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Store","Key"]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"kiosk","name":"PurchaseCap","typeArguments":[{"TypeParameter":0}]}}}],"return":["U64"]},"purchase_with_cap":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Store","Key"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"kiosk","name":"Kiosk","typeArguments":[]}}},{"Struct":{"address":"0x2","module":"kiosk","name":"PurchaseCap","typeArguments":[{"TypeParameter":0}]}},{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"Struct":{"address":"0x2","module":"sui","name":"SUI","typeArguments":[]}}]}}],"return":[{"TypeParameter":0},{"Struct":{"address":"0x2","module":"transfer_policy","name":"TransferRequest","typeArguments":[{"TypeParameter":0}]}}]},"return_purchase_cap":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Store","Key"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"kiosk","name":"Kiosk","typeArguments":[]}}},{"Struct":{"address":"0x2","module":"kiosk","name":"PurchaseCap","typeArguments":[{"TypeParameter":0}]}}],"return":[]},"return_val":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Store","Key"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"kiosk","name":"Kiosk","typeArguments":[]}}},{"TypeParameter":0},{"Struct":{"address":"0x2","module":"kiosk","name":"Borrow","typeArguments":[]}}],"return":[]},"set_allow_extensions":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"kiosk","name":"Kiosk","typeArguments":[]}}},{"Reference":{"Struct":{"address":"0x2","module":"kiosk","name":"KioskOwnerCap","typeArguments":[]}}},"Bool"],"return":[]},"set_owner":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"kiosk","name":"Kiosk","typeArguments":[]}}},{"Reference":{"Struct":{"address":"0x2","module":"kiosk","name":"KioskOwnerCap","typeArguments":[]}}},{"Reference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[]},"set_owner_custom":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"kiosk","name":"Kiosk","typeArguments":[]}}},{"Reference":{"Struct":{"address":"0x2","module":"kiosk","name":"KioskOwnerCap","typeArguments":[]}}},"Address"],"return":[]},"take":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Store","Key"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"kiosk","name":"Kiosk","typeArguments":[]}}},{"Reference":{"Struct":{"address":"0x2","module":"kiosk","name":"KioskOwnerCap","typeArguments":[]}}},{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}],"return":[{"TypeParameter":0}]},"uid":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"kiosk","name":"Kiosk","typeArguments":[]}}}],"return":[{"Reference":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}}]},"uid_mut":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"kiosk","name":"Kiosk","typeArguments":[]}}}],"return":[{"MutableReference":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}}]},"uid_mut_as_owner":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"kiosk","name":"Kiosk","typeArguments":[]}}},{"Reference":{"Struct":{"address":"0x2","module":"kiosk","name":"KioskOwnerCap","typeArguments":[]}}}],"return":[{"MutableReference":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}}]},"uid_mut_internal":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"kiosk","name":"Kiosk","typeArguments":[]}}}],"return":[{"MutableReference":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}}]},"withdraw":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"kiosk","name":"Kiosk","typeArguments":[]}}},{"Reference":{"Struct":{"address":"0x2","module":"kiosk","name":"KioskOwnerCap","typeArguments":[]}}},{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":["U64"]}},{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"Struct":{"address":"0x2","module":"sui","name":"SUI","typeArguments":[]}}]}}]}}},"kiosk_extension":{"fileFormatVersion":6,"address":"0x2","name":"kiosk_extension","friends":[],"structs":{"Extension":{"abilities":{"abilities":["Store"]},"typeParameters":[],"fields":[{"name":"storage","type":{"Struct":{"address":"0x2","module":"bag","name":"Bag","typeArguments":[]}}},{"name":"permissions","type":"U128"},{"name":"is_enabled","type":"Bool"}]},"ExtensionKey":{"abilities":{"abilities":["Copy","Drop","Store"]},"typeParameters":[{"constraints":{"abilities":[]},"isPhantom":true}],"fields":[{"name":"dummy_field","type":"Bool"}]}},"exposedFunctions":{"add":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Drop"]}],"parameters":[{"TypeParameter":0},{"MutableReference":{"Struct":{"address":"0x2","module":"kiosk","name":"Kiosk","typeArguments":[]}}},{"Reference":{"Struct":{"address":"0x2","module":"kiosk","name":"KioskOwnerCap","typeArguments":[]}}},"U128",{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[]},"can_lock":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Drop"]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"kiosk","name":"Kiosk","typeArguments":[]}}}],"return":["Bool"]},"can_place":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Drop"]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"kiosk","name":"Kiosk","typeArguments":[]}}}],"return":["Bool"]},"disable":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Drop"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"kiosk","name":"Kiosk","typeArguments":[]}}},{"Reference":{"Struct":{"address":"0x2","module":"kiosk","name":"KioskOwnerCap","typeArguments":[]}}}],"return":[]},"enable":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Drop"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"kiosk","name":"Kiosk","typeArguments":[]}}},{"Reference":{"Struct":{"address":"0x2","module":"kiosk","name":"KioskOwnerCap","typeArguments":[]}}}],"return":[]},"is_enabled":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Drop"]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"kiosk","name":"Kiosk","typeArguments":[]}}}],"return":["Bool"]},"is_installed":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Drop"]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"kiosk","name":"Kiosk","typeArguments":[]}}}],"return":["Bool"]},"lock":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Drop"]},{"abilities":["Store","Key"]}],"parameters":[{"TypeParameter":0},{"MutableReference":{"Struct":{"address":"0x2","module":"kiosk","name":"Kiosk","typeArguments":[]}}},{"TypeParameter":1},{"Reference":{"Struct":{"address":"0x2","module":"transfer_policy","name":"TransferPolicy","typeArguments":[{"TypeParameter":1}]}}}],"return":[]},"place":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Drop"]},{"abilities":["Store","Key"]}],"parameters":[{"TypeParameter":0},{"MutableReference":{"Struct":{"address":"0x2","module":"kiosk","name":"Kiosk","typeArguments":[]}}},{"TypeParameter":1},{"Reference":{"Struct":{"address":"0x2","module":"transfer_policy","name":"TransferPolicy","typeArguments":[{"TypeParameter":1}]}}}],"return":[]},"remove":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Drop"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"kiosk","name":"Kiosk","typeArguments":[]}}},{"Reference":{"Struct":{"address":"0x2","module":"kiosk","name":"KioskOwnerCap","typeArguments":[]}}}],"return":[]},"storage":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Drop"]}],"parameters":[{"TypeParameter":0},{"Reference":{"Struct":{"address":"0x2","module":"kiosk","name":"Kiosk","typeArguments":[]}}}],"return":[{"Reference":{"Struct":{"address":"0x2","module":"bag","name":"Bag","typeArguments":[]}}}]},"storage_mut":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Drop"]}],"parameters":[{"TypeParameter":0},{"MutableReference":{"Struct":{"address":"0x2","module":"kiosk","name":"Kiosk","typeArguments":[]}}}],"return":[{"MutableReference":{"Struct":{"address":"0x2","module":"bag","name":"Bag","typeArguments":[]}}}]}}},"linked_table":{"fileFormatVersion":6,"address":"0x2","name":"linked_table","friends":[],"structs":{"LinkedTable":{"abilities":{"abilities":["Store","Key"]},"typeParameters":[{"constraints":{"abilities":["Copy","Drop","Store"]},"isPhantom":false},{"constraints":{"abilities":["Store"]},"isPhantom":true}],"fields":[{"name":"id","type":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}},{"name":"size","type":"U64"},{"name":"head","type":{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":[{"TypeParameter":0}]}}},{"name":"tail","type":{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":[{"TypeParameter":0}]}}}]},"Node":{"abilities":{"abilities":["Store"]},"typeParameters":[{"constraints":{"abilities":["Copy","Drop","Store"]},"isPhantom":false},{"constraints":{"abilities":["Store"]},"isPhantom":false}],"fields":[{"name":"prev","type":{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":[{"TypeParameter":0}]}}},{"name":"next","type":{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":[{"TypeParameter":0}]}}},{"name":"value","type":{"TypeParameter":1}}]}},"exposedFunctions":{"back":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop","Store"]},{"abilities":["Store"]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"linked_table","name":"LinkedTable","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}}],"return":[{"Reference":{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":[{"TypeParameter":0}]}}}]},"borrow":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop","Store"]},{"abilities":["Store"]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"linked_table","name":"LinkedTable","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}},{"TypeParameter":0}],"return":[{"Reference":{"TypeParameter":1}}]},"borrow_mut":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop","Store"]},{"abilities":["Store"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"linked_table","name":"LinkedTable","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}},{"TypeParameter":0}],"return":[{"MutableReference":{"TypeParameter":1}}]},"contains":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop","Store"]},{"abilities":["Store"]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"linked_table","name":"LinkedTable","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}},{"TypeParameter":0}],"return":["Bool"]},"destroy_empty":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop","Store"]},{"abilities":["Store"]}],"parameters":[{"Struct":{"address":"0x2","module":"linked_table","name":"LinkedTable","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}],"return":[]},"drop":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop","Store"]},{"abilities":["Drop","Store"]}],"parameters":[{"Struct":{"address":"0x2","module":"linked_table","name":"LinkedTable","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}],"return":[]},"front":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop","Store"]},{"abilities":["Store"]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"linked_table","name":"LinkedTable","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}}],"return":[{"Reference":{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":[{"TypeParameter":0}]}}}]},"is_empty":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop","Store"]},{"abilities":["Store"]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"linked_table","name":"LinkedTable","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}}],"return":["Bool"]},"length":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop","Store"]},{"abilities":["Store"]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"linked_table","name":"LinkedTable","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}}],"return":["U64"]},"new":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop","Store"]},{"abilities":["Store"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x2","module":"linked_table","name":"LinkedTable","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}]},"next":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop","Store"]},{"abilities":["Store"]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"linked_table","name":"LinkedTable","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}},{"TypeParameter":0}],"return":[{"Reference":{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":[{"TypeParameter":0}]}}}]},"pop_back":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop","Store"]},{"abilities":["Store"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"linked_table","name":"LinkedTable","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}}],"return":[{"TypeParameter":0},{"TypeParameter":1}]},"pop_front":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop","Store"]},{"abilities":["Store"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"linked_table","name":"LinkedTable","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}}],"return":[{"TypeParameter":0},{"TypeParameter":1}]},"prev":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop","Store"]},{"abilities":["Store"]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"linked_table","name":"LinkedTable","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}},{"TypeParameter":0}],"return":[{"Reference":{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":[{"TypeParameter":0}]}}}]},"push_back":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop","Store"]},{"abilities":["Store"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"linked_table","name":"LinkedTable","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}},{"TypeParameter":0},{"TypeParameter":1}],"return":[]},"push_front":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop","Store"]},{"abilities":["Store"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"linked_table","name":"LinkedTable","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}},{"TypeParameter":0},{"TypeParameter":1}],"return":[]},"remove":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop","Store"]},{"abilities":["Store"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"linked_table","name":"LinkedTable","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}},{"TypeParameter":0}],"return":[{"TypeParameter":1}]}}},"math":{"fileFormatVersion":6,"address":"0x2","name":"math","friends":[],"structs":{},"exposedFunctions":{"diff":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U64","U64"],"return":["U64"]},"divide_and_round_up":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U64","U64"],"return":["U64"]},"max":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U64","U64"],"return":["U64"]},"min":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U64","U64"],"return":["U64"]},"pow":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U64","U8"],"return":["U64"]},"sqrt":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U64"],"return":["U64"]},"sqrt_u128":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U128"],"return":["U128"]}}},"object":{"fileFormatVersion":6,"address":"0x2","name":"object","friends":[{"address":"0x2","name":"authenticator_state"},{"address":"0x2","name":"clock"},{"address":"0x2","name":"deny_list"},{"address":"0x2","name":"dynamic_field"},{"address":"0x2","name":"random"}],"structs":{"ID":{"abilities":{"abilities":["Copy","Drop","Store"]},"typeParameters":[],"fields":[{"name":"bytes","type":"Address"}]},"UID":{"abilities":{"abilities":["Store"]},"typeParameters":[],"fields":[{"name":"id","type":{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}}]}},"exposedFunctions":{"authenticator_state":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[],"return":[{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}]},"borrow_id":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Key"]}],"parameters":[{"Reference":{"TypeParameter":0}}],"return":[{"Reference":{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}}]},"clock":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[],"return":[{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}]},"delete":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}],"return":[]},"id":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Key"]}],"parameters":[{"Reference":{"TypeParameter":0}}],"return":[{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}]},"id_address":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Key"]}],"parameters":[{"Reference":{"TypeParameter":0}}],"return":["Address"]},"id_bytes":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Key"]}],"parameters":[{"Reference":{"TypeParameter":0}}],"return":[{"Vector":"U8"}]},"id_from_address":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["Address"],"return":[{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}]},"id_from_bytes":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Vector":"U8"}],"return":[{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}]},"id_to_address":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}}],"return":["Address"]},"id_to_bytes":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}}],"return":[{"Vector":"U8"}]},"new":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}]},"new_uid_from_hash":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":["Address"],"return":[{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}]},"randomness_state":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[],"return":[{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}]},"sui_deny_list_object_id":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[],"return":[{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}]},"uid_as_inner":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}}],"return":[{"Reference":{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}}]},"uid_to_address":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}}],"return":["Address"]},"uid_to_bytes":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}}],"return":[{"Vector":"U8"}]},"uid_to_inner":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}]}}},"object_bag":{"fileFormatVersion":6,"address":"0x2","name":"object_bag","friends":[],"structs":{"ObjectBag":{"abilities":{"abilities":["Store","Key"]},"typeParameters":[],"fields":[{"name":"id","type":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}},{"name":"size","type":"U64"}]}},"exposedFunctions":{"add":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop","Store"]},{"abilities":["Store","Key"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"object_bag","name":"ObjectBag","typeArguments":[]}}},{"TypeParameter":0},{"TypeParameter":1}],"return":[]},"borrow":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop","Store"]},{"abilities":["Store","Key"]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"object_bag","name":"ObjectBag","typeArguments":[]}}},{"TypeParameter":0}],"return":[{"Reference":{"TypeParameter":1}}]},"borrow_mut":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop","Store"]},{"abilities":["Store","Key"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"object_bag","name":"ObjectBag","typeArguments":[]}}},{"TypeParameter":0}],"return":[{"MutableReference":{"TypeParameter":1}}]},"contains":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop","Store"]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"object_bag","name":"ObjectBag","typeArguments":[]}}},{"TypeParameter":0}],"return":["Bool"]},"contains_with_type":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop","Store"]},{"abilities":["Store","Key"]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"object_bag","name":"ObjectBag","typeArguments":[]}}},{"TypeParameter":0}],"return":["Bool"]},"destroy_empty":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Struct":{"address":"0x2","module":"object_bag","name":"ObjectBag","typeArguments":[]}}],"return":[]},"is_empty":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"object_bag","name":"ObjectBag","typeArguments":[]}}}],"return":["Bool"]},"length":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"object_bag","name":"ObjectBag","typeArguments":[]}}}],"return":["U64"]},"new":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x2","module":"object_bag","name":"ObjectBag","typeArguments":[]}}]},"remove":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop","Store"]},{"abilities":["Store","Key"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"object_bag","name":"ObjectBag","typeArguments":[]}}},{"TypeParameter":0}],"return":[{"TypeParameter":1}]},"value_id":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop","Store"]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"object_bag","name":"ObjectBag","typeArguments":[]}}},{"TypeParameter":0}],"return":[{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":[{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}]}}]}}},"object_table":{"fileFormatVersion":6,"address":"0x2","name":"object_table","friends":[],"structs":{"ObjectTable":{"abilities":{"abilities":["Store","Key"]},"typeParameters":[{"constraints":{"abilities":["Copy","Drop","Store"]},"isPhantom":true},{"constraints":{"abilities":["Store","Key"]},"isPhantom":true}],"fields":[{"name":"id","type":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}},{"name":"size","type":"U64"}]}},"exposedFunctions":{"add":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop","Store"]},{"abilities":["Store","Key"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"object_table","name":"ObjectTable","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}},{"TypeParameter":0},{"TypeParameter":1}],"return":[]},"borrow":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop","Store"]},{"abilities":["Store","Key"]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"object_table","name":"ObjectTable","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}},{"TypeParameter":0}],"return":[{"Reference":{"TypeParameter":1}}]},"borrow_mut":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop","Store"]},{"abilities":["Store","Key"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"object_table","name":"ObjectTable","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}},{"TypeParameter":0}],"return":[{"MutableReference":{"TypeParameter":1}}]},"contains":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop","Store"]},{"abilities":["Store","Key"]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"object_table","name":"ObjectTable","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}},{"TypeParameter":0}],"return":["Bool"]},"destroy_empty":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop","Store"]},{"abilities":["Store","Key"]}],"parameters":[{"Struct":{"address":"0x2","module":"object_table","name":"ObjectTable","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}],"return":[]},"is_empty":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop","Store"]},{"abilities":["Store","Key"]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"object_table","name":"ObjectTable","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}}],"return":["Bool"]},"length":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop","Store"]},{"abilities":["Store","Key"]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"object_table","name":"ObjectTable","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}}],"return":["U64"]},"new":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop","Store"]},{"abilities":["Store","Key"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x2","module":"object_table","name":"ObjectTable","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}]},"remove":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop","Store"]},{"abilities":["Store","Key"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"object_table","name":"ObjectTable","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}},{"TypeParameter":0}],"return":[{"TypeParameter":1}]},"value_id":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop","Store"]},{"abilities":["Store","Key"]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"object_table","name":"ObjectTable","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}},{"TypeParameter":0}],"return":[{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":[{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}]}}]}}},"package":{"fileFormatVersion":6,"address":"0x2","name":"package","friends":[],"structs":{"Publisher":{"abilities":{"abilities":["Store","Key"]},"typeParameters":[],"fields":[{"name":"id","type":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}},{"name":"package","type":{"Struct":{"address":"0x1","module":"ascii","name":"String","typeArguments":[]}}},{"name":"module_name","type":{"Struct":{"address":"0x1","module":"ascii","name":"String","typeArguments":[]}}}]},"UpgradeCap":{"abilities":{"abilities":["Store","Key"]},"typeParameters":[],"fields":[{"name":"id","type":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}},{"name":"package","type":{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}},{"name":"version","type":"U64"},{"name":"policy","type":"U8"}]},"UpgradeReceipt":{"abilities":{"abilities":[]},"typeParameters":[],"fields":[{"name":"cap","type":{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}},{"name":"package","type":{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}}]},"UpgradeTicket":{"abilities":{"abilities":[]},"typeParameters":[],"fields":[{"name":"cap","type":{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}},{"name":"package","type":{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}},{"name":"policy","type":"U8"},{"name":"digest","type":{"Vector":"U8"}}]}},"exposedFunctions":{"additive_policy":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[],"return":["U8"]},"authorize_upgrade":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"package","name":"UpgradeCap","typeArguments":[]}}},"U8",{"Vector":"U8"}],"return":[{"Struct":{"address":"0x2","module":"package","name":"UpgradeTicket","typeArguments":[]}}]},"burn_publisher":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Struct":{"address":"0x2","module":"package","name":"Publisher","typeArguments":[]}}],"return":[]},"claim":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Drop"]}],"parameters":[{"TypeParameter":0},{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x2","module":"package","name":"Publisher","typeArguments":[]}}]},"claim_and_keep":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Drop"]}],"parameters":[{"TypeParameter":0},{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[]},"commit_upgrade":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"package","name":"UpgradeCap","typeArguments":[]}}},{"Struct":{"address":"0x2","module":"package","name":"UpgradeReceipt","typeArguments":[]}}],"return":[]},"compatible_policy":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[],"return":["U8"]},"dep_only_policy":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[],"return":["U8"]},"from_module":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"package","name":"Publisher","typeArguments":[]}}}],"return":["Bool"]},"from_package":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"package","name":"Publisher","typeArguments":[]}}}],"return":["Bool"]},"make_immutable":{"visibility":"Public","isEntry":true,"typeParameters":[],"parameters":[{"Struct":{"address":"0x2","module":"package","name":"UpgradeCap","typeArguments":[]}}],"return":[]},"only_additive_upgrades":{"visibility":"Public","isEntry":true,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"package","name":"UpgradeCap","typeArguments":[]}}}],"return":[]},"only_dep_upgrades":{"visibility":"Public","isEntry":true,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"package","name":"UpgradeCap","typeArguments":[]}}}],"return":[]},"published_module":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"package","name":"Publisher","typeArguments":[]}}}],"return":[{"Reference":{"Struct":{"address":"0x1","module":"ascii","name":"String","typeArguments":[]}}}]},"published_package":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"package","name":"Publisher","typeArguments":[]}}}],"return":[{"Reference":{"Struct":{"address":"0x1","module":"ascii","name":"String","typeArguments":[]}}}]},"receipt_cap":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"package","name":"UpgradeReceipt","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}]},"receipt_package":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"package","name":"UpgradeReceipt","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}]},"ticket_digest":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"package","name":"UpgradeTicket","typeArguments":[]}}}],"return":[{"Reference":{"Vector":"U8"}}]},"ticket_package":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"package","name":"UpgradeTicket","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}]},"ticket_policy":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"package","name":"UpgradeTicket","typeArguments":[]}}}],"return":["U8"]},"upgrade_package":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"package","name":"UpgradeCap","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}]},"upgrade_policy":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"package","name":"UpgradeCap","typeArguments":[]}}}],"return":["U8"]},"version":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"package","name":"UpgradeCap","typeArguments":[]}}}],"return":["U64"]}}},"pay":{"fileFormatVersion":6,"address":"0x2","name":"pay","friends":[],"structs":{},"exposedFunctions":{"divide_and_keep":{"visibility":"Public","isEntry":true,"typeParameters":[{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"TypeParameter":0}]}}},"U64",{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[]},"join":{"visibility":"Public","isEntry":true,"typeParameters":[{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"TypeParameter":0}]}}},{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"TypeParameter":0}]}}],"return":[]},"join_vec":{"visibility":"Public","isEntry":true,"typeParameters":[{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"TypeParameter":0}]}}},{"Vector":{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"TypeParameter":0}]}}}],"return":[]},"join_vec_and_transfer":{"visibility":"Public","isEntry":true,"typeParameters":[{"abilities":[]}],"parameters":[{"Vector":{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"TypeParameter":0}]}}},"Address"],"return":[]},"keep":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"TypeParameter":0}]}},{"Reference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[]},"split":{"visibility":"Public","isEntry":true,"typeParameters":[{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"TypeParameter":0}]}}},"U64",{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[]},"split_and_transfer":{"visibility":"Public","isEntry":true,"typeParameters":[{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"TypeParameter":0}]}}},"U64","Address",{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[]},"split_vec":{"visibility":"Public","isEntry":true,"typeParameters":[{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"TypeParameter":0}]}}},{"Vector":"U64"},{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[]}}},"poseidon":{"fileFormatVersion":6,"address":"0x2","name":"poseidon","friends":[],"structs":{},"exposedFunctions":{"poseidon_bn254":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Vector":"U256"}}],"return":["U256"]}}},"priority_queue":{"fileFormatVersion":6,"address":"0x2","name":"priority_queue","friends":[],"structs":{"Entry":{"abilities":{"abilities":["Drop","Store"]},"typeParameters":[{"constraints":{"abilities":["Drop"]},"isPhantom":false}],"fields":[{"name":"priority","type":"U64"},{"name":"value","type":{"TypeParameter":0}}]},"PriorityQueue":{"abilities":{"abilities":["Drop","Store"]},"typeParameters":[{"constraints":{"abilities":["Drop"]},"isPhantom":false}],"fields":[{"name":"entries","type":{"Vector":{"Struct":{"address":"0x2","module":"priority_queue","name":"Entry","typeArguments":[{"TypeParameter":0}]}}}}]}},"exposedFunctions":{"create_entries":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Drop"]}],"parameters":[{"Vector":"U64"},{"Vector":{"TypeParameter":0}}],"return":[{"Vector":{"Struct":{"address":"0x2","module":"priority_queue","name":"Entry","typeArguments":[{"TypeParameter":0}]}}}]},"insert":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Drop"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"priority_queue","name":"PriorityQueue","typeArguments":[{"TypeParameter":0}]}}},"U64",{"TypeParameter":0}],"return":[]},"new":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Drop"]}],"parameters":[{"Vector":{"Struct":{"address":"0x2","module":"priority_queue","name":"Entry","typeArguments":[{"TypeParameter":0}]}}}],"return":[{"Struct":{"address":"0x2","module":"priority_queue","name":"PriorityQueue","typeArguments":[{"TypeParameter":0}]}}]},"new_entry":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Drop"]}],"parameters":["U64",{"TypeParameter":0}],"return":[{"Struct":{"address":"0x2","module":"priority_queue","name":"Entry","typeArguments":[{"TypeParameter":0}]}}]},"pop_max":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Drop"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"priority_queue","name":"PriorityQueue","typeArguments":[{"TypeParameter":0}]}}}],"return":["U64",{"TypeParameter":0}]},"priorities":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Drop"]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"priority_queue","name":"PriorityQueue","typeArguments":[{"TypeParameter":0}]}}}],"return":[{"Vector":"U64"}]}}},"prover":{"fileFormatVersion":6,"address":"0x2","name":"prover","friends":[],"structs":{},"exposedFunctions":{}},"random":{"fileFormatVersion":6,"address":"0x2","name":"random","friends":[],"structs":{"Random":{"abilities":{"abilities":["Key"]},"typeParameters":[],"fields":[{"name":"id","type":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}},{"name":"inner","type":{"Struct":{"address":"0x2","module":"versioned","name":"Versioned","typeArguments":[]}}}]},"RandomGenerator":{"abilities":{"abilities":["Drop"]},"typeParameters":[],"fields":[{"name":"seed","type":{"Vector":"U8"}},{"name":"counter","type":"U16"},{"name":"buffer","type":{"Vector":"U8"}}]},"RandomInner":{"abilities":{"abilities":["Store"]},"typeParameters":[],"fields":[{"name":"version","type":"U64"},{"name":"epoch","type":"U64"},{"name":"randomness_round","type":"U64"},{"name":"random_bytes","type":{"Vector":"U8"}}]}},"exposedFunctions":{"generate_bool":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"random","name":"RandomGenerator","typeArguments":[]}}}],"return":["Bool"]},"generate_bytes":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"random","name":"RandomGenerator","typeArguments":[]}}},"U16"],"return":[{"Vector":"U8"}]},"generate_u128":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"random","name":"RandomGenerator","typeArguments":[]}}}],"return":["U128"]},"generate_u128_in_range":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"random","name":"RandomGenerator","typeArguments":[]}}},"U128","U128"],"return":["U128"]},"generate_u16":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"random","name":"RandomGenerator","typeArguments":[]}}}],"return":["U16"]},"generate_u16_in_range":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"random","name":"RandomGenerator","typeArguments":[]}}},"U16","U16"],"return":["U16"]},"generate_u256":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"random","name":"RandomGenerator","typeArguments":[]}}}],"return":["U256"]},"generate_u32":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"random","name":"RandomGenerator","typeArguments":[]}}}],"return":["U32"]},"generate_u32_in_range":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"random","name":"RandomGenerator","typeArguments":[]}}},"U32","U32"],"return":["U32"]},"generate_u64":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"random","name":"RandomGenerator","typeArguments":[]}}}],"return":["U64"]},"generate_u64_in_range":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"random","name":"RandomGenerator","typeArguments":[]}}},"U64","U64"],"return":["U64"]},"generate_u8":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"random","name":"RandomGenerator","typeArguments":[]}}}],"return":["U8"]},"generate_u8_in_range":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"random","name":"RandomGenerator","typeArguments":[]}}},"U8","U8"],"return":["U8"]},"new_generator":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"random","name":"Random","typeArguments":[]}}},{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x2","module":"random","name":"RandomGenerator","typeArguments":[]}}]},"shuffle":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"random","name":"RandomGenerator","typeArguments":[]}}},{"MutableReference":{"Vector":{"TypeParameter":0}}}],"return":[]}}},"sui":{"fileFormatVersion":6,"address":"0x2","name":"sui","friends":[],"structs":{"SUI":{"abilities":{"abilities":["Drop"]},"typeParameters":[],"fields":[{"name":"dummy_field","type":"Bool"}]}},"exposedFunctions":{"transfer":{"visibility":"Public","isEntry":true,"typeParameters":[],"parameters":[{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"Struct":{"address":"0x2","module":"sui","name":"SUI","typeArguments":[]}}]}},"Address"],"return":[]}}},"table":{"fileFormatVersion":6,"address":"0x2","name":"table","friends":[],"structs":{"Table":{"abilities":{"abilities":["Store","Key"]},"typeParameters":[{"constraints":{"abilities":["Copy","Drop","Store"]},"isPhantom":true},{"constraints":{"abilities":["Store"]},"isPhantom":true}],"fields":[{"name":"id","type":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}},{"name":"size","type":"U64"}]}},"exposedFunctions":{"add":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop","Store"]},{"abilities":["Store"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"table","name":"Table","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}},{"TypeParameter":0},{"TypeParameter":1}],"return":[]},"borrow":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop","Store"]},{"abilities":["Store"]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"table","name":"Table","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}},{"TypeParameter":0}],"return":[{"Reference":{"TypeParameter":1}}]},"borrow_mut":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop","Store"]},{"abilities":["Store"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"table","name":"Table","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}},{"TypeParameter":0}],"return":[{"MutableReference":{"TypeParameter":1}}]},"contains":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop","Store"]},{"abilities":["Store"]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"table","name":"Table","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}},{"TypeParameter":0}],"return":["Bool"]},"destroy_empty":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop","Store"]},{"abilities":["Store"]}],"parameters":[{"Struct":{"address":"0x2","module":"table","name":"Table","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}],"return":[]},"drop":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop","Store"]},{"abilities":["Drop","Store"]}],"parameters":[{"Struct":{"address":"0x2","module":"table","name":"Table","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}],"return":[]},"is_empty":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop","Store"]},{"abilities":["Store"]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"table","name":"Table","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}}],"return":["Bool"]},"length":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop","Store"]},{"abilities":["Store"]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"table","name":"Table","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}}],"return":["U64"]},"new":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop","Store"]},{"abilities":["Store"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x2","module":"table","name":"Table","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}]},"remove":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop","Store"]},{"abilities":["Store"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"table","name":"Table","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}},{"TypeParameter":0}],"return":[{"TypeParameter":1}]}}},"table_vec":{"fileFormatVersion":6,"address":"0x2","name":"table_vec","friends":[],"structs":{"TableVec":{"abilities":{"abilities":["Store"]},"typeParameters":[{"constraints":{"abilities":["Store"]},"isPhantom":true}],"fields":[{"name":"contents","type":{"Struct":{"address":"0x2","module":"table","name":"Table","typeArguments":["U64",{"TypeParameter":0}]}}}]}},"exposedFunctions":{"borrow":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Store"]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"table_vec","name":"TableVec","typeArguments":[{"TypeParameter":0}]}}},"U64"],"return":[{"Reference":{"TypeParameter":0}}]},"borrow_mut":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Store"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"table_vec","name":"TableVec","typeArguments":[{"TypeParameter":0}]}}},"U64"],"return":[{"MutableReference":{"TypeParameter":0}}]},"destroy_empty":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Store"]}],"parameters":[{"Struct":{"address":"0x2","module":"table_vec","name":"TableVec","typeArguments":[{"TypeParameter":0}]}}],"return":[]},"drop":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Drop","Store"]}],"parameters":[{"Struct":{"address":"0x2","module":"table_vec","name":"TableVec","typeArguments":[{"TypeParameter":0}]}}],"return":[]},"empty":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Store"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x2","module":"table_vec","name":"TableVec","typeArguments":[{"TypeParameter":0}]}}]},"is_empty":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Store"]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"table_vec","name":"TableVec","typeArguments":[{"TypeParameter":0}]}}}],"return":["Bool"]},"length":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Store"]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"table_vec","name":"TableVec","typeArguments":[{"TypeParameter":0}]}}}],"return":["U64"]},"pop_back":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Store"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"table_vec","name":"TableVec","typeArguments":[{"TypeParameter":0}]}}}],"return":[{"TypeParameter":0}]},"push_back":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Store"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"table_vec","name":"TableVec","typeArguments":[{"TypeParameter":0}]}}},{"TypeParameter":0}],"return":[]},"singleton":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Store"]}],"parameters":[{"TypeParameter":0},{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x2","module":"table_vec","name":"TableVec","typeArguments":[{"TypeParameter":0}]}}]},"swap":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Store"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"table_vec","name":"TableVec","typeArguments":[{"TypeParameter":0}]}}},"U64","U64"],"return":[]},"swap_remove":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Store"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"table_vec","name":"TableVec","typeArguments":[{"TypeParameter":0}]}}},"U64"],"return":[{"TypeParameter":0}]}}},"token":{"fileFormatVersion":6,"address":"0x2","name":"token","friends":[],"structs":{"ActionRequest":{"abilities":{"abilities":[]},"typeParameters":[{"constraints":{"abilities":[]},"isPhantom":true}],"fields":[{"name":"name","type":{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}},{"name":"amount","type":"U64"},{"name":"sender","type":"Address"},{"name":"recipient","type":{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":["Address"]}}},{"name":"spent_balance","type":{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":[{"Struct":{"address":"0x2","module":"balance","name":"Balance","typeArguments":[{"TypeParameter":0}]}}]}}},{"name":"approvals","type":{"Struct":{"address":"0x2","module":"vec_set","name":"VecSet","typeArguments":[{"Struct":{"address":"0x1","module":"type_name","name":"TypeName","typeArguments":[]}}]}}}]},"RuleKey":{"abilities":{"abilities":["Copy","Drop","Store"]},"typeParameters":[{"constraints":{"abilities":[]},"isPhantom":true}],"fields":[{"name":"is_protected","type":"Bool"}]},"Token":{"abilities":{"abilities":["Key"]},"typeParameters":[{"constraints":{"abilities":[]},"isPhantom":true}],"fields":[{"name":"id","type":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}},{"name":"balance","type":{"Struct":{"address":"0x2","module":"balance","name":"Balance","typeArguments":[{"TypeParameter":0}]}}}]},"TokenPolicy":{"abilities":{"abilities":["Key"]},"typeParameters":[{"constraints":{"abilities":[]},"isPhantom":true}],"fields":[{"name":"id","type":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}},{"name":"spent_balance","type":{"Struct":{"address":"0x2","module":"balance","name":"Balance","typeArguments":[{"TypeParameter":0}]}}},{"name":"rules","type":{"Struct":{"address":"0x2","module":"vec_map","name":"VecMap","typeArguments":[{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}},{"Struct":{"address":"0x2","module":"vec_set","name":"VecSet","typeArguments":[{"Struct":{"address":"0x1","module":"type_name","name":"TypeName","typeArguments":[]}}]}}]}}}]},"TokenPolicyCap":{"abilities":{"abilities":["Store","Key"]},"typeParameters":[{"constraints":{"abilities":[]},"isPhantom":true}],"fields":[{"name":"id","type":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}},{"name":"for","type":{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}}]},"TokenPolicyCreated":{"abilities":{"abilities":["Copy","Drop"]},"typeParameters":[{"constraints":{"abilities":[]},"isPhantom":true}],"fields":[{"name":"id","type":{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}},{"name":"is_mutable","type":"Bool"}]}},"exposedFunctions":{"action":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"token","name":"ActionRequest","typeArguments":[{"TypeParameter":0}]}}}],"return":[{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}]},"add_approval":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]},{"abilities":["Drop"]}],"parameters":[{"TypeParameter":1},{"MutableReference":{"Struct":{"address":"0x2","module":"token","name":"ActionRequest","typeArguments":[{"TypeParameter":0}]}}},{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[]},"add_rule_config":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]},{"abilities":["Drop"]},{"abilities":["Store"]}],"parameters":[{"TypeParameter":1},{"MutableReference":{"Struct":{"address":"0x2","module":"token","name":"TokenPolicy","typeArguments":[{"TypeParameter":0}]}}},{"Reference":{"Struct":{"address":"0x2","module":"token","name":"TokenPolicyCap","typeArguments":[{"TypeParameter":0}]}}},{"TypeParameter":2},{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[]},"add_rule_for_action":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]},{"abilities":["Drop"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"token","name":"TokenPolicy","typeArguments":[{"TypeParameter":0}]}}},{"Reference":{"Struct":{"address":"0x2","module":"token","name":"TokenPolicyCap","typeArguments":[{"TypeParameter":0}]}}},{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}},{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[]},"allow":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"token","name":"TokenPolicy","typeArguments":[{"TypeParameter":0}]}}},{"Reference":{"Struct":{"address":"0x2","module":"token","name":"TokenPolicyCap","typeArguments":[{"TypeParameter":0}]}}},{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}},{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[]},"amount":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"token","name":"ActionRequest","typeArguments":[{"TypeParameter":0}]}}}],"return":["U64"]},"approvals":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"token","name":"ActionRequest","typeArguments":[{"TypeParameter":0}]}}}],"return":[{"Struct":{"address":"0x2","module":"vec_set","name":"VecSet","typeArguments":[{"Struct":{"address":"0x1","module":"type_name","name":"TypeName","typeArguments":[]}}]}}]},"burn":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"coin","name":"TreasuryCap","typeArguments":[{"TypeParameter":0}]}}},{"Struct":{"address":"0x2","module":"token","name":"Token","typeArguments":[{"TypeParameter":0}]}}],"return":[]},"confirm_request":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"token","name":"TokenPolicy","typeArguments":[{"TypeParameter":0}]}}},{"Struct":{"address":"0x2","module":"token","name":"ActionRequest","typeArguments":[{"TypeParameter":0}]}},{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}},"U64","Address",{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":["Address"]}}]},"confirm_request_mut":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"token","name":"TokenPolicy","typeArguments":[{"TypeParameter":0}]}}},{"Struct":{"address":"0x2","module":"token","name":"ActionRequest","typeArguments":[{"TypeParameter":0}]}},{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}},"U64","Address",{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":["Address"]}}]},"confirm_with_policy_cap":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"token","name":"TokenPolicyCap","typeArguments":[{"TypeParameter":0}]}}},{"Struct":{"address":"0x2","module":"token","name":"ActionRequest","typeArguments":[{"TypeParameter":0}]}},{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}},"U64","Address",{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":["Address"]}}]},"confirm_with_treasury_cap":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"coin","name":"TreasuryCap","typeArguments":[{"TypeParameter":0}]}}},{"Struct":{"address":"0x2","module":"token","name":"ActionRequest","typeArguments":[{"TypeParameter":0}]}},{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}},"U64","Address",{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":["Address"]}}]},"destroy_zero":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Struct":{"address":"0x2","module":"token","name":"Token","typeArguments":[{"TypeParameter":0}]}}],"return":[]},"disallow":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"token","name":"TokenPolicy","typeArguments":[{"TypeParameter":0}]}}},{"Reference":{"Struct":{"address":"0x2","module":"token","name":"TokenPolicyCap","typeArguments":[{"TypeParameter":0}]}}},{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}},{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[]},"flush":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"token","name":"TokenPolicy","typeArguments":[{"TypeParameter":0}]}}},{"MutableReference":{"Struct":{"address":"0x2","module":"coin","name":"TreasuryCap","typeArguments":[{"TypeParameter":0}]}}},{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":["U64"]},"from_coin":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"TypeParameter":0}]}},{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x2","module":"token","name":"Token","typeArguments":[{"TypeParameter":0}]}},{"Struct":{"address":"0x2","module":"token","name":"ActionRequest","typeArguments":[{"TypeParameter":0}]}}]},"from_coin_action":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[],"return":[{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}]},"has_rule_config":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]},{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"token","name":"TokenPolicy","typeArguments":[{"TypeParameter":0}]}}}],"return":["Bool"]},"has_rule_config_with_type":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]},{"abilities":[]},{"abilities":["Store"]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"token","name":"TokenPolicy","typeArguments":[{"TypeParameter":0}]}}}],"return":["Bool"]},"is_allowed":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"token","name":"TokenPolicy","typeArguments":[{"TypeParameter":0}]}}},{"Reference":{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}}],"return":["Bool"]},"join":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"token","name":"Token","typeArguments":[{"TypeParameter":0}]}}},{"Struct":{"address":"0x2","module":"token","name":"Token","typeArguments":[{"TypeParameter":0}]}}],"return":[]},"keep":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Struct":{"address":"0x2","module":"token","name":"Token","typeArguments":[{"TypeParameter":0}]}},{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[]},"mint":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"coin","name":"TreasuryCap","typeArguments":[{"TypeParameter":0}]}}},"U64",{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x2","module":"token","name":"Token","typeArguments":[{"TypeParameter":0}]}}]},"new_policy":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"coin","name":"TreasuryCap","typeArguments":[{"TypeParameter":0}]}}},{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x2","module":"token","name":"TokenPolicy","typeArguments":[{"TypeParameter":0}]}},{"Struct":{"address":"0x2","module":"token","name":"TokenPolicyCap","typeArguments":[{"TypeParameter":0}]}}]},"new_request":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}},"U64",{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":["Address"]}},{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":[{"Struct":{"address":"0x2","module":"balance","name":"Balance","typeArguments":[{"TypeParameter":0}]}}]}},{"Reference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x2","module":"token","name":"ActionRequest","typeArguments":[{"TypeParameter":0}]}}]},"recipient":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"token","name":"ActionRequest","typeArguments":[{"TypeParameter":0}]}}}],"return":[{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":["Address"]}}]},"remove_rule_config":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]},{"abilities":[]},{"abilities":["Store"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"token","name":"TokenPolicy","typeArguments":[{"TypeParameter":0}]}}},{"Reference":{"Struct":{"address":"0x2","module":"token","name":"TokenPolicyCap","typeArguments":[{"TypeParameter":0}]}}},{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"TypeParameter":2}]},"remove_rule_for_action":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]},{"abilities":["Drop"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"token","name":"TokenPolicy","typeArguments":[{"TypeParameter":0}]}}},{"Reference":{"Struct":{"address":"0x2","module":"token","name":"TokenPolicyCap","typeArguments":[{"TypeParameter":0}]}}},{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}},{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[]},"rule_config":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]},{"abilities":["Drop"]},{"abilities":["Store"]}],"parameters":[{"TypeParameter":1},{"Reference":{"Struct":{"address":"0x2","module":"token","name":"TokenPolicy","typeArguments":[{"TypeParameter":0}]}}}],"return":[{"Reference":{"TypeParameter":2}}]},"rule_config_mut":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]},{"abilities":["Drop"]},{"abilities":["Store"]}],"parameters":[{"TypeParameter":1},{"MutableReference":{"Struct":{"address":"0x2","module":"token","name":"TokenPolicy","typeArguments":[{"TypeParameter":0}]}}},{"Reference":{"Struct":{"address":"0x2","module":"token","name":"TokenPolicyCap","typeArguments":[{"TypeParameter":0}]}}}],"return":[{"MutableReference":{"TypeParameter":2}}]},"rules":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"token","name":"TokenPolicy","typeArguments":[{"TypeParameter":0}]}}},{"Reference":{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x2","module":"vec_set","name":"VecSet","typeArguments":[{"Struct":{"address":"0x1","module":"type_name","name":"TypeName","typeArguments":[]}}]}}]},"sender":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"token","name":"ActionRequest","typeArguments":[{"TypeParameter":0}]}}}],"return":["Address"]},"share_policy":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Struct":{"address":"0x2","module":"token","name":"TokenPolicy","typeArguments":[{"TypeParameter":0}]}}],"return":[]},"spend":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Struct":{"address":"0x2","module":"token","name":"Token","typeArguments":[{"TypeParameter":0}]}},{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x2","module":"token","name":"ActionRequest","typeArguments":[{"TypeParameter":0}]}}]},"spend_action":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[],"return":[{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}]},"spent":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"token","name":"ActionRequest","typeArguments":[{"TypeParameter":0}]}}}],"return":[{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":["U64"]}}]},"spent_balance":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"token","name":"TokenPolicy","typeArguments":[{"TypeParameter":0}]}}}],"return":["U64"]},"split":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"token","name":"Token","typeArguments":[{"TypeParameter":0}]}}},"U64",{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x2","module":"token","name":"Token","typeArguments":[{"TypeParameter":0}]}}]},"to_coin":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Struct":{"address":"0x2","module":"token","name":"Token","typeArguments":[{"TypeParameter":0}]}},{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"TypeParameter":0}]}},{"Struct":{"address":"0x2","module":"token","name":"ActionRequest","typeArguments":[{"TypeParameter":0}]}}]},"to_coin_action":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[],"return":[{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}]},"transfer":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Struct":{"address":"0x2","module":"token","name":"Token","typeArguments":[{"TypeParameter":0}]}},"Address",{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x2","module":"token","name":"ActionRequest","typeArguments":[{"TypeParameter":0}]}}]},"transfer_action":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[],"return":[{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}]},"value":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"token","name":"Token","typeArguments":[{"TypeParameter":0}]}}}],"return":["U64"]},"zero":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x2","module":"token","name":"Token","typeArguments":[{"TypeParameter":0}]}}]}}},"transfer":{"fileFormatVersion":6,"address":"0x2","name":"transfer","friends":[],"structs":{"Receiving":{"abilities":{"abilities":["Drop"]},"typeParameters":[{"constraints":{"abilities":["Key"]},"isPhantom":true}],"fields":[{"name":"id","type":{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}},{"name":"version","type":"U64"}]}},"exposedFunctions":{"freeze_object":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Key"]}],"parameters":[{"TypeParameter":0}],"return":[]},"freeze_object_impl":{"visibility":"Friend","isEntry":false,"typeParameters":[{"abilities":["Key"]}],"parameters":[{"TypeParameter":0}],"return":[]},"public_freeze_object":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Store","Key"]}],"parameters":[{"TypeParameter":0}],"return":[]},"public_receive":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Store","Key"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}},{"Struct":{"address":"0x2","module":"transfer","name":"Receiving","typeArguments":[{"TypeParameter":0}]}}],"return":[{"TypeParameter":0}]},"public_share_object":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Store","Key"]}],"parameters":[{"TypeParameter":0}],"return":[]},"public_transfer":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Store","Key"]}],"parameters":[{"TypeParameter":0},"Address"],"return":[]},"receive":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Key"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}},{"Struct":{"address":"0x2","module":"transfer","name":"Receiving","typeArguments":[{"TypeParameter":0}]}}],"return":[{"TypeParameter":0}]},"receiving_object_id":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Key"]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"transfer","name":"Receiving","typeArguments":[{"TypeParameter":0}]}}}],"return":[{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}]},"share_object":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Key"]}],"parameters":[{"TypeParameter":0}],"return":[]},"share_object_impl":{"visibility":"Friend","isEntry":false,"typeParameters":[{"abilities":["Key"]}],"parameters":[{"TypeParameter":0}],"return":[]},"transfer":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Key"]}],"parameters":[{"TypeParameter":0},"Address"],"return":[]},"transfer_impl":{"visibility":"Friend","isEntry":false,"typeParameters":[{"abilities":["Key"]}],"parameters":[{"TypeParameter":0},"Address"],"return":[]}}},"transfer_policy":{"fileFormatVersion":6,"address":"0x2","name":"transfer_policy","friends":[],"structs":{"RuleKey":{"abilities":{"abilities":["Copy","Drop","Store"]},"typeParameters":[{"constraints":{"abilities":["Drop"]},"isPhantom":true}],"fields":[{"name":"dummy_field","type":"Bool"}]},"TransferPolicy":{"abilities":{"abilities":["Store","Key"]},"typeParameters":[{"constraints":{"abilities":[]},"isPhantom":true}],"fields":[{"name":"id","type":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}},{"name":"balance","type":{"Struct":{"address":"0x2","module":"balance","name":"Balance","typeArguments":[{"Struct":{"address":"0x2","module":"sui","name":"SUI","typeArguments":[]}}]}}},{"name":"rules","type":{"Struct":{"address":"0x2","module":"vec_set","name":"VecSet","typeArguments":[{"Struct":{"address":"0x1","module":"type_name","name":"TypeName","typeArguments":[]}}]}}}]},"TransferPolicyCap":{"abilities":{"abilities":["Store","Key"]},"typeParameters":[{"constraints":{"abilities":[]},"isPhantom":true}],"fields":[{"name":"id","type":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}},{"name":"policy_id","type":{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}}]},"TransferPolicyCreated":{"abilities":{"abilities":["Copy","Drop"]},"typeParameters":[{"constraints":{"abilities":[]},"isPhantom":true}],"fields":[{"name":"id","type":{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}}]},"TransferPolicyDestroyed":{"abilities":{"abilities":["Copy","Drop"]},"typeParameters":[{"constraints":{"abilities":[]},"isPhantom":true}],"fields":[{"name":"id","type":{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}}]},"TransferRequest":{"abilities":{"abilities":[]},"typeParameters":[{"constraints":{"abilities":[]},"isPhantom":true}],"fields":[{"name":"item","type":{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}},{"name":"paid","type":"U64"},{"name":"from","type":{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}},{"name":"receipts","type":{"Struct":{"address":"0x2","module":"vec_set","name":"VecSet","typeArguments":[{"Struct":{"address":"0x1","module":"type_name","name":"TypeName","typeArguments":[]}}]}}}]}},"exposedFunctions":{"add_receipt":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]},{"abilities":["Drop"]}],"parameters":[{"TypeParameter":1},{"MutableReference":{"Struct":{"address":"0x2","module":"transfer_policy","name":"TransferRequest","typeArguments":[{"TypeParameter":0}]}}}],"return":[]},"add_rule":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]},{"abilities":["Drop"]},{"abilities":["Drop","Store"]}],"parameters":[{"TypeParameter":1},{"MutableReference":{"Struct":{"address":"0x2","module":"transfer_policy","name":"TransferPolicy","typeArguments":[{"TypeParameter":0}]}}},{"Reference":{"Struct":{"address":"0x2","module":"transfer_policy","name":"TransferPolicyCap","typeArguments":[{"TypeParameter":0}]}}},{"TypeParameter":2}],"return":[]},"add_to_balance":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]},{"abilities":["Drop"]}],"parameters":[{"TypeParameter":1},{"MutableReference":{"Struct":{"address":"0x2","module":"transfer_policy","name":"TransferPolicy","typeArguments":[{"TypeParameter":0}]}}},{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"Struct":{"address":"0x2","module":"sui","name":"SUI","typeArguments":[]}}]}}],"return":[]},"confirm_request":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"transfer_policy","name":"TransferPolicy","typeArguments":[{"TypeParameter":0}]}}},{"Struct":{"address":"0x2","module":"transfer_policy","name":"TransferRequest","typeArguments":[{"TypeParameter":0}]}}],"return":[{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}},"U64",{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}]},"default":{"visibility":"Private","isEntry":true,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"package","name":"Publisher","typeArguments":[]}}},{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[]},"destroy_and_withdraw":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Struct":{"address":"0x2","module":"transfer_policy","name":"TransferPolicy","typeArguments":[{"TypeParameter":0}]}},{"Struct":{"address":"0x2","module":"transfer_policy","name":"TransferPolicyCap","typeArguments":[{"TypeParameter":0}]}},{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"Struct":{"address":"0x2","module":"sui","name":"SUI","typeArguments":[]}}]}}]},"from":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"transfer_policy","name":"TransferRequest","typeArguments":[{"TypeParameter":0}]}}}],"return":[{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}]},"get_rule":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]},{"abilities":["Drop"]},{"abilities":["Drop","Store"]}],"parameters":[{"TypeParameter":1},{"Reference":{"Struct":{"address":"0x2","module":"transfer_policy","name":"TransferPolicy","typeArguments":[{"TypeParameter":0}]}}}],"return":[{"Reference":{"TypeParameter":2}}]},"has_rule":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]},{"abilities":["Drop"]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"transfer_policy","name":"TransferPolicy","typeArguments":[{"TypeParameter":0}]}}}],"return":["Bool"]},"item":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"transfer_policy","name":"TransferRequest","typeArguments":[{"TypeParameter":0}]}}}],"return":[{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}]},"new":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"package","name":"Publisher","typeArguments":[]}}},{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x2","module":"transfer_policy","name":"TransferPolicy","typeArguments":[{"TypeParameter":0}]}},{"Struct":{"address":"0x2","module":"transfer_policy","name":"TransferPolicyCap","typeArguments":[{"TypeParameter":0}]}}]},"new_request":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}},"U64",{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}],"return":[{"Struct":{"address":"0x2","module":"transfer_policy","name":"TransferRequest","typeArguments":[{"TypeParameter":0}]}}]},"paid":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"transfer_policy","name":"TransferRequest","typeArguments":[{"TypeParameter":0}]}}}],"return":["U64"]},"remove_rule":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]},{"abilities":["Drop"]},{"abilities":["Drop","Store"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"transfer_policy","name":"TransferPolicy","typeArguments":[{"TypeParameter":0}]}}},{"Reference":{"Struct":{"address":"0x2","module":"transfer_policy","name":"TransferPolicyCap","typeArguments":[{"TypeParameter":0}]}}}],"return":[]},"rules":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"transfer_policy","name":"TransferPolicy","typeArguments":[{"TypeParameter":0}]}}}],"return":[{"Reference":{"Struct":{"address":"0x2","module":"vec_set","name":"VecSet","typeArguments":[{"Struct":{"address":"0x1","module":"type_name","name":"TypeName","typeArguments":[]}}]}}}]},"uid":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"transfer_policy","name":"TransferPolicy","typeArguments":[{"TypeParameter":0}]}}}],"return":[{"Reference":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}}]},"uid_mut_as_owner":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"transfer_policy","name":"TransferPolicy","typeArguments":[{"TypeParameter":0}]}}},{"Reference":{"Struct":{"address":"0x2","module":"transfer_policy","name":"TransferPolicyCap","typeArguments":[{"TypeParameter":0}]}}}],"return":[{"MutableReference":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}}]},"withdraw":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"transfer_policy","name":"TransferPolicy","typeArguments":[{"TypeParameter":0}]}}},{"Reference":{"Struct":{"address":"0x2","module":"transfer_policy","name":"TransferPolicyCap","typeArguments":[{"TypeParameter":0}]}}},{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":["U64"]}},{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"Struct":{"address":"0x2","module":"sui","name":"SUI","typeArguments":[]}}]}}]}}},"tx_context":{"fileFormatVersion":6,"address":"0x2","name":"tx_context","friends":[],"structs":{"TxContext":{"abilities":{"abilities":["Drop"]},"typeParameters":[],"fields":[{"name":"sender","type":"Address"},{"name":"tx_hash","type":{"Vector":"U8"}},{"name":"epoch","type":"U64"},{"name":"epoch_timestamp_ms","type":"U64"},{"name":"ids_created","type":"U64"}]}},"exposedFunctions":{"digest":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Reference":{"Vector":"U8"}}]},"epoch":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":["U64"]},"epoch_timestamp_ms":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":["U64"]},"fresh_object_address":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":["Address"]},"sender":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":["Address"]}}},"types":{"fileFormatVersion":6,"address":"0x2","name":"types","friends":[],"structs":{},"exposedFunctions":{"is_one_time_witness":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Drop"]}],"parameters":[{"Reference":{"TypeParameter":0}}],"return":["Bool"]}}},"url":{"fileFormatVersion":6,"address":"0x2","name":"url","friends":[],"structs":{"Url":{"abilities":{"abilities":["Copy","Drop","Store"]},"typeParameters":[],"fields":[{"name":"url","type":{"Struct":{"address":"0x1","module":"ascii","name":"String","typeArguments":[]}}}]}},"exposedFunctions":{"inner_url":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"url","name":"Url","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x1","module":"ascii","name":"String","typeArguments":[]}}]},"new_unsafe":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Struct":{"address":"0x1","module":"ascii","name":"String","typeArguments":[]}}],"return":[{"Struct":{"address":"0x2","module":"url","name":"Url","typeArguments":[]}}]},"new_unsafe_from_bytes":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Vector":"U8"}],"return":[{"Struct":{"address":"0x2","module":"url","name":"Url","typeArguments":[]}}]},"update":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"url","name":"Url","typeArguments":[]}}},{"Struct":{"address":"0x1","module":"ascii","name":"String","typeArguments":[]}}],"return":[]}}},"vdf":{"fileFormatVersion":6,"address":"0x2","name":"vdf","friends":[],"structs":{},"exposedFunctions":{"hash_to_input":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Vector":"U8"}}],"return":[{"Vector":"U8"}]},"vdf_verify":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Vector":"U8"}},{"Reference":{"Vector":"U8"}},{"Reference":{"Vector":"U8"}},"U64"],"return":["Bool"]}}},"vec_map":{"fileFormatVersion":6,"address":"0x2","name":"vec_map","friends":[],"structs":{"Entry":{"abilities":{"abilities":["Copy","Drop","Store"]},"typeParameters":[{"constraints":{"abilities":["Copy"]},"isPhantom":false},{"constraints":{"abilities":[]},"isPhantom":false}],"fields":[{"name":"key","type":{"TypeParameter":0}},{"name":"value","type":{"TypeParameter":1}}]},"VecMap":{"abilities":{"abilities":["Copy","Drop","Store"]},"typeParameters":[{"constraints":{"abilities":["Copy"]},"isPhantom":false},{"constraints":{"abilities":[]},"isPhantom":false}],"fields":[{"name":"contents","type":{"Vector":{"Struct":{"address":"0x2","module":"vec_map","name":"Entry","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}}}]}},"exposedFunctions":{"contains":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy"]},{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"vec_map","name":"VecMap","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}},{"Reference":{"TypeParameter":0}}],"return":["Bool"]},"destroy_empty":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy"]},{"abilities":[]}],"parameters":[{"Struct":{"address":"0x2","module":"vec_map","name":"VecMap","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}],"return":[]},"empty":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy"]},{"abilities":[]}],"parameters":[],"return":[{"Struct":{"address":"0x2","module":"vec_map","name":"VecMap","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}]},"from_keys_values":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy"]},{"abilities":[]}],"parameters":[{"Vector":{"TypeParameter":0}},{"Vector":{"TypeParameter":1}}],"return":[{"Struct":{"address":"0x2","module":"vec_map","name":"VecMap","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}]},"get":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy"]},{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"vec_map","name":"VecMap","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}},{"Reference":{"TypeParameter":0}}],"return":[{"Reference":{"TypeParameter":1}}]},"get_entry_by_idx":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy"]},{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"vec_map","name":"VecMap","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}},"U64"],"return":[{"Reference":{"TypeParameter":0}},{"Reference":{"TypeParameter":1}}]},"get_entry_by_idx_mut":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy"]},{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"vec_map","name":"VecMap","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}},"U64"],"return":[{"Reference":{"TypeParameter":0}},{"MutableReference":{"TypeParameter":1}}]},"get_idx":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy"]},{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"vec_map","name":"VecMap","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}},{"Reference":{"TypeParameter":0}}],"return":["U64"]},"get_idx_opt":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy"]},{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"vec_map","name":"VecMap","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}},{"Reference":{"TypeParameter":0}}],"return":[{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":["U64"]}}]},"get_mut":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy"]},{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"vec_map","name":"VecMap","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}},{"Reference":{"TypeParameter":0}}],"return":[{"MutableReference":{"TypeParameter":1}}]},"insert":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy"]},{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"vec_map","name":"VecMap","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}},{"TypeParameter":0},{"TypeParameter":1}],"return":[]},"into_keys_values":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy"]},{"abilities":[]}],"parameters":[{"Struct":{"address":"0x2","module":"vec_map","name":"VecMap","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}],"return":[{"Vector":{"TypeParameter":0}},{"Vector":{"TypeParameter":1}}]},"is_empty":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy"]},{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"vec_map","name":"VecMap","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}}],"return":["Bool"]},"keys":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy"]},{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"vec_map","name":"VecMap","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}}],"return":[{"Vector":{"TypeParameter":0}}]},"pop":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy"]},{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"vec_map","name":"VecMap","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}}],"return":[{"TypeParameter":0},{"TypeParameter":1}]},"remove":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy"]},{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"vec_map","name":"VecMap","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}},{"Reference":{"TypeParameter":0}}],"return":[{"TypeParameter":0},{"TypeParameter":1}]},"remove_entry_by_idx":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy"]},{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"vec_map","name":"VecMap","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}},"U64"],"return":[{"TypeParameter":0},{"TypeParameter":1}]},"size":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy"]},{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"vec_map","name":"VecMap","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}}],"return":["U64"]},"try_get":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy"]},{"abilities":["Copy"]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"vec_map","name":"VecMap","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}},{"Reference":{"TypeParameter":0}}],"return":[{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":[{"TypeParameter":1}]}}]}}},"vec_set":{"fileFormatVersion":6,"address":"0x2","name":"vec_set","friends":[],"structs":{"VecSet":{"abilities":{"abilities":["Copy","Drop","Store"]},"typeParameters":[{"constraints":{"abilities":["Copy","Drop"]},"isPhantom":false}],"fields":[{"name":"contents","type":{"Vector":{"TypeParameter":0}}}]}},"exposedFunctions":{"contains":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop"]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"vec_set","name":"VecSet","typeArguments":[{"TypeParameter":0}]}}},{"Reference":{"TypeParameter":0}}],"return":["Bool"]},"empty":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop"]}],"parameters":[],"return":[{"Struct":{"address":"0x2","module":"vec_set","name":"VecSet","typeArguments":[{"TypeParameter":0}]}}]},"from_keys":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop"]}],"parameters":[{"Vector":{"TypeParameter":0}}],"return":[{"Struct":{"address":"0x2","module":"vec_set","name":"VecSet","typeArguments":[{"TypeParameter":0}]}}]},"insert":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"vec_set","name":"VecSet","typeArguments":[{"TypeParameter":0}]}}},{"TypeParameter":0}],"return":[]},"into_keys":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop"]}],"parameters":[{"Struct":{"address":"0x2","module":"vec_set","name":"VecSet","typeArguments":[{"TypeParameter":0}]}}],"return":[{"Vector":{"TypeParameter":0}}]},"is_empty":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop"]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"vec_set","name":"VecSet","typeArguments":[{"TypeParameter":0}]}}}],"return":["Bool"]},"keys":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop"]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"vec_set","name":"VecSet","typeArguments":[{"TypeParameter":0}]}}}],"return":[{"Reference":{"Vector":{"TypeParameter":0}}}]},"remove":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"vec_set","name":"VecSet","typeArguments":[{"TypeParameter":0}]}}},{"Reference":{"TypeParameter":0}}],"return":[]},"singleton":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop"]}],"parameters":[{"TypeParameter":0}],"return":[{"Struct":{"address":"0x2","module":"vec_set","name":"VecSet","typeArguments":[{"TypeParameter":0}]}}]},"size":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop"]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"vec_set","name":"VecSet","typeArguments":[{"TypeParameter":0}]}}}],"return":["U64"]}}},"versioned":{"fileFormatVersion":6,"address":"0x2","name":"versioned","friends":[],"structs":{"VersionChangeCap":{"abilities":{"abilities":[]},"typeParameters":[],"fields":[{"name":"versioned_id","type":{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}},{"name":"old_version","type":"U64"}]},"Versioned":{"abilities":{"abilities":["Store","Key"]},"typeParameters":[],"fields":[{"name":"id","type":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}},{"name":"version","type":"U64"}]}},"exposedFunctions":{"create":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Store"]}],"parameters":["U64",{"TypeParameter":0},{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x2","module":"versioned","name":"Versioned","typeArguments":[]}}]},"destroy":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Store"]}],"parameters":[{"Struct":{"address":"0x2","module":"versioned","name":"Versioned","typeArguments":[]}}],"return":[{"TypeParameter":0}]},"load_value":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Store"]}],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"versioned","name":"Versioned","typeArguments":[]}}}],"return":[{"Reference":{"TypeParameter":0}}]},"load_value_mut":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Store"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"versioned","name":"Versioned","typeArguments":[]}}}],"return":[{"MutableReference":{"TypeParameter":0}}]},"remove_value_for_upgrade":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Store"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"versioned","name":"Versioned","typeArguments":[]}}}],"return":[{"TypeParameter":0},{"Struct":{"address":"0x2","module":"versioned","name":"VersionChangeCap","typeArguments":[]}}]},"upgrade":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Store"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"versioned","name":"Versioned","typeArguments":[]}}},"U64",{"TypeParameter":0},{"Struct":{"address":"0x2","module":"versioned","name":"VersionChangeCap","typeArguments":[]}}],"return":[]},"version":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"versioned","name":"Versioned","typeArguments":[]}}}],"return":["U64"]}}},"zklogin_verified_id":{"fileFormatVersion":6,"address":"0x2","name":"zklogin_verified_id","friends":[],"structs":{"VerifiedID":{"abilities":{"abilities":["Key"]},"typeParameters":[],"fields":[{"name":"id","type":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}},{"name":"owner","type":"Address"},{"name":"key_claim_name","type":{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}},{"name":"key_claim_value","type":{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}},{"name":"issuer","type":{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}},{"name":"audience","type":{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}}]}},"exposedFunctions":{"audience":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"zklogin_verified_id","name":"VerifiedID","typeArguments":[]}}}],"return":[{"Reference":{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}}]},"check_zklogin_id":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["Address",{"Reference":{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}},{"Reference":{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}},{"Reference":{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}},{"Reference":{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}},"U256"],"return":["Bool"]},"delete":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Struct":{"address":"0x2","module":"zklogin_verified_id","name":"VerifiedID","typeArguments":[]}}],"return":[]},"issuer":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"zklogin_verified_id","name":"VerifiedID","typeArguments":[]}}}],"return":[{"Reference":{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}}]},"key_claim_name":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"zklogin_verified_id","name":"VerifiedID","typeArguments":[]}}}],"return":[{"Reference":{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}}]},"key_claim_value":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"zklogin_verified_id","name":"VerifiedID","typeArguments":[]}}}],"return":[{"Reference":{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}}]},"owner":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"zklogin_verified_id","name":"VerifiedID","typeArguments":[]}}}],"return":["Address"]},"verify_zklogin_id":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}},{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}},{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}},{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}},"U256",{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[]}}},"zklogin_verified_issuer":{"fileFormatVersion":6,"address":"0x2","name":"zklogin_verified_issuer","friends":[],"structs":{"VerifiedIssuer":{"abilities":{"abilities":["Key"]},"typeParameters":[],"fields":[{"name":"id","type":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}},{"name":"owner","type":"Address"},{"name":"issuer","type":{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}}]}},"exposedFunctions":{"check_zklogin_issuer":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["Address","U256",{"Reference":{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}}],"return":["Bool"]},"delete":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Struct":{"address":"0x2","module":"zklogin_verified_issuer","name":"VerifiedIssuer","typeArguments":[]}}],"return":[]},"issuer":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"zklogin_verified_issuer","name":"VerifiedIssuer","typeArguments":[]}}}],"return":[{"Reference":{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}}]},"owner":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x2","module":"zklogin_verified_issuer","name":"VerifiedIssuer","typeArguments":[]}}}],"return":["Address"]},"verify_zklogin_issuer":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U256",{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}},{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[]}}}}',
);

export function loadAllTypes(coder: MoveCoder) {
  _0x1.loadAllTypes(coder);
  for (const m of Object.values(MODULES)) {
    coder.load(m as any, "0x2");
  }
}

loadAllTypes(defaultMoveCoder());
